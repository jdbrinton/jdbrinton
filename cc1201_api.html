
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>CC1201 API</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.tailwindcss.com?plugins=typography"></script>
    <script>
        tailwind.config = {
        }
    </script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css">
    <link rel="shortcut icon" href="https://chatboxai.app/icon.png">
</head>
<body class='bg-slate-100'>
    <div class='mx-auto max-w-5xl shadow-md prose bg-white px-2 py-4'>
        <h1 class='flex flex-row justify-between items-center my-4 h-8'>
            <span>CC1201 API</span>
            <a href="https://chatboxai.app" target="_blank" >
                <img src='https://chatboxai.app/icon.png' class="w-12">
            </a>
        </h1>
        <hr />
        <div class="prose-sm">
<h2>1. CC1201 API</h2>
<div class="mb-4">
<p class="text-green-500 text-lg"><b>SYSTEM: </b></p>
<div class="break-words "><p>You are a helpful assistant. You can help me by answering my questions. You can also ask me questions. I am a physicist and electrical engineer. I am also knowledgeable in mechanical engineering, software engineering, and I&#x27;m familiar with C/C++, python, javascript, Matlab, and LLMs.</p></div></div>
<div class="mb-4">
<p class="text-green-500 text-lg"><b>USER: </b></p>
<div class="break-words "><p>generate me a full comprehensive C API for this CC1201 transceiver using an OSI pattern. assume the SPI interface already exists. implement everything (no commented code left for implementer).</p>
<p>CC120X<br/>
CC120X Low-Power High Performance<br/>
Sub-1 GHz RF Transceivers<br/>
User’s Guide<br/>
SWRU346B Page 1 of 114CC120X<br/>
Abbreviations<br/>
Abbreviations used in this data sheet are described below.<br/>
2-FSK Binary Frequency Shift Keying LO Local Oscillator<br/>
4-FSK Quaternary Frequency Shift Keying LSB Least Significant Bit<br/>
ACP Adjacent Channel Power LQI Link Quality Indicator<br/>
ADC Analog to Digital Converter MCU Microcontroller Unit<br/>
AES Advanced Encryption Standard MSB Most Significant Bit<br/>
AFC Automatic Frequency Compensation MSK Minimum Shift Keying<br/>
AGC Automatic Gain Control NRNSC Non-recursive Non-systematic Convolutional<br/>
ASK Amplitude Shift Keying OOK On-Off Keying<br/>
BIST Built-In Self-Test PA Power Amplifier<br/>
BT Bandwidth-Time Product PD Power Down<br/>
CCA Clear Channel Assessment PER Packet Error Rate<br/>
CRC Cyclic Redundancy Check PLL Phase Locked Loop<br/>
CS Carrier Sense POR Power-On Reset<br/>
DC Direct Current PQT Preamble Quality Threshold<br/>
CFM Custom Frequency Modulation PTAT Proportional to Absolute Temperature<br/>
ESR Equivalent Series Resistance QPSK Quadrature Phase Shift Keying<br/>
FCC Federal Communications Commission RC Resistor-Capacitor<br/>
FEC Forward Error Correction RF Radio Frequency<br/>
FIFO First-In-First-Out RSSI Received Signal Strength Indicator<br/>
FHSS Frequency Hopping Spread Spectrum RX Receive, Receive Mode<br/>
FS Frequency Synthesizer RXDCM RX Duty Cycle Mode<br/>
GFSK Gaussian shaped Frequency Shift Keying SPI Serial Peripheral Interface<br/>
GPIO General Purpose Input/Output SRD Short Range Devices<br/>
IF Intermediate Frequency TX Transmit, Transmit Mode<br/>
I/Q In-Phase/Quadrature VCO Voltage Controlled Oscillator<br/>
ISM Industrial, Scientific, Medical eWOR Enhanced Wake on Radio<br/>
kbps kilo bit per second XOSC Crystal Oscillator<br/>
ksps kilo symbol per second XTAL Crystal<br/>
LNA Low Noise Amplifier<br/>
SWRU346B Page 2 of 114CC120X<br/>
Table of Contents<br/>
ABBREVIATIONS ............................................................................................................................................... 2<br/>
TABLE OF CONTENTS ..................................................................................................................................... 3<br/>
1 OVERVIEW .............................................................................................................................................. 5<br/>
2 CONFIGURATION SOFTWARE .......................................................................................................... 6<br/>
3 MICROCONTROLLER INTERFACE ................................................................................................. 7<br/>
3.1 CONFIGURATION ......................................................................................................................................... 7<br/>
3.2 SPI ACCESS TYPES ...................................................................................................................................... 9<br/>
3.3 OPTIONAL PIN CTRL RADIO CONTROL FEATURE .................................................................................... 17<br/>
3.4 GENERAL PURPOSE INPUT/OUTPUT CONTROL PINS .................................................................................. 17<br/>
4 ON-CHIP TEMPERATURE SENSOR ................................................................................................ 22<br/>
5 COMMON RECEIVE AND TRANSMIT CONFIGURATIONS ...................................................... 23<br/>
5.1 DATA COMMUNICATION MODES ............................................................................................................... 23<br/>
5.2 MODULATION FORMATS ............................................................................................................................ 24<br/>
5.3 FORWARD ERROR CORRECTION ................................................................................................................ 29<br/>
5.4 SYMBOL RATE PROGRAMMING ................................................................................................................. 29<br/>
6 RECEIVE CONFIGURATION ............................................................................................................ 30<br/>
6.1 RX FILTER BANDWIDTH ............................................................................................................................ 30<br/>
6.2 DC OFFSET REMOVAL ............................................................................................................................... 31<br/>
6.3 FEEDBACK TO PLL .................................................................................................................................... 32<br/>
6.4 AUTOMATIC GAIN CONTROL ..................................................................................................................... 33<br/>
6.5 IMAGE COMPENSATION ............................................................................................................................. 34<br/>
6.6 BIT SYNCHRONIZATION ............................................................................................................................. 35<br/>
6.7 BYTE SYNCHRONIZATION, SYNC WORD DETECTION ................................................................................. 35<br/>
6.8 PREAMBLE DETECTION ............................................................................................................................. 36<br/>
6.9 RSSI .......................................................................................................................................................... 37<br/>
6.10 COLLISION DETECTOR ............................................................................................................................... 42<br/>
6.11 CLEAR CHANNEL ASSESSMENT (CCA) ..................................................................................................... 42<br/>
6.12 LISTEN BEFORE TALK (LBT) .................................................................................................................... 43<br/>
6.13 LINK QUALITY INDICATOR (LQI) .............................................................................................................. 43<br/>
7 TRANSMIT CONFIGURATION ......................................................................................................... 44<br/>
7.1 PA OUTPUT POWER PROGRAMMING ......................................................................................................... 44<br/>
7.2 OOK/ASK BIT SHAPING ........................................................................................................................... 45<br/>
8 PACKET HANDLING HARDWARE SUPPORT .............................................................................. 46<br/>
8.1 STANDARD PACKET FORMAT .................................................................................................................... 46<br/>
8.2 PACKET FILTERING IN RECEIVE MODE ...................................................................................................... 52<br/>
8.3 PACKET HANDLING IN TRANSMIT MODE ................................................................................................... 53<br/>
8.4 PACKET HANDLING IN RECEIVE MODE ..................................................................................................... 53<br/>
8.5 PACKET HANDLING IN FIRMWARE ............................................................................................................. 53<br/>
8.6 TX FIFO AND RX FIFO ............................................................................................................................ 54<br/>
8.7 IEEE 802.15.4G SUPPORT ......................................................................................................................... 55<br/>
8.8 802.15.4G FRAME CHECK SEQUENCE (FCS) ............................................................................................. 59<br/>
8.9 TRANSPARENT AND SYNCHRONOUS SERIAL OPERATION .......................................................................... 59<br/>
9 RADIO CONTROL ................................................................................................................................ 62<br/>
9.1 POWER-ON START-UP SEQUENCE ............................................................................................................. 62<br/>
9.2 CRYSTAL CONTROL ................................................................................................................................... 62<br/>
9.3 VOLTAGE REGULATOR CONTROL .............................................................................................................. 62<br/>
9.4 ACTIVE MODES ......................................................................................................................................... 63<br/>
9.5 RX TERMINATION ..................................................................................................................................... 64<br/>
9.6 ENHANCED WAKE ON RADIO (EWOR) ...................................................................................................... 67<br/>
9.7 RX SNIFF MODE ........................................................................................................................................ 70<br/>
9.8 RX DUTY CYCLE MODE ............................................................................................................................ 72<br/>
9.9 RC OSCILLATOR CALIBRATION ................................................................................................................. 73<br/>
9.10 ANTENNA DIVERSITY AND MULTIPLE PATH TRANSMISSION ..................................................................... 73<br/>
9.11 RANDOM NUMBER GENERATOR ................................................................................................................ 74<br/>
9.12 RF PROGRAMMING .................................................................................................................................... 74<br/>
9.13 FREQUENCY SYNTHESIZER CONFIGURATION............................................................................................. 75<br/>
SWRU346B Page 3 of 114CC120X<br/>
9.14 IF PROGRAMMING ..................................................................................................................................... 75<br/>
9.15 FS CALIBRATION ....................................................................................................................................... 76<br/>
9.16 FS OUT OF LOCK DETECTION .................................................................................................................... 76<br/>
10 AES .......................................................................................................................................................... 77<br/>
10.1 AES BLOCK OPERATION ........................................................................................................................... 77<br/>
10.2 AES COMMANDS....................................................................................................................................... 77<br/>
10.3 AES PARAMETERS .................................................................................................................................... 77<br/>
10.4 AES TX/RXFIFO OPERATION .................................................................................................................. 78<br/>
11 SYSTEM CONSIDERATIONS AND GUIDELINES ......................................................................... 79<br/>
11.1 VOLTAGE REGULATORS ............................................................................................................................ 79<br/>
11.2 SRD REGULATIONS ................................................................................................................................... 79<br/>
11.3 FREQUENCY HOPPING AND MULTI-CHANNEL SYSTEMS ............................................................................ 79<br/>
11.4 CONTINUOUS TRANSMISSIONS .................................................................................................................. 79<br/>
11.5 BATTERY OPERATED SYSTEMS ................................................................................................................. 79<br/>
12 REGISTER DESCRIPTION ................................................................................................................. 80<br/>
13 SOLDERING INFORMATION .......................................................................................................... 114<br/>
14 DEVELOPMENT KIT ORDERING INFORMATION ................................................................... 114<br/>
15 REFERENCES ..................................................................................................................................... 114<br/>
16 GENERAL INFORMATION .............................................................................................................. 114<br/>
16.1 DOCUMENT HISTORY .............................................................................................................................. 114<br/>
SWRU346B Page 4 of 114CC120X<br/>
1 Overview<br/>
CC120X is a family of high performance low power RF transceivers designed for operation with a<br/>
companion MCU. The purpose of this user’s guide is to describe configurations and functionality<br/>
available for implementing a wireless system. CC120X automates all common RF related tasks, greatly<br/>
offloading the MCU. Below is a block diagram showing the different parts of the transceiver divided in<br/>
an RF related part and a part for digital support functionality.<br/>
BIAS<br/>
SWRU346B Page 5 of 114<br/>
SAIBR 1Q_CSOX 2Q_CSOX<br/>
ADC<br/>
LNA<br/>
ADC<br/>
0 FREQ<br/>
90 SYNTH<br/>
XOSC<br/>
ROTALUDOMED<br/>
ROTALUDOM<br/>
RELDNAH<br/>
TEKCAP<br/>
OFIFXR<br/>
OFIFXT<br/>
RADIO CONTROL &amp; POWER MANAGEMENT<br/>
LNA_P<br/>
LNA_N<br/>
PA<br/>
CSOX_TXE<br/>
PA<br/>
1CFL<br/>
SCLK<br/>
SO (GPIO0) SI CS_N<br/>
GPIO1<br/>
GPIO2<br/>
GPIO3<br/>
0CFL<br/>
UCM<br/>
OT<br/>
ECAFRETNI<br/>
LATIGID<br/>
CC120x<br/>
4 kbyte<br/>
ROM M Ua ltin ra R loa wdM Mi o pA<br/>
C<br/>
oR C UwC o en rt r 1o 6l u bn iti t S ae nr dia dl aco tS anP f iniI g tu er ra fati co en<br/>
System bus Interrupt and<br/>
IO handler<br/>
En Wha an kc ee Ode nuW l RtO r aaR d lo iow t ip mo ew rer C so tn af ti ug su r ra et gio isn t ea rn sd F2 IF5 bO6 u f b fR ey A rte M aP na dc Fk Ie Ft O h a cn od nl te ror l<br/>
RF and DSP frontend<br/>
PA out e1 f4 fi cd iB enm c yh i Pg Ah<br/>
90 dB dynamic LNA_P range ADC<br/>
High linearity<br/>
LNA<br/>
90 dB dynamic LNA_N range ADC<br/>
lennahC retlif<br/>
XOSC<br/>
cidroC<br/>
(optional 40 kHz Ultra low power 40 kHz CSn (chip select) clock intput) auto-calibrated RC oscillator<br/>
SI (serial input)<br/>
SO (serial output)<br/>
SCLK (serial clock)<br/>
(optional GPIO3/2/0<br/>
XOSC_Q1 Data interface with signal chain access<br/>
XOSC_Q2<br/>
(optional bit clock)<br/>
Highly flexible FSK / OOK<br/>
demodulator<br/>
(optional low jitter serial<br/>
data output for legacy protocols)<br/>
AGC<br/>
Automatic Gain Control, 60dB VGA range RSSI measurements and carrier sense detection<br/>
rotaludoM<br/>
Power on reset<br/>
AES-128<br/>
accelerator<br/>
Battery sensor / temp sensor<br/>
Output power ramping and OOK / ASK modulation (optional auto detected external XOSC / TCXO)<br/>
I Fully integrated fractional-N frequency synthesizer<br/>
Q<br/>
IF amp<br/>
IF amp<br/>
(optional GPIO for antenna diversity)<br/>
Figure 1: CC120X Block Diagram<br/>
CC120X can be configured to achieve optimum performance for many different applications using the<br/>
SPI interface (see Section 3.1.1 for more details). The following key parameters can be programmed:<br/>
Power-down/power-up mode (SLEEP/IDLE)<br/>
Crystal oscillator power-up/power-down (IDLE/XOFF)<br/>
Receive/transmit mode (RX/TX)<br/>
Carrier frequency<br/>
Symbol rate<br/>
Modulation format<br/>
RX channel filter bandwidth<br/>
RF output power<br/>
Data buffering with separate 128-byte receive and transmit FIFOs<br/>
Packet radio hardware support<br/>
Data whitening<br/>
Enhanced Wake-On-Radio (eWOR)<br/>
Figure 1 shows a simplified state diagram. For detailed information on controlling the CC120X state<br/>
machine see Section 9.CC120X<br/>
SLEEP<br/>
SIDLE SPWD or wake-on-radio (WOR)<br/>
Lowest power mode. Most<br/>
register values are retained<br/>
Default state when the radio is not (see Table 5 for details ).<br/>
receiving or transmitting. CSn = 0<br/>
IDLE<br/>
SXOFF<br/>
SCAL<br/>
Used for calibrating frequency<br/>
synthesizer upfront (entering Manual freq. CSn = 0 Crystal All register values are<br/>
receive or transmit mode can synth. calibration oscillator off retained.<br/>
then be done quicker). SRX or STX or SFSTXON or wake-on-radio (WOR)<br/>
Transitional state.<br/>
Frequency<br/>
Frequency synthesizer is turned on, can optionally be<br/>
synthesizer startup,<br/>
calibrated, and then settles to the correct frequency.<br/>
SFSTXON optional calibration,<br/>
Transitional state.<br/>
settling<br/>
Frequency synthesizer is on,<br/>
ready to start transmitting. Frequency<br/>
Transmission starts very synthesizer on<br/>
quickly after receiving the STX<br/>
command strobe. STX<br/>
SRX or wake-on-radio (WOR)<br/>
STX TXOFF_MODE = 01<br/>
SFSTXON or RXOFF_MODE = 01<br/>
SRX<br/>
STX or RXOFF_MODE=10<br/>
Transmit mode Receive mode<br/>
SRX or TXOFF_MODE = 11<br/>
TXOFF_MODE = 00 RXOFF_MODE = 00<br/>
Optional transitional state.<br/>
In FIFO-based modes,<br/>
In FIFO-based modes,<br/>
transmission is turned off and<br/>
TX FIFO Optional freq. RX FIFO reception is turned off and this<br/>
this state entered if the TX<br/>
ERROR synth. calibration ERROR state entered if the RX FIFO<br/>
FIFO becomes empty in the<br/>
overflows.<br/>
middle of a packet.<br/>
SFTX SFRX<br/>
IDLE<br/>
Figure 2: Simplified State Diagram<br/>
2 Configuration Software<br/>
CC112X can be configured using the SmartRF™ Studio software [1]. SmartRF Studio is highly<br/>
recommended for obtaining optimum register settings, and for evaluating performance and<br/>
functionality.<br/>
After chip reset, all registers have default values and these might differ from the optimum register<br/>
setting. It is therefore necessary to configure/reconfigure the radio through the SPI interface after the<br/>
chip has been reset. SmartRF Studio provides a code export function making it easy to implement this<br/>
in firmware.<br/>
SWRU346B Page 6 of 114CC120X<br/>
3 Microcontroller Interface<br/>
3.1 Configuration<br/>
In a typical system, CC120X will interface to an MCU. This MCU must be able to communicate with the<br/>
CC120X over a 4-wire SPI interface to be able to:<br/>
Configure the CC120X<br/>
Program CC120X into different modes (RX, TX, SLEEP, IDLE, etc)<br/>
Read and write buffered data (RX FIFO and TX FIFO)<br/>
Read status information<br/>
3.1.1 4-wire Serial Configuration and Data Interface<br/>
CC120X is configured via a simple 4-wire SPI-compatible interface (SI, SO, SCLK, and CSn) where<br/>
CC120X is the slave. This interface is also used to read and write buffered data. All transfers on the SPI<br/>
interface are done most significant bit first.<br/>
All transactions on the SPI interface start with a header byte containing a R/W¯ bit, a burst access bit<br/>
(B), and a 6-bit address (A - A ). A status byte is sent on the SO pin each time a header byte is<br/>
5 0<br/>
transmitted on the SI pin (see Section 3.1.2 for more details on the chip status byte).<br/>
The CSn pin must be kept low during transfers on the SPI bus. The timing for the address and data<br/>
transfers on the SPI interface is shown in Figure 3 with reference to Table 1.<br/>
tsp tch tcl tsd thd tns<br/>
SCLK<br/>
CSn<br/>
Write to Register<br/>
SI X 0 B A5 A4 A3 A2 A1 A0 X DW7 DW6 DW5 DW4 DW3 DW2 DW1 DW0 X<br/>
Hi Z Hi Z<br/>
SO S7 0 S5 S4 S3 S2 S1 S0 S0 S7 S6 S5 S4 S3 S2 S1 S0<br/>
Read from Register<br/>
SI X 1 B A5 A4 A3 A2 A1 A0 X<br/>
Hi Z Hi Z<br/>
SO S7 S6 S5 S4 S3 S2 S1 S0 S0 DR7 DR6 DR5 DR4 DR3 DR2 DR1 DR0<br/>
Figure 3: Configuration Registers Write and Read Operations<br/>
Parameter Description Min Max Units<br/>
f<br/>
SCLK<br/>
SCLK frequency read/write access - 10 MHz<br/>
Note: A 100 ns delay between consecutive data bytes must be added during burst write access to the configuration<br/>
registers<br/>
SCLK frequency read access extended memory 7.7<br/>
t CSn low to positive edge on SCLK 50 - ns<br/>
sp<br/>
t Clock high 47.5 - ns<br/>
ch<br/>
t Clock low 47.5 - ns<br/>
cl<br/>
t Clock rise time - 40 ns<br/>
rise<br/>
t Clock fall time - 40 ns<br/>
fall<br/>
t Setup data before a positive edge on SCLK 10 - ns<br/>
sd<br/>
t Hold data after positive edge on SCLK 10 - ns<br/>
hd<br/>
t Negative edge on SCLK to CSn high. 200 - ns<br/>
ns<br/>
CSn high time, time from CSn has been pulled high until it can be pulled low again 50 ns<br/>
Table 1: SPI Timing Requirements<br/>
SWRU346B Page 7 of 114CC120X<br/>
When CSn is pulled low, the MCU must wait until CC120X SO pin goes low before starting to transfer<br/>
the header byte. This indicates that the crystal is stable. Unless the chip was just reset or was in<br/>
SLEEP or XOFF state, or the XOSC configuration has been altered, the SO pin will always go low<br/>
immediately after pulling CSn low.<br/>
Registers with consecutive addresses can be accessed in an efficient way by setting the burst bit (B)<br/>
in the header byte. The address bits (A - A ) set the start address in an internal address counter. This<br/>
5 0<br/>
counter is incremented by one each new byte (every 8 clock pulses). The burst access is either a<br/>
read or write, and must be terminated by setting CSn high.<br/>
If a single register shall be accessed multiple times (e.g. CFM_RX_DATA_OUT/ CFM_TX_DATA_IN for<br/>
custom frequency modulation, see Section 5.2.4), the EXT_CTRL.BURST_ADDR_INCR_EN bit can be<br/>
set to 0. In this mode the address counter will not increment in burst mode, and it is possible to<br/>
read/write the same register repeatedly without address overhead.<br/>
Table 3 gives an overview of the different SPI access types possible.<br/>
3.1.2 Chip Status Byte<br/>
When the header byte, data byte, or command strobe is sent on the SPI interface, the chip status byte<br/>
is sent by the CC120X on the SO pin. The status byte contains key status signals, useful for the MCU.<br/>
The first bit, S , is the CHIP_RDYn signal and this signal must go low before the first positive edge of<br/>
7<br/>
SCLK. The CHIP_RDYn signal indicates that the crystal is stable.<br/>
S , S , and S comprise the STATE value which reflects the state of the chip. In IDLE state the XOSC<br/>
6 5 4<br/>
and power to the digital core are on and all other modules are in power down. Unless otherwise<br/>
stated, registers should not be changed unless the chip is in this state.<br/>
Table 2 gives a status byte summary.<br/>
Bits Name Description<br/>
7 CHIP_RDYn Stays high until power and crystal have stabilized. Should always be low when using the SPI<br/>
interface.<br/>
6:4 STATE[2:0] Indicates the current main state machine mode<br/>
Value State MARC State Description<br/>
000 IDLE IDLE IDLE state<br/>
001 RX RX Receive mode<br/>
RX_END<br/>
010 TX TX Transmit mode<br/>
TX_END<br/>
011 FSTXON FSTXON Fast TX ready<br/>
100 CALIBRATE BIAS_SETTLE_MC Frequency synthesizer calibration is running<br/>
REG_SETTLE_MC<br/>
MANCAL<br/>
STARTCAL<br/>
ENDCAL<br/>
101 SETTLING BIAS_SETTLE PLL is settling<br/>
REG_SETTLE<br/>
BWBOOST<br/>
FS_LOCK<br/>
IFADCON<br/>
RXTX_SWITCH<br/>
TXRX_SWITCH<br/>
IFADCON_TXRX<br/>
110 RX FIFO RX_FIFO_ERR RX FIFO has over/underflowed. Read out<br/>
ERROR any useful data, then flush the FIFO with an<br/>
SFRX strobe<br/>
111 TX FIFO TX_FIFO_ERR TX FIFO has over/underflowed. Flush the<br/>
ERROR FIFO with an SFTX strobe<br/>
3:0 Reserved<br/>
Table 2: Status Byte Summary<br/>
SWRU346B Page 8 of 114CC120X<br/>
3.2 SPI Access Types<br/>
Figure 4 shows the SPI memory map and the following sections are going to explain how the different<br/>
SPI access types (see Table 3) should be used. Table 4 shows the SPI address space.<br/>
0x00 Extended Address Space<br/>
Register Space<br/>
Configuration Registers<br/>
0x00<br/>
0x2E Extended Register Space<br/>
Configuration Registers<br/>
0x2F Extended Address Status Registers<br/>
FIFO Pointers<br/>
0x30 AES Workspace (key and buffer)<br/>
0xFF<br/>
Command Strobes<br/>
0x00<br/>
0x3D<br/>
FIFO Buffers<br/>
FEC Workspace<br/>
0x3E Direct Memory Access<br/>
128 Bytes Free Area<br/>
(AES Command Workspace)<br/>
0x3F FIFO Access (push/pop)<br/>
0xFF<br/>
Figure 4: SPI Memory Map1<br/>
Access type Command/Address byte Description<br/>
Single Register Access Address: R/W¯ 0 A5 A4 A3 A2 A1 A0 The R/W¯ bit determines whether the operation is a read (1)<br/>
(register space) or a write (0) operation<br/>
(A5 - 0 &lt; 0x2F) The register accessed is determined by the address in A5 - 0<br/>
Exactly one data byte is expected after the address byte<br/>
The chip status byte is returned on the SO line both when<br/>
the address is sent on the SI line as well as when data are<br/>
written<br/>
Burst Register Access Address: R/W¯ 1 A5 A4 A3 A2 A1 A0 The R/W¯ bit determines whether the operation is a read (1)<br/>
(register space) or a write (0) operation<br/>
(A5 - 0 &lt; 0x2F) The address in A5 - 0 determines the first register accessed,<br/>
after which an internal address counter is incremented for<br/>
each new data byte following the address byte<br/>
Consecutive bytes are expected after the address byte and<br/>
the burst access is terminated by setting CSn high<br/>
The chip status byte is returned on the SO line both when<br/>
the address is sent on the SI line as well as when data are<br/>
written<br/>
If the internal address counter reaches address 0x2E (last<br/>
byte in register space) the counter will not increment<br/>
anymore and the same address will be read/written until the<br/>
burst access is being terminated<br/>
Single Register Access Command: R/W¯ 0 1 0 1 1 1 1 This access mode starts with a specific command (0x2F)<br/>
(extended register space) Address: A7 A6 A5 A4 A3 A2 A1 A0 The first byte following this command is interpreted as the<br/>
extended address<br/>
(A7 - 0: See Table 5) Exactly one data byte is expected after the extended<br/>
address byte<br/>
When the extended address is sent on the SI line, SO will<br/>
return all zeros. The chip status byte is returned on the SO<br/>
line when the command is transmitted as well as when data<br/>
are written to the extended address<br/>
1 The FEC workspace is used by the chip when FEC is enabled (PKT_CFG1.FEC_EN = 1) but can<br/>
be used freely otherwise<br/>
Part of the 128 bytes “Free Area” is used by the AES accelerator. Please see Section 10 for more<br/>
details<br/>
SWRU346B Page 9 of 114CC120X<br/>
Access type Command/Address byte Description<br/>
Burst Register Access Command: R/W¯ 1 1 0 1 1 1 1 This access mode starts with a specific command (0x2F)<br/>
(extended register space) Address: A7 A6 A5 A4 A3 A2 A1 A0 The first byte following this command is interpreted as the<br/>
extended address<br/>
(A7 - 0: See Table 5) Consecutive bytes are expected after the extended address<br/>
byte and the burst access is terminated by setting CSn high<br/>
When the extended address is sent on the SI line, SO will<br/>
return all zeros. The chip status byte is returned on the SO<br/>
line when the command is transmitted as well as when data<br/>
are written to the extended address.<br/>
If the internal address counter reaches address 0xFF (last<br/>
byte in extended register space) the counter will wrap<br/>
around to 0x00<br/>
Registers not listed in Table 5 can be part of a burst access<br/>
Command Strobe Access Address: R/W¯ 0 A5 A4 A3 A2 A1 A0 Accessing one of the command strobe registers triggers an<br/>
event determined by the address in A5 - 0, e.g. resetting the<br/>
(0x30 ≤ A5 - 0 ≤ 0x3D) device, enabling the crystal oscillator, entering TX, etc. No<br/>
data byte is expected.<br/>
The chip status byte is returned on the SO line when a<br/>
command strobe is sent on the SI line<br/>
Standard FIFO Access Address: R/W¯ B 1 1 1 1 1 1 The R/W¯ bit determines whether the operation is a read (1)<br/>
operation from the RX FIFO or a write (0) operation to the<br/>
TX FIFO. If the burst bit B is 1, all bytes following the<br/>
address byte are treated as data bytes until CSn goes high.<br/>
If the burst bit B is 0, the FIFOs are accessed byte-wise as<br/>
a normal register.<br/>
Direct Access to FIFO Command: R/W¯ B 1 1 1 1 1 0 This access mode starts with a specific command (0x3E)<br/>
Buffers Address: A7 A6 A5 A4 A3 A2 A1 A0 which makes it possible to access the FIFOs directly<br/>
through memory operations without affecting the FIFO<br/>
SPI_DIRECT_ACCESS_CFG in pointers.<br/>
SERIAL_STATUS must be 0 The first byte following this command is interpreted as the<br/>
address. The next byte is read/written to this address. If<br/>
A7 - 0 &lt; 0x80: TX FIFO burst is enabled, consecutive bytes will be read/written by<br/>
0x80 ≤ A7 - 0 ≤ 0xFF: RX FIFO incrementing the address.2<br/>
FIFO pointers are available in extended register space for<br/>
debug purposes.<br/>
Direct Access to FEC Command: R/W¯ B 1 1 1 1 1 0 This access mode starts with a specific command (0x3E)<br/>
Workspace Address: A7 A6 A5 A4 A3 A2 A1 A0 which makes it possible to access the FEC workspace.<br/>
SPI_DIRECT_ACCESS_CFG in The first byte following this command is interpreted as the<br/>
SERIAL_STATUS must be 1 address. The next byte is read/written to this address. If<br/>
burst is enabled, consecutive bytes will be read/written by<br/>
(A7 - 0 &lt; 0x80) incrementing the address.<br/>
Direct Access to 128 Bytes Command: R/W¯ B 1 1 1 1 1 0 This access mode starts with a specific command (0x3E)<br/>
Free Area (AES Command Address: A7 A6 A5 A4 A3 A2 A1 A0 which makes it possible to access 128 bytes of free<br/>
Workspace) SPI_DIRECT_ACCESS_CFG in memory.<br/>
SERIAL_STATUS must be 1 The first byte following this command is interpreted as the<br/>
address. The next byte is read/written to this address. If<br/>
0x80 ≤ A7 - 0 ≤ 0xFF burst is enabled, consecutive bytes will be read/written by<br/>
incrementing the address.<br/>
Table 3: SPI Access Types<br/>
2 Note that the first byte received in an empty RX FIFO will not be possible to read using direct FIFO<br/>
access but can be read from extended register space (A7 – 0 = 0xDA). Please see Section 3.2.3 for more<br/>
details.<br/>
SWRU346B Page 10 of 114CC120X<br/>
Write Read<br/>
Single Byte Burst Single Byte Burst<br/>
+0x00 +0x40 +0x80 +0xC0<br/>
0x00 IOCFG3<br/>
0x01 IOCFG2<br/>
0x02 IOCFG1<br/>
0x03 IOCFG0<br/>
0x04 SYNC3<br/>
0x05 SYNC2<br/>
0x06 SYNC1<br/>
0x07 SYNC0<br/>
0x08 SYNC_CFG1<br/>
0x09 SYNC_CFG0<br/>
0x0A DEVIATION_M<br/>
0x0B MODCFG_DEV_E<br/>
0x0C DCFILT_CFG<br/>
0x0D PREAMBLE_CFG1<br/>
0x0E PREAMBLE_CFG0<br/>
0x0F IQIC e lb<br/>
0x10 CHAN_BW is<br/>
s<br/>
0x11 MDMCFG1 o<br/>
p<br/>
0x12 MDMCFG0 s<br/>
s<br/>
0x13 SYMBOL_RATE2 e c<br/>
0x14 SYMBOL_RATE1 c a<br/>
0x15 SYMBOL_RATE0 ts<br/>
0x16 AGC_REF<br/>
ru<br/>
b<br/>
0x17 AGC_CS_THR ,s<br/>
0x18 AGC_GAIN_ADJUST<br/>
re<br/>
ts<br/>
0x19 AGC_CFG3 ig<br/>
e<br/>
0x1A AGC_CFG2 r<br/>
n<br/>
0x1B AGC_CFG1 o<br/>
0x1C AGC_CFG0<br/>
ita<br/>
ru<br/>
0x1D FIFO_CFG g<br/>
0x1E DEV_ADDR<br/>
ifn<br/>
o<br/>
0x1F SETTLING_CFG c<br/>
W<br/>
0x20 FS_CFG /R<br/>
0x21 WOR_CFG1<br/>
0x22 WOR_CFG0<br/>
0x23 WOR_EVENT0_MSB<br/>
0x24 WOR_EVENT0_LSB<br/>
0x25 RXDCM_TIME<br/>
0x26 PKT_CFG2<br/>
0x27 PKT_CFG1<br/>
0x28 PKT_CFG0<br/>
0x29 RFEND_CFG1<br/>
0x2A RFEND_CFG0<br/>
0x2B PA_CFG1<br/>
0x2C PA_CFG0<br/>
0x2D ASK_CFG<br/>
0x2E PKT_LEN<br/>
0x2F EXTENDED ADDRESS<br/>
0x30 SRES SRES<br/>
0x31 SFSTXON SFSTXON<br/>
0x32 SXOFF SXOFF<br/>
0x33 SCAL SCAL<br/>
0x34 SRX SRX<br/>
0x35 STX STX<br/>
0x36 SIDLE SIDLE<br/>
0x37 SAFC SAFC<br/>
0x38 SWOR SWOR<br/>
s<br/>
0x39 SPWD SPWD e b<br/>
0x3A SFRX SFRX o rtS<br/>
0x3B SFTX SFTX<br/>
d<br/>
0x3C SWORRST SWORRST n<br/>
a<br/>
0x3D SNOP SNOP m<br/>
m<br/>
0x3E DIRECT MEMORY ACCESS o<br/>
C<br/>
0x3F TX FIFO TX FIFO RX FIFO RX FIFO<br/>
Table 4: SPI Address Space<br/>
SWRU346B Page 11 of 114CC120X<br/>
3.2.1 Register Space Access and Extended Register Space Access<br/>
The configuration registers on the CC120X are located on SPI addresses from 0x00 to 0x2E (register<br/>
space) with address extension command at address 0x2F to access the extended register space (see<br/>
Figure 4). All configuration registers can be both written to and read and this is controlled by the R/W¯<br/>
bit in the header byte. All configuration registers can also be accessed with the burst bit (B) set to<br/>
either 1 or 0. Note that all registers in register space (address 0x00 - 0x2E) have retention. In<br/>
extended register space, the status registers, FIFO pointers, and the AES workspace do not have<br/>
retention. Please see Table 5 for details.<br/>
Extended Register Space (0x00 - 0x2F) Retention Extended Register Space (0x30 - 0x86) Retention<br/>
0x00 IF_MIX_CFG Yes 0x30 LNA Yes<br/>
0x01 FREQOFF_CFG Yes 0x31 RXMIX Yes<br/>
0x02 TOC_CFG Yes 0x32 XOSC5 Yes<br/>
0x03 MARC_SPARE Yes 0x33 XOSC4 Yes<br/>
0x04 ECG_CFG Yes 0x34 XOSC3 Yes<br/>
0x05 MDMCFG2 Yes 0x35 XOSC2 Yes<br/>
0x06 EXT_CTRL Yes 0x36 XOSC1 Yes<br/>
0x07 RCCAL_FINE Yes 0x37 XOSC0 Yes<br/>
0x08 RCCAL_COARSE Yes 0x38 ANALOG_SPARE Yes<br/>
0x09 RCCAL_OFFSET Yes 0x39 PA_CFG3 Yes<br/>
0x0A FREQOFF1 Yes 0x3A - 0x3E Not Used<br/>
0x0B FREQOFF0 Yes 0x3F - 0x40 Reserved<br/>
0x0C FREQ2 Yes 0x41 - 0x63 Not Used<br/>
0x0D FREQ1 Yes 0x64 WOR_TIME1 No<br/>
0x0E FREQ0 Yes 0x65 WOR_TIME0 No<br/>
0x0F IF_ADC2 Yes 0x66 WOR_CAPTURE1 No<br/>
0x10 IF_ADC1 Yes 0x67 WOR_CAPTURE0 No<br/>
0x11 IF_ADC0 Yes 0x68 BIST No<br/>
0x12 FS_DIG1 Yes 0x69 DCFILTOFFSET_I1 No<br/>
0x13 FS_DIG0 Yes 0x6A DCFILTOFFSET_I0 No<br/>
0x14 FS_CAL3 Yes 0x6B DCFILTOFFSET_Q1 No<br/>
0x15 FS_CAL2 Yes 0x6C DCFILTOFFSET_Q0 No<br/>
0x16 FS_CAL1 Yes 0x6D IQIE_I1 No<br/>
0x17 FS_CAL0 Yes 0x6E IQIE_I0 No<br/>
0x18 FS_CHP Yes 0x6F IQIE_Q1 No<br/>
0x19 FS_DIVTWO Yes 0x70 IQIE_Q0 No<br/>
0x1A FS_DSM1 Yes 0x71 RSSI1 No<br/>
0x1B FS_DSM0 Yes 0x72 RSSI0 No<br/>
0x1C FS_DVC1 Yes 0x73 MARCSTATE No<br/>
0x1D FS_DVC0 Yes 0x74 LQI_VAL No<br/>
0x1E FS_LBI Yes 0x75 PQT_SYNC_ERR No<br/>
0x1F FS_PFD Yes 0x76 DEM_STATUS No<br/>
0x20 FS_PRE Yes 0x77 FREQOFF_EST1 No<br/>
0x21 FS_REG_DIV_CML Yes 0x78 FREQOFF_EST0 No<br/>
0x22 FS_SPARE Yes 0x79 AGC_GAIN3 No<br/>
0x23 FS_VCO4 Yes 0x7A AGC_GAIN2 No<br/>
0x24 FS_VCO3 Yes 0x7B AGC_GAIN1 No<br/>
0x25 FS_VCO2 Yes 0x7C AGC_GAIN0 No<br/>
0x26 FS_VCO1 Yes 0x7D CFM_RX_DATA_OUT No<br/>
0x27 FS_VCO0 Yes 0x7E CFM_TX_DATA_IN No<br/>
0x28 GBIAS6 Yes 0x7F ASK_SOFT_RX_DATA No<br/>
0x29 GBIAS5 Yes 0x80 RNDGEN No<br/>
0x2A GBIAS4 Yes 0x81 MAGN2 No<br/>
0x2B GBIAS3 Yes 0x82 MAGN1 No<br/>
0x2C GBIAS2 Yes 0x83 MAGN0 No<br/>
0x2D GBIAS1 Yes 0x84 ANG1 No<br/>
0x2E GBIAS0 Yes 0x85 ANG0 No<br/>
0x2F IFAMP Yes 0x86 CHFILT_I2 No<br/>
SWRU346B Page 12 of 114CC120X<br/>
Extended Register Space (0x87 - 0x9D) Retention Extended Register Space (0x9E - 0xFF) Retention<br/>
0x87 CHFILT_I1 No 0x9E ATEST_MODE No<br/>
0x88 CHFILT_I0 No 0x9F XOSC_TEST1 No<br/>
0x89 CHFILT_Q2 No 0xA0 XOSC_TEST0 No<br/>
0x8A CHFILT_Q1 No 0xA1 AES No<br/>
0x8B CHFILT_Q0 No 0xA2 MDM_TEST No<br/>
0x8C GPIO_STATUS No 0xA3 - 0xD1 Not Used<br/>
0x8D FSCAL_CTRL No 0xD2 RXFIRST No<br/>
0x8E PHASE_ADJUST No 0xD3 TXFIRST No<br/>
0x8F PARTNUMBER No 0xD4 RXLAST No<br/>
0x90 PARTVERSION No 0xD5 TXLAST No<br/>
0x91 SERIAL_STATUS No 0xD6 NUM_TXBYTES No<br/>
0x92 MODEM_STATUS1 No 0xD7 NUM_RXBYTES No<br/>
0x93 MODEM_STATUS0 No 0xD8 FIFO_NUM_TXBYTES No<br/>
0x94 MARC_STATUS1 No 0xD9 FIFO_NUM_RXBYTES No<br/>
0x95 MARC_STATUS0 No 0xDA RXFIFO_PRE_BUF No<br/>
0x96 PA_IFAMP_TEST No 0xDB - 0xDF Not Used No<br/>
0x97 FSRF_TEST No 0xE0 - 0xEF AES_KEY<br/>
0x98 PRE_TEST No<br/>
0x99 PRE_OVR No 0xE0 - 0xFF AES Workspace No<br/>
0x9A ADC_TEST No<br/>
0x9B DVC_TEST No 0xF0 – 0xFF AES_BUFFER<br/>
0x9C ATEST No<br/>
0x9D ATEST_LVDS No<br/>
Table 5: Extended Register Space Mapping<br/>
3.2.2 Command Strobes<br/>
Command Strobes may be viewed as single byte instructions to CC120X. By addressing a command<br/>
strobe register, internal sequences will be started. These commands are used to enable receive and<br/>
transmit mode, enter SLEEP mode, disable the crystal oscillator, etc. The command strobes are listed<br/>
in Table 6.The command strobe registers are accessed by transferring a single header byte (no data<br/>
is being transferred). That is, only the R/W¯ bit, the burst access bit (set to 0), and the six address bits<br/>
(in the range 0x30 through 0x3D) are written. When sending a strobe, the R/W¯ bit can be either one<br/>
or zero. The status byte is available on the SO pin when a command strobe is being sent.<br/>
Address Strobe Name Description<br/>
0x30 SRES Reset chip<br/>
0x31 SFSTXON Enable and calibrate frequency synthesizer (if SETTLING_CFG.FS_AUTOCAL = 1).<br/>
If in RX and PKT_CFG2.CCA_MODE ≠ 0: Go to a wait state where only the synthesizer is<br/>
running (for quick RX/TX turnaround).<br/>
0x32 SXOFF Enter XOFF state when CSn is de-asserted<br/>
0x33 SCAL Calibrate frequency synthesizer and turn it off. SCAL can be strobed from IDLE mode without<br/>
setting manual calibration mode (SETTLING_CFG.FS_AUTOCAL = 0)<br/>
0x34 SRX Enable RX. Perform calibration first if coming from IDLE and SETTLING_CFG.FS_AUTOCAL =<br/>
1<br/>
0x35 STX In IDLE state: Enable TX. Perform calibration first if SETTLING_CFG.FS_AUTOCAL = 1.<br/>
If in RX state and PKT_CFG2.CCA_MODE ≠ 0: Only go to TX if channel is clear<br/>
0x36 SIDLE Exit RX/TX, turn off frequency synthesizer and exit eWOR mode if applicable<br/>
0x37 SAFC Automatic Frequency Compensation<br/>
0x38 SWOR Start automatic RX polling sequence (eWOR) as described in Section 9.6 if<br/>
WOR_CFG0.RC_PD = 0<br/>
0x39 SPWD Enter SLEEP mode when CSn is de-asserted<br/>
0x3A SFRX Flush the RX FIFO. Only issue SFRX in IDLE or RX_FIFO_ERR states<br/>
0x3B SFTX Flush the TX FIFO. Only issue SFTX in IDLE or TX_FIFO_ERR states<br/>
0x3C SWORRST Reset the eWOR timer to the Event1 value<br/>
0x3D SNOP No operation. May be used to get access to the chip status byte<br/>
Table 6: Command Strobes<br/>
SWRU346B Page 13 of 114CC120X<br/>
A command strobe may be followed by any other SPI access without pulling CSn high, and the<br/>
command strobes are executed immediately. This applies for all command strobes except SRES,<br/>
SPWD, SWOR, and the SXOFF strobe.<br/>
When a SRES strobe is issued the CSn pin must be kept low and wait for SO to go low again before<br/>
the next header byte can be issued, as shown in Figure 5.<br/>
CSn<br/>
SO x<br/>
SI HeaderSRES HeaderAddr Data<br/>
Figure 5: SRES Command Strobe<br/>
The SPWD, SWOR, and the SXOFF command strobes are not executed before the CSn goes high.<br/>
3.2.3 Direct FIFO Access<br/>
The complete RX and TX FIFOs, with associated pointers, are mapped in the register space for FIFO<br/>
manipulation and SW-debug purposes. The FIFOs are mapped as shown in Table 7 (the address<br/>
must be preceded by the command 0x3E) while the FIFO pointers are located in extended register<br/>
space (address 0xD2 - 0xD5, see Table 5).<br/>
Direct FIFO Access Mapping Retention<br/>
0x00 - 0x7F TXFIFO No<br/>
0x80 - 0xFF RXFIFO No<br/>
Table 7: Direct FIFO Access Mapping<br/>
Both FIFO data and pointers are readable and writeable to enable e.g. re-transmissions, partial flush,<br/>
partial readouts, changing only the sequence number before re-transmission etc. Figure 6 shows how<br/>
the TX FIFO pointer changes as the FIFO is written and as data are sent on the air (assume variable<br/>
packet length mode PKT_CFG0.LENGTH_CONFIG = 1.<br/>
SWRU346B Page 14 of 114CC120X<br/>
NUM_TXBYTES = 0x09<br/>
1 D 2 D D 3 D D D x x x x<br/>
0 1 2 3 4 5<br/>
0 1 2 3 4 5 6 7 8 9 10 126 127<br/>
TXFIRST TXLAST<br/>
STX: 1 D transmitted on the air<br/>
0<br/>
NUM_TXBYTES = 0x07<br/>
1 D 2 D D 3 D D D x x x x<br/>
0 1 2 3 4 5<br/>
0 1 2 3 4 5 6 7 8 9 10 126 127<br/>
TXFIRST TXLAST<br/>
STX: 2 D D transmitted on the air<br/>
1 2<br/>
NUM_TXBYTES = 0x04<br/>
1 D 2 D D 3 D D D x x x x<br/>
0 1 2 3 4 5<br/>
0 1 2 3 4 5 6 7 8 9 10 126 127<br/>
TXFIRST TXLAST<br/>
STX: 3 D D D transmitted on the air<br/>
3 4 5<br/>
NUM_TXBYTES = 0x00<br/>
1 D 2 D D 3 D D D x x x x<br/>
0 1 2 3 4 5<br/>
0 1 2 3 4 5 6 7 8 9 10 126 127<br/>
TXLAST<br/>
TXFIRST<br/>
Figure 6: FIFO Pointers (TX FIFO)<br/>
To transmit packet number 3 over again one can simply write 0x05 to the TXFIRST register and then<br/>
strobe STX again.<br/>
In RX mode, when the RX FIFO is empty (i.e. RXFIRST = RXLAST) the first byte received will not be<br/>
available to be read from the RXFIFO using direct FIFO access3. Please see Figure 7 (it is assumed<br/>
that the receiver uses variable packet length mode (PKT_CFG0.LENGTH_CFG = 01) and that<br/>
append status is disabled (PKT_CFG1.APPEND_STATUS = 0) for this example).<br/>
3 This byte can instead be read from extended register space (A<br/>
7 – 0<br/>
= 0xDA).<br/>
SWRU346B Page 15 of 114CC120X<br/>
NUM_RXBYTES = 0x00<br/>
x x x x x x x x x x x x x<br/>
0 1 2 3 4 5 6 7 8 9 10 126 127<br/>
RXFIRST<br/>
RXLAST<br/>
transmitted on the air and received by<br/>
3 D D D<br/>
0 1 2 the radio<br/>
NUM_RXBYTES = 0x04<br/>
D D D x x x x x x x x x x<br/>
0 1 2<br/>
0 1 2 3 4 5 6 7 8 9 10 126 127<br/>
RXFIRST RXLAST<br/>
transmitted on the air and received by<br/>
3 D D D<br/>
0 1 2 the radio<br/>
NUM_RXBYTES = 0x08<br/>
D D D 3 D D D x x x x x x<br/>
0 1 2 0 1 2<br/>
0 1 2 3 4 5 6 7 8 9 10 126 127<br/>
RXFIRST RXLAST<br/>
Figure 7: FIFO Pointers (RX FIFO) (1)<br/>
If 8 bytes (NUM_RXBYTES = 0x08) are read from the RXFIFO using standard FIFO access (see<br/>
Section 3.2.4) the following will be read: 3, D , D , D , 3, D , D , D .<br/>
0 1 2 0 1 2<br/>
If the RX FIFO had been read (using standard FIFO access) in between the two packets, the RX<br/>
FIFO pointers would end up with the values shown in Figure 8.<br/>
NUM_RXBYTES = 0x04<br/>
D D D D D D x x x x x x x<br/>
0 1 2 0 1 2<br/>
0 1 2 3 4 5 6 7 8 9 10 126 127<br/>
RXFIRST RXLAST<br/>
Figure 8: FIFO Pointers (RX FIFO) (2)<br/>
3.2.4 Standard FIFO Access<br/>
Using the standard FIFO push/pop interface the 128-byte TX FIFO and the 128-byte RX FIFO are<br/>
accessed through the 0x3F address. When the R/W¯ bit is zero the TX FIFO is accessed, and the RX<br/>
FIFO is accessed when the R/W¯ bit is one. Using this type of access, the TX FIFO is write-only, while<br/>
the RX FIFO is read-only. The burst bit is used to determine if the FIFO access is a single byte access<br/>
or a burst access. The single byte access method expects a header byte with the burst bit set to zero<br/>
and one data byte. After the data byte, a new header byte is expected; hence CSn can remain low.<br/>
The burst access method expects one header byte and then consecutive data bytes until terminating<br/>
the access by setting CSn high.<br/>
SWRU346B Page 16 of 114CC120X<br/>
If the radio tries to write to the RX FIFO after it is full or if the RX FIFO is tried read when it is empty,<br/>
the RXFIFO_OVERFLOW and RXFIFO_UNDERFLOW signals will be asserted and the radio will enter the<br/>
RX_FIFO_ERR state. Likewise, if the TX FIFO is tried written when it is full or if the TX FIFO runs<br/>
empty in the middle of a packet, the TXFIFO_OVERFLOW and TXFIFO_UNDERFLOW signals will be<br/>
asserted and the radio will enter the TX_FIFO_ERR state.<br/>
The TX FIFO may be flushed by issuing a SFTX command strobe. Similarly, a SFRX command strobe<br/>
will flush the RX FIFO. A SFTX or SFRX command strobe can only be issued in the IDLE,<br/>
TX_FIFO_ERR, or RX_FIFO_ERR states. Both FIFOs are flushed when going to the SLEEP state.<br/>
3.3 Optional PIN CTRL Radio Control Feature<br/>
The CC120X has an optional way of controlling the radio by reusing SI, SCLK, and CSn from the SPI<br/>
interface. This feature allows for a simple three-pin control of the major states of the radio: SLEEP,<br/>
IDLE, RX, and TX. This optional functionality is enabled with the EXT_CTRL.PIN_CTRL_EN<br/>
configuration bit.<br/>
State changes are commanded as follows:<br/>
When CSn is high, the SI and SCLK are set to the desired state according to Table 8.<br/>
When CSn goes low, the state of SI and SCLK is latched and a command strobe is generated<br/>
internally according to the pin configuration.<br/>
If the device is in the TX state and the TX command is issued, it will be ignored. For RX state, an RX<br/>
command will restart RX. When CSn is low the SI and SCLK have normal SPI functionality.<br/>
All pin control command strobes are executed immediately, except the SPWD strobe. The SPWD strobe<br/>
is delayed until CSn goes high.<br/>
Pin control is useful to get precise timing on RX/TX strobes.<br/>
CSn SCLK SI Function<br/>
1 X X Chip unaffected by SCLK/SI<br/>
0 0 Generates SPWD strobe<br/>
0 1 Generates STX strobe<br/>
1 0 Generates SIDLE strobe<br/>
1 1 Generates SRX strobe<br/>
0 SPI SPI SPI mode (wakes up into<br/>
mode mode IDLE if in SLEEP/XOFF)<br/>
Table 8: Optional Pin Control Coding<br/>
3.4 General Purpose Input/Output Control Pins<br/>
The four digital I/O pins GPIO0, GPIO1, GPIO2 and GPIO3 are general control pins configured with<br/>
IOCFGx.GPIOx_CFG (where x is 0, 1, 2, or 3). Table 10 shows the different signals that can be<br/>
monitored on the GPIO pins. The signal name field in the table should be interpreted as follows:<br/>
One signal name: The signal can be routed out to any of the four GPIO pins for full flexibility<br/>
Four signal names: The signal can only be routed out on the GPIO designated in the table.<br/>
GPIO1 is shared with the SO pin in the SPI interface. The default setting for GPIO1/SO is HIGHZ (tri-<br/>
state) output, which is useful when the SPI interface is shared with other devices. By selecting any<br/>
other of the programming options, the GPIO1/SO pin will become a generic pin when CSn is high<br/>
and function as SO when CSn is low.<br/>
When the IOCFGx.GPIOx_CFG setting is less than 0x30 and IOCFGx.GPIOx_INV is 0 (1) the<br/>
GPIO0 and GPIO2 pin will be hardwired to 0 (1), and GPIO1 and GPIO3 will be hardwired to 1 (0) in<br/>
the SLEEP state. These signals will be hardwired until the CHIP_RDYn signal goes low. If the<br/>
IOCFGx.GPIOx_CFG setting is 0x30 or higher, the GPIO pins will work as programmed also in<br/>
SLEEP state.<br/>
The GPIOs can also be used as inputs by setting IOCFGx.GPIOx_CFG = HIGHZ (48). Table 9<br/>
shows which signals can be input to the CC112X.<br/>
SWRU346B Page 17 of 114CC120X<br/>
GPIO Pin Signal Name Signal Description<br/>
0 SERIAL_TX Serial data (TX mode). Used for both synchronous and transparent<br/>
mode.<br/>
Synchronous serial mode: Data is captured on the rising edge of the<br/>
serial clock<br/>
1 Reserved<br/>
2 SYNC_DETECT In blind mode (see Section 5.1.2.2) sync detection must be done by the<br/>
MCU. When sync is found, the MCU should assert an output connected<br/>
to this pin (GPIO2) to make the receiver switch modem parameters from<br/>
sync search settings to packet receive settings similar as what is done in<br/>
FIFO mode/normal mode (see for instance<br/>
AGC_CFG3.AGC_SYNC_BEHAVIOUR). SYNC_CFG0.EXT_SYNC_DETECT<br/>
must be 1<br/>
3 EXT_40K_CLOCK External 40 kHz clock signal<br/>
Table 9: GPIO Input Pin Mapping<br/>
When changing IOCFGx.GPIOx_CFG or IOCFGx.GPIOx_INV the output can be unstable and this<br/>
should be handled by the MCU by for instance disable interrupts on GPIO pins until re-configuration is<br/>
done.<br/>
3.4.1 MCU Input/Interrupt<br/>
There are two main methods that can be used to generate an input/interrupt to the MCU<br/>
1. GPIO Signals<br/>
2. MCU WAKEUP<br/>
3.4.1.1 GPIO Signals<br/>
See Table 10 for the different signals that can be output from the CC120X. Note that all signals<br/>
described as a pulse are two XOSC periods long.<br/>
GPIOx_CFG Signal Name Description<br/>
0 RXFIFO_THR Associated to the RX FIFO. Asserted when the RX FIFO is filled above<br/>
FIFO_CFG.FIFO_THR. De-asserted when the RX FIFO is drained below<br/>
(or is equal) to the same threshold. This signal is also available in the<br/>
MODEM_STATUS1 register<br/>
1 RXFIFO_THR_PKT Associated to the RX FIFO. Asserted when the RX FIFO is filled above<br/>
FIFO_CFG.FIFO_THR or the end of packet is reached. De-asserted<br/>
when the RX FIFO is empty<br/>
2 TXFIFO_THR Associated to the TX FIFO. Asserted when the TX FIFO is filled above<br/>
(or is equal to) (127 −FIFO_CFG.FIFO_THR). De-asserted when the TX<br/>
FIFO is drained below the same threshold. This signal is also available in<br/>
the MODEM_STATUS0 register<br/>
3 TXFIFO_THR_PKT Associated to the TX FIFO. Asserted when the TX FIFO is full. De-<br/>
asserted when the TX FIFO is drained below<br/>
(127 − FIFO_CFG.FIFO_THR)<br/>
4 RXFIFO_OVERFLOW Asserted when the RX FIFO has overflowed. De-asserted when the RX<br/>
FIFO is flushed (see Section 3.2.4). This signal is also available in the<br/>
MODEM_STATUS1 register<br/>
5 TXFIFO_UNDERFLOW Asserted when the TX FIFO has underflowed. De-asserted when the TX<br/>
FIFO is flushed (see Section 3.2.4). This signal is also available in the<br/>
MODEM_STATUS0 register<br/>
6 PKT_SYNC_RXTX RX: Asserted when sync word has been received and de-asserted at the<br/>
end of the packet. Will de-assert when the optional address and/or<br/>
length check fails or the RX FIFO overflows/underflows.<br/>
TX: Asserted when sync word has been sent, and de-asserted at the end<br/>
of the packet. Will de-assert if the TX FIFO underflows/overflows<br/>
7 CRC_OK Asserted simultaneously as PKT_CRC_OK. De-asserted when the first<br/>
byte is read from the RX FIFO<br/>
8 SERIAL_CLK Serial clock (RX and TX mode). Synchronous to the data in synchronous<br/>
serial mode. Data is set up on the falling edge in RX and is captured on<br/>
the rising edge of the serial clock in TX<br/>
9 SERIAL_RX Serial data (RX mode). Used for both synchronous and transparent<br/>
mode.<br/>
Synchronous serial mode: Data is set up on the falling edge.<br/>
Transparent mode: No timing recovery (outputs just the hard limited<br/>
baseband signal)<br/>
SWRU346B Page 18 of 114CC120X<br/>
10 Reserved (used for test)<br/>
11 PQT_REACHED Preamble Quality Reached. Asserted when the quality of the preamble is<br/>
above the programmed PQT value (see Section 6.8). This signal is also<br/>
available in the MODEM_STATUS1 register<br/>
12 PQT_VALID Preamble quality valid. Asserted when the PQT logic has received a<br/>
sufficient number of symbols (see Section 6.8). This signal is also<br/>
available in the MODEM_STATUS1 register<br/>
13 RSSI_VALID RSSI calculation is valid<br/>
14 RSSI Signals<br/>
3 RSSI_UPDATE A pulse occurring each time the RSSI value is updated (see Figure 16)<br/>
2 RSSI_UPDATE A pulse occurring each time the RSSI value is updated (see Figure 16)<br/>
1 AGC_HOLD AGC waits for gain settling (see Figure 16)<br/>
0 AGC_UPDATE A pulse occurring each time the front end gain has been adjusted<br/>
(see Figure 16)<br/>
15 Clear channel assessment<br/>
3 CCA_STATUS Current CCA status<br/>
2 TXONCCA_DONE A pulse occurring when a decision has been made as to whether the<br/>
channel is busy or not. This signal must be used as an interrupt to the<br/>
MCU. When this signal is asserted/de-asserted, TXONCCA_FAILED can<br/>
be checked<br/>
1 CCA_STATUS Current CCA status<br/>
0 TXONCCA_FAILED TX on CCA failed. This signal is also available in the MARC_STATUS0<br/>
register<br/>
16 CARRIER_SENSE_VALID CARRIER_SENSE is valid (see Figure 16)<br/>
17 CARRIER_SENSE Carrier sense. High if RSSI level is above threshold (see Section 6.9.1)<br/>
(see Figure 16)<br/>
18 DSSS signals for DSSS repeat mode (RX).<br/>
MODCFG_DEV_E.MODEM_MODE = 1<br/>
3 DSSS_CLK DSSS clock (see Section 5.2.6 for more details)<br/>
2 DSSS_DATA0 DSSS data0 (see Section 5.2.6 for more details)<br/>
1 DSSS_CLK DSSS clock (see Section 5.2.6 for more details)<br/>
0 DSSS_DATA1 DSSS data1 (see Section 5.2.6 for more details)<br/>
19 PKT_CRC_OK Asserted in RX when PKT_CFG1.CRC_CFG = 1 or 10 and a good<br/>
b<br/>
packet is received. This signal is always on if the radio is in TX or if the<br/>
radio is in RX and PKT_CFG1.CRC_CFG = 0. The signal is de-asserted<br/>
when RX mode is entered and PKT_CFG1.CRC_CFG ≠ 0. This signal<br/>
is also available in the LQI_VAL register<br/>
20 MCU_WAKEUP MCU wake up signal. Read MARC_STATUS1.MARC_STATUS_OUT to find<br/>
the cause of the wake up event (see Section 3.4.1.2 for more details).<br/>
This signal is also available in the MARC_STATUS0 register. The signal is<br/>
a pulse<br/>
21 SYNC_LOW0_HIGH1 DualSync detect. Only valid when SYNC_CFG1.SYNC_MODE = 111.<br/>
b<br/>
When SYNC_EVENT is asserted this bit can be checked to see which<br/>
sync word is found. This signal is also available in the DEM_STATUS<br/>
register<br/>
22 3 Reserved (used for test)<br/>
2 Reserved (used for test)<br/>
1 Reserved (used for test)<br/>
0 AES_COMMAND_ACTIVE Indicates that an AES command is being executed<br/>
23 LNA_PA_REG_PD Common regulator control for PA and LNA. Indicates RF operation<br/>
24 LNA_PD Control external LNA4<br/>
25 PA_PD Control external PA4<br/>
26 RX0TX1_CFG Indicates whether RF operation is in RX or TX (this signal is 0 in IDLE<br/>
state)<br/>
27 Reserved (used for test)<br/>
28 IMAGE_FOUND Image detected by image rejection calibration algorithm<br/>
29 CLKEN_CFM Data clock for demodulator soft data (see Section 5.2.4 for more details)<br/>
4 This signal is active low. To control an external LNA, PA, or RX/TX switch in applications where the<br/>
SLEEP state is used it is therefore recommended to map this signal to GDO3 as this signal will be<br/>
hardwired to 1(0) in the SLEEP state.<br/>
SWRU346B Page 19 of 114CC120X<br/>
30 CFM_TX_DATA_CLK Data clock for modulator soft data (see Section 5.2.4 for more details)<br/>
31 - 32 Reserved (used for test)<br/>
33 RSSI_STEP_FOUND RSSI step found during packet reception (after the assertion of<br/>
SYNC_EVENT). The RSSI step is either 10 or 16 dB (configured through<br/>
AGC_CFG1.RSSI_STEP_THR). This signal is also available in the<br/>
DEM_STATUS register<br/>
34 3 AES_RUN AES enable. This signal is asserted as long as the AES module is<br/>
enabled given that AES.AES_ABORT = 0. This signal is also available<br/>
in the AES register<br/>
2 AES_RUN Same as 3<br/>
1 RSSI_STEP_EVENT RSSI step detected. This signal is asserted if there is an RSSI step of 3<br/>
or 6 dB during sync search or if there is an RSSI step of 10 or 16 dB<br/>
during packet reception. The RSSI step is configured through<br/>
AGC_CFG1.RSSI_STEP_THR). The signal is a pulse<br/>
0 RSSI_STEP_EVENT Same as 1<br/>
35 3 Reserved (used for test)<br/>
2 Reserved (used for test)<br/>
1 LOCK Out of lock status signal. Indicates out of lock when the signal goes low.<br/>
This signal is also available in the FSCAL_CTR register<br/>
0 LOCK Same a 1<br/>
36 ANTENNA_SELECT Antenna diversity control. Can be used to control external antenna<br/>
switch. If differential signal is needed, two GPIOs can be used with one<br/>
of them having IOCFGx.GPIOx_INV set to 1<br/>
37 MARC_2PIN_STATUS[1] Partial MARC state status. These signals are also available in the<br/>
MARCSTATE register<br/>
MARC_2PIN_STATUS[1] MARC_2PIN_STATUS[0] State<br/>
0 0 SETTLING<br/>
0 1 TX<br/>
1 0 IDLE<br/>
1 1 RX<br/>
38 MARC_2PIN_STATUS[0] See MARC_2PIN_STATUS[1]<br/>
39 3 Reserved (used for test)<br/>
2 TXFIFO_OVERFLOW Asserted when the TX FIFO has overflowed. De-asserted when the TX<br/>
FIFO is flushed (see Section 3.2.4). This signal is also available in the<br/>
MODEM_STATUS0 register<br/>
1 Reserved (used for test)<br/>
0 RXFIFO_UNDERFLOW Asserted when the RX FIFO has underflowed. De-asserted when the RX<br/>
FIFO is flushed (see Section 3.2.4). This signal is also available in the<br/>
MODEM_STATUS1 register<br/>
40 3 MAGN_VALID New CORDIC magnitude sample<br/>
2 CHFILT_VALID New channel filter sample<br/>
1 RCC_CAL_VALID RCOSC calibration has been performed at least once<br/>
0 CHFILT_STARTUP_VALID Channel filter has settled<br/>
41 3 COLLISION_FOUND Asserted if a new preamble is found and the RSSI has increased 10 or<br/>
16 dB during packet reception.<br/>
( MDMCFG1.COLLISION_DETECT_EN = 1)<br/>
This signal is also available in the DEM_STATUS register<br/>
2 SYNC_EVENT Sync word found (pulse)<br/>
1 COLLISION_FOUND Same as 3<br/>
0 COLLISION_EVENT Preamble found during receive with an RSSI step of 10 or 16 dB (pulse)<br/>
42 PA_RAMP_UP Asserted when ramping is started (for compliance testing)<br/>
43 3 CRC_FAILED Packet CRC error<br/>
2 LENGTH_FAILED Packet length error<br/>
1 ADDR_FAILED Packet address error<br/>
0 UART_FRAMING_ERROR Packet UART framing error<br/>
44 AGC_STABLE_GAIN AGC has settled to a gain. The AGC gain is reported stable whenever<br/>
the current gain setting is equal to the previous gain setting. This<br/>
condition is evaluated each time a new internal RSSI estimate is<br/>
computed (see Figure 16)<br/>
45 AGC_UPDATE A pulse occurring each time the front end gain has been adjusted<br/>
(see Figure 16)<br/>
SWRU346B Page 20 of 114CC120X<br/>
46 ADC data (test purposes only)<br/>
3 ADC_CLOCK ADC clock<br/>
2 ADC_Q_DATA_SAMPLE ADC sample (Q data)<br/>
1 ADC_CLOCK ADC clock<br/>
0 ADC_I_DATA_SAMPLE ADC sample (I data)<br/>
47 Reserved (used for test)<br/>
48 HIGHZ High impedance (tri-state)<br/>
49 EXT_CLOCK External clock (divided crystal clock). The division factor is controlled<br/>
through the ECG_CFG.EXT_CLOCK_FREQ register field<br/>
50 CHIP_RDYn Chip ready (XOSC is stable)<br/>
51 HW0 HW to 0 (HW to 1 achieved with IOCFGx.GPIOx_INV = 1)<br/>
52 - 53 (Reserved (used for test)<br/>
54 CLOCK_40K 40 kHz clock output from internal RC oscillator<br/>
55 WOR_EVENT0 WOR EVENT0<br/>
56 WOR_EVENT1 WOR EVENT1<br/>
57 WOR_EVENT2 WOR EVENT2<br/>
58 Reserved (used for test)<br/>
59 XOSC_STABLE XOSC is stable (has finished settling)<br/>
60 EXT_OSC_EN External oscillator enable (used to control e.g. a TCXO). Note that this<br/>
signal is only asserted is a TCXO is present<br/>
61 - 63 Reserved (used for test)<br/>
Table 10: GPIO Output Pin Mapping<br/>
3.4.1.2 MCU Wake-Up<br/>
The main purpose of the MCU wake-up feature is to wake up the MCU from power down mode at the<br/>
right time, i.e., when there is a need of intervention from the MCU side.<br/>
To use the MCU wake-up feature one of the GPIO pins should be configured to output the<br/>
MCU_WAKEUP signal (IOCFGx.GPIOx_CFG = MCU_WAKEUP (20)). Every time this signal is asserted,<br/>
the MCU should read MARC_STATUS1.MARC_STATUS_OUT to find the cause of the wake up event<br/>
and take appropriate action.<br/>
Table 11 shows all the different cases that can initiate a MCU wake-up (assertion of MCU_WAKEUP).<br/>
Please note that MCU_WAKEUP will only be asserted when the radio enters IDLE state.<br/>
SWRU346B Page 21 of 114CC120X<br/>
MARC_STATUS_OUT Description<br/>
00000000 No failure<br/>
00000001 RX timeout occurred. Only valid in RX mode and when not using eWOR<br/>
00000010 RX termination based on CS or PQT. Only valid in RX mode and when not using eWOR<br/>
00000011 eWOR sync lost (16 slots with no successful reception). Only valid in Feedback eWOR mode<br/>
(WOR_CFG1.WOR_MODE = 0)<br/>
00000100 Packet discarded due to maximum length filtering. Only valid in RX mode and when<br/>
RFEND_CFG0.TERM_ON_BAD_PKT is enabled.<br/>
Note: In eWOR Normal &amp; Feedback modes the wake up pulse will not be asserted and the CC120X<br/>
will go to SLEEP until the next time slot<br/>
00000101 Packet discarded due to address filtering. Only valid in RX mode and when<br/>
RFEND_CFG0.TERM_ON_BAD_PKT is enabled.<br/>
Note: In eWOR Normal &amp; Feedback modes the wake up pulse will not be asserted and the CC120X<br/>
will go to SLEEP until the next time slot<br/>
00000110 Packet discarded due to CRC filtering. Only valid in RX mode and when<br/>
RFEND_CFG0.TERM_ON_BAD_PKT is enabled.<br/>
Note: In eWOR Normal &amp; Feedback modes the wake up pulse will not be asserted and the CC120X<br/>
will go to SLEEP until the next time slot<br/>
00000111 TX FIFO overflow error occurred (the MCU should flush the TX FIFO)<br/>
00001000 TX FIFO underflow error occurred (the MCU should flush the TX FIFO)<br/>
00001001 RX FIFO overflow error occurred (the MCU should flush the RX FIFO)<br/>
00001010 RX FIFO underflow error occurred (the MCU should flush the RX FIFO)<br/>
00001011 TX ON CCA failed. A TX strobe was ignored due to a busy channel. In parallel the TXONCCA_DONE<br/>
signal is asserted together with the TXONCCA_FAILED signal. These signals can be output on GDO2<br/>
and GDO0 respectively by setting IOCFG2/0.GPIO2/0_CFG = 15. The TXONCCA_FAILED signal<br/>
is also available in the MARC_STATUS0 register together with TXONCCA_DONE<br/>
01000000 TX finished successfully (the CC120X is ready for the next operation)<br/>
10000000 RX finished successfully (a packet is in the RX FIFO ready to be read)<br/>
Table 11: MARC_STATUS_OUT<br/>
By setting RFEND_CFG0.CAL_END_WAKE_UP_EN = 1, the MCU will be given additional wake up<br/>
pulses at the end of calibration (MARC_STATUS_OUT will be 0).<br/>
4 On-Chip Temperature Sensor<br/>
The CC120X has a temperature sensor that can be activated by using the register settings shown in<br/>
Table 12. The temperature sensor is based on a PTAT current from a band-gap cell fed to a resistor<br/>
to generate a PTAT voltage.Please see DN403 [4] for more details.<br/>
Register Value<br/>
IOCFG1 0x80<br/>
ATEST 0x2A<br/>
ATEST_MODE 0x0C<br/>
GBIAS1 0x07<br/>
Table 12: Register Settings for Activating the Temp Sensor<br/>
SWRU346B Page 22 of 114CC120X<br/>
5 Common Receive and Transmit Configurations<br/>
5.1 Data Communication Modes<br/>
The CC120X supports different ways of setting up data communication, each with a defined area of<br/>
use. The following sections contain a description of the high level functionality of these different<br/>
modes of operation.<br/>
5.1.1 FIFO Mode/Normal Mode<br/>
FIFO mode is the preferred mode of operation. In this mode data is read from the RX FIFO and<br/>
written to the TX FIFO, making the data transfer to/from the MCU less time critical compared to what<br/>
is the case in the other modes. Using the FIFOs to buffer data allows the MCU to be in sleep mode<br/>
during RX/TX, reducing system power consumption.<br/>
In FIFO mode, sync and preamble insertion/detection are done automatically, and several other<br/>
optional packet handling features are supported in this mode. FIFO mode/Normal mode is enabled by<br/>
setting PKT_CFG2.PKT_FORMAT = 0.<br/>
5.1.2 Synchronous Serial Mode<br/>
In synchronous serial mode, data is clocked in and out of the CC112X by a clock provided by the<br/>
device. More details on this mode are found in Section 8.9.1. Synchronous serial mode is enabled by<br/>
setting PKT_CFG2.PKT_FORMAT = 1.<br/>
5.1.2.1 Sync Insertion/Detection Enabled<br/>
After the sync word is received/transmitted (SYNC_CFG1.SYNC_MODE ≠ 0), data is clocked in/out on<br/>
a GPIO pin with the associated clock on another GPIO pin. The serial clock is not output from the<br/>
device before the sync word is sent/received, hence the MCU can be in sleep mode until sync is<br/>
detected in RX mode.<br/>
Synchronous serial mode makes use of the WaveMatch detector, which means the performance will<br/>
be similar to the performance in FIFO mode.<br/>
5.1.2.2 Sync Insertion/Detection Disabled (Blind Mode)<br/>
Blind mode is synchronous serial mode with SYNC_CFG1.SYNC_MODE = 0. In this mode, the CC120X<br/>
will demodulate data/noise and it is the MCU that needs to monitor the data stream to find the framing<br/>
information. The serial clock will run continuously when the radio is in active mode.<br/>
If framing information is present in the signal, it is strongly advised to use either FIFO mode or<br/>
synchronous serial mode with sync detection enabled to make use of the strong WaveMatch detector<br/>
in CC120X (see Section 6.6).<br/>
Blind mode can be used in applications with no framing information, e.g. streaming data applications.<br/>
5.1.3 Transparent Serial Mode<br/>
In transparent serial mode (PKT_CFG2.PKT_FORMAT = 11 ) the CC120X is configured to resemble a<br/>
b<br/>
legacy analog RF front end device. In this mode data is only filtered through the channel filter and the<br/>
hard limited baseband signal is output directly on a GPIO pin. No symbol rate recovery or bit timing is<br/>
performed by the radio.<br/>
Transparent mode can be used for applications that have packet formats incompatible with the built-in<br/>
demodulator. Examples are pulse width modulation and pulse position modulation. When using<br/>
transparent mode, the demodulation must be performed by the MCU.<br/>
More details on this mode are found in Section 8.9.2.<br/>
SWRU346B Page 23 of 114CC120X<br/>
5.2 Modulation Formats<br/>
CC120X supports amplitude and frequency shift modulation formats. The desired modulation format is<br/>
set in the MODCFG_DEV_E.MOD_FORMAT register.<br/>
Optionally, the data stream can be Manchester encoded by the modulator and decoded by the<br/>
demodulator. This option is enabled by setting MDMCFG1.MANCHESTER_EN = 1. Note that<br/>
Manchester encoding/decoding is only performed on the payload (including optional length and<br/>
address field) and the CRC and that all packet handling features are still available. In applications<br/>
where preamble and sync word also need to be Manchester encoded, this can be achieved by<br/>
selecting PREAMBLE_CFG1.PREAMBLE_WORD = 10 or 11 and manually encoding a two byte long<br/>
b b<br/>
sync word and write it to SYNC3/2/1/0.<br/>
5.2.1 Frequency Shift Keying<br/>
CC120X supports both 2-FSK and 4-FSK modulation. Both can optionally be shaped by a Gaussian<br/>
filter with BT = 0.5, producing a GFSK modulated signal. This spectrum-shaping feature improves<br/>
adjacent channel power (ACP) and occupied bandwidth. When selecting 4-(G)FSK, the preamble and<br/>
sync word is sent using 2-(G)FSK (see Figure 9).<br/>
1/Symbol Rate 1/Symbol Rate 1/Symbol Rate<br/>
+1<br/>
+1/3<br/>
-1/3<br/>
-1<br/>
1 0 1 0 1 0 1 0 1 1 0 1 0 0 1 1 00 01 01 11 10 00 11 01<br/>
Preamble Sync Data<br/>
0xAA 0xD3 0x17 0x8D<br/>
Figure 9: Data Sent Over the Air (MDMCFG2.SYMBOL_MAP_CFG = 0)<br/>
In ‘true’ 2-FSK systems with abrupt frequency shifting, the spectrum is inherently broad. By making<br/>
the frequency shift ‘softer’, the spectrum can be made significantly narrower. Thus, higher symbol<br/>
rates can be transmitted in the same bandwidth using GFSK.<br/>
When 2-(G)FSK/4-(G)FSK modulation is used, the DEVIATION_M and MODCFG_DEV_E.DEV_E<br/>
register specifies the expected frequency deviation of incoming signals in RX and should be the same<br/>
as the TX deviation for demodulation to be performed reliably and robustly.<br/>
The frequency deviation is programmed with the DEV_M and DEV_E values in the DEVIATION_M and<br/>
MODCFG_DEV_E.DEV_E register. The value has an exponent/mantissa form, and the resultant<br/>
deviation is given by Equation 1 and Equation 2.<br/>
f<br/>
f xosc (256 DEV _M) 2DEV_E [Hz]<br/>
dev 222<br/>
Equation 1: f (DEVIATION_E &gt; 0)<br/>
dev<br/>
f<br/>
f xosc DEV _M [Hz]<br/>
dev 221<br/>
Equation 2: f (DEVIATION_E = 0)<br/>
dev<br/>
SWRU346B Page 24 of 114CC120X<br/>
The symbol encoding can be configured through the MDMCFG2.SYMBOL_MAP_CFG register field as<br/>
shown in Table 135 (SYMBOL_MAP_CFG = 0 by default).<br/>
Format Symbol Coding<br/>
SYMBOL_MAP_CFG SYMBOL_MAP_CFG SYMBOL_MAP_CFG SYMBOL_MAP_CFG =<br/>
= 00 = 01 = 10 11<br/>
b b b b<br/>
2-(G)FSK ‘0’ −Deviation [A ] +Deviation [A ] +Deviation[A ] +Deviation [A ]<br/>
Min Max Max Max<br/>
OOK/ASK ‘1’ +Deviation [A ] −Deviation [A ] −Deviation [A ] −Deviation [A ]<br/>
Max Min Min Min<br/>
4-(G)FSK ‘00’ −Deviation /3 −Deviation +Deviation /3 +Deviation<br/>
‘01’ −Deviation −Deviation /3 +Deviation +Deviation /3<br/>
‘10’ +Deviation /3 +Deviation −Deviation /3 −Deviation<br/>
‘11’ +Deviation +Deviation /3 −Deviation −Deviation /3<br/>
Table 13: Symbol Encoding for 2-(G)FSK and 4-(G)FSK Modulation<br/>
5.2.2 Amplitude Modulation (ASK) and on-off keying (OOK)<br/>
CC120X supports two different forms of amplitude modulation: On-Off Keying (OOK) and Amplitude<br/>
Shift Keying (ASK).<br/>
OOK modulation simply turns the PA on or off to modulate ones and zeros respectively.<br/>
When using OOK/ASK bit shaping can be enabled and the CC120X allows programming of both the<br/>
shape length and of the modulation depth (the difference between 1 and 0). Pulse shaping produces<br/>
a more bandwidth constrained output spectrum (see Figure 10).<br/>
The shape length is configured through PA_CFG0.RAMP_SHAPE and the modulation depth is<br/>
configured through ASK_CFG.ASK_DEPTH.<br/>
Figure 10: OOK with Shaping<br/>
5 A = Minimum Amplitude and A = Maximum Amplitude when OOK/ASK is used<br/>
Min Max<br/>
SWRU346B Page 25 of 114CC120X<br/>
5.2.3 Minimum Shift Keying<br/>
When using MSK6, the complete transmission (preamble, sync word, and payload) will be MSK<br/>
modulated.<br/>
MSK modulation is configured by MODCFG_DEV_E.MOD_FORMAT set to 2-(G)FSK modulation and<br/>
frequency deviation set to ¼ of symbol rate. Then phase shifts are performed with a constant<br/>
transition time. Table 14 shows what the frequency deviation should be programmed to for different<br/>
symbol rates to achieve a modulation index ~0.5.<br/>
Symbol Rate [ksps] Frequency Deviation [kHz] Actual Modulation Index<br/>
1.0 0.25 0.4940<br/>
1.2 0.3 0.5083<br/>
2.4 0.6 0.5083<br/>
4.8 1.2 0.5004<br/>
9.6 2.4 0.5006<br/>
19.6 4.8 0.5001<br/>
38.4 9.6 0.5007<br/>
50 12.5 0.5005<br/>
76.8 19.2 0.4997<br/>
100 25.0 0.5005<br/>
125 31.25 0.5005<br/>
250 62.5 0.5005<br/>
500 125 0.5005<br/>
Table 14: MSK Parameters<br/>
5.2.4 Custom Frequency Modulation(CFM)/Analog FM<br/>
CC120X supports a simple scheme to do custom frequency modulation/analog FM (e.g. communication<br/>
with analog legacy voice devices, N-FSK systems). This feature utilizes the high resolution PLL and<br/>
lets the user in a simple way directly control/read the instantaneous frequency without SPI overhead.<br/>
Custom frequency modulation is enabled by setting MDMCFG2.CFM_DATA_EN = 1.<br/>
One register (CFM_TX_DATA_IN) is used to set the carrier frequency offset and another register<br/>
(CFM_RX_DATA_OUT) is used to read the instantaneous frequency offset. The two registers have the<br/>
same format (two’s complement) to simplify SW control in both TX and RX. Accessing these registers<br/>
should be done using burst mode combined with setting EXT_CTRL.BURST_ADDR_INCR_EN = 0 to<br/>
continuously access the same address without any SPI address overhead.<br/>
The signal CFM_TX_DATA_CLK can be output on a GPIO by setting IOCFGx.GPIOx_CFG = 30. This<br/>
signal will be asserted every time the CFM_TX_DATA_IN register should be written and should be<br/>
used as an interrupt to the MCU to synchronize the SPI data to the internal modulation rate. The<br/>
signal runs at 16x the programmed symbol rate.<br/>
The signal CLKEN_CFM should be output on a GPIO (IOCFGx.GPIOx_CFG = 29) and used as a<br/>
trigger to read the CFM_RX_DATA_OUT samples. This signal runs at the same rate as the<br/>
programmed symbol rate.<br/>
Note that in TX mode, 3 dummy symbols should be written to the CFM_TX_DATA_IN register before<br/>
strobing SIDLE in order for all symbols to be sent on the air before TX mode is ended.<br/>
6 Identical to offset QPSK with half-sine shaping (data coding may differ).<br/>
SWRU346B Page 26 of 114CC120X<br/>
When using custom frequency modulation there are 129 values (referred to as f ) between −f<br/>
OFFSET dev<br/>
and +f that can be used (see Equation 1 and Equation 2 in Section 5.2.1 for details on how to<br/>
dev<br/>
program the frequency deviation). f is given by Equation 3.<br/>
OFFSET<br/>
f CFM _TX _DATA_IN<br/>
f dev [Hz]<br/>
OFFSET 64<br/>
Equation 3: f 7<br/>
OFFSET<br/>
The modulator writes values to the PLL at 16x the programmed symbol rate. Between the modulator<br/>
and the PLL there is an optional linear upsampler configured through the MDMCFG2.UPSAMPLER_P<br/>
register field.<br/>
5.2.5 DSSS PN Mode<br/>
CC120X supports DSSS PN mode for applications requiring high sensitivity. Preamble and sync word is<br/>
unchanged, but the payload data bit is spread with a fixed PN gold sequence initialized at the<br/>
beginning of each packet. The spreading factor is set to 4 hence the effective data rate is reduced by<br/>
a factor 4. The PN gold sequence is generated from a combination of two 7-bits LFSR registers with<br/>
generator polynomial given by Equation 4 and Equation 5. h1(p) is initialized to 0x04 and h2(p) is<br/>
initialized to 0x0B.<br/>
h1(p) p7 p3 p2 p 1<br/>
Equation 4: h1(p)<br/>
h2(p) p7 p3 1<br/>
Equation 5: h2(p)<br/>
The resulting bit is then XOR’ed with the transmitted bits, where each of the input data bits is mapped<br/>
into 4 consecutive symbols, as shown in the following Figure 11. The figure shows what is sent on the<br/>
air when the input data is 101 .<br/>
b<br/>
+<br/>
Input Data<br/>
@ ¼ Symbol Rate<br/>
Gold<br/>
Sequence<br/>
+ +<br/>
TX Data @ Symbol Rate<br/>
+ + +<br/>
TX Data @ Symbol Rate<br/>
Bit n Bit n + 1 Bit n + 2 Input Data @ ¼ Symbol Rate<br/>
Gold Sequence<br/>
Figure 11: Gold Sequence Generation<br/>
The resulting sequence has good autocorrelation properties.<br/>
7 This equation is only valid when -64 ≤ CFM_TX_DATA_IN ≤ +64. CFM_TX_DATA_IN &gt; 64<br/>
corresponds to +f while CFM_TX_DATA_IN &lt; -64 gives a frequency of −f . CFM_TX_DATA_IN<br/>
dev dev<br/>
= -128 is the same as setting CFM_TX_DATA_IN = 0.<br/>
SWRU346B Page 27 of 114CC120X<br/>
At the receiver, the PN gold sequence is known and is initialized at the beginning of each packet. For<br/>
every group of 4 incoming symbols, two accumulated distance computation are performed; one<br/>
assuming that a ‘0’ was sent and the other assuming that a ‘1’ was sent, and the most likely<br/>
transmitted bit is chosen.<br/>
DSSS PN mode is enabled by setting MODCFG_DEV_E.MODEM_MODE = 10 8.<br/>
b<br/>
When using this mode both FIFO mode and synchronous serial mode are supported<br/>
(PKT_CFG2.PKT_FORMAT = 0 or 1).<br/>
5.2.6 DSSS Repeat Mode<br/>
CC120X supports DSSS repeat mode for applications requiring high sensitivity. In DSSS repeat mode,<br/>
preamble is unchanged. The payload data bits are spread using the sync word meaning that the<br/>
complete sync word is sent for every 1 in the payload and the inverted sync word is sent for every 0 in<br/>
the payload. Only SYNC_CFG1.SYNC_MODE = 1 and 010 are supported (11 or 16 bits).<br/>
b<br/>
DSSS repeat mode is enabled by setting MODCFG_DEV_E.MODEM_MODE = 18.<br/>
In TX mode all packet handling features are supported, but the packet format must be set to FIFO<br/>
mode (PKT_CFG2.PKT_FORMAT = 0).<br/>
In RX mode, none of the packet handling features are supported and synchronous serial mode must<br/>
be selected (PKT_CFG2.PKT_FORMAT = 1, MDMCFG1.FIFO_EN = 0 and<br/>
MDMCFG0.TRANSPARENT_MODE_EN = 0). It is the MCU’s responsibility to extract the demodulated<br/>
data, which are available on GPIO by configuring IOCFGx.GPIOx_CFG = 18 (GPIO3/1 =<br/>
DSSS_CLK, GPIO2 = DSSS_DATA0 and GPIO0 = DSSS_DATA1). The clock (DSSS_CLK) will run at a<br/>
frequency twice the programmed symbol rate and will start as soon as the radio enters RX state.<br/>
The receiver uses two correlation filters (see Section 6.7 for more details) to search for sync word and<br/>
inverted sync word. Each output is connected directly to DSSS_DATA1 and DSSS_DATA0. After<br/>
strobing RX the sync search starts, and when a sync word or inverted sync word is detected the<br/>
corresponding serial data line will be asserted high, otherwise the data line is low. The output from the<br/>
correlation filter is high as long as the sync word/inverted sync word is detected, so the MCU needs to<br/>
do edge detect on the data in order to not duplicate the demodulated data bit. Figure 12 shows how<br/>
the DSSS signal will look like on the GPIO pins when the following packet is sent on the air using<br/>
DSSS repeat mode: 0x03, 0x55, 0x55, 0x55. Symbol rate is 1.2 ksps.<br/>
Note. Assertion of DSSS_DATA1 and DSSS_DATA0 within the first 5 DSSS_CLK edges after<br/>
entering RX should be ignored.<br/>
Figure 12: DSSS Repeat Mode<br/>
8 DSSS PN mode and DSSS repeat mode are not supported for 4’ary modulation formats.<br/>
SWRU346B Page 28 of 114CC120X<br/>
5.3 Forward Error Correction<br/>
FEC is enabled by settings PKT_CFG1.FEC_EN = 1. The FEC implemented in CC120X is compatible<br/>
with the 802.15.4g FEC (NRNSC coding) when PKT_CFG2.FS_MODE_EN = 1 and the FEC<br/>
implemented in the CC1101 when PKT_CFG2.FS_MODE_EN = 0.<br/>
The RXFIFO must not be accessed during packet reception when FEC is enabled, hence the<br/>
complete packet, excluding preamble and sync, must not be larger than 128 bytes. When using FEC,<br/>
the symbol rate must not exceed 250 ksps for 4’ary modulation formats or 500 ksps for 2’ary<br/>
modulation formats.<br/>
5.4 Symbol Rate Programming<br/>
The symbol rate used in transmit and the symbol rate expected in receive is programmed by the<br/>
SYMBOL_RATE_M and the SYMBOL_RATE_E configuration settings. The symbol rate, R , is given<br/>
SYMBOL<br/>
by Equation 6 and Equation 7 and is in ksps. Note that SYMBOL_RATE_M is 20 bits wide and consists<br/>
of the register fields SRATE_M_19_16, SRATE_M_15_8 and SRATE_M_7_0 found in SYMBOL_RATE2,<br/>
SYMBOL_RATE1, and SYMBOL_RATE0 respectively.<br/>
(220 SRATE_M) 2SRATE_E<br/>
R f [ksps]<br/>
Symbol 239 XOSC<br/>
Equation 6: Symbol Rate (SRATE_E &gt; 0)<br/>
SRATE_M<br/>
R f [ksps]<br/>
Symbol 238 XOSC<br/>
Equation 7: Symbol Rate (SRATE_E = 0)<br/>
Equation 8 and Equation 9 can be used to find suitable register values for a given symbol rate.<br/>
R 239<br/>
SRATE_E log Symbol 20<br/>
2 f<br/>
XOSC<br/>
Equation 8: SRATE_E<br/>
R 239<br/>
SRATE_M Symbol 220<br/>
f 2SRATE_E<br/>
XOSC<br/>
Equation 9: SRATE_M<br/>
If SYMBOL_RATE_M is rounded to the nearest integer and becomes 220, one should increment<br/>
SYMBOL_RATE_E and use SYMBOL_RATE_M = 0 instead.<br/>
The symbol rate can be set up to 500 ksps with the minimum step size according to<br/>
Table 15.<br/>
SWRU346B Page 29 of 114CC120X<br/>
Min Symbol Rate [ksps] Typical Symbol Rate [ksps] Max Symbol Rate [ksps] Symbol Rate Step Size [ksps]<br/>
0 0.04 0.15 0.00000014<br/>
0.15 0.25 0.3 0.00000014<br/>
0.61 1.2 1.22 0.0000006<br/>
1.22 2.4 2.44 0.000001<br/>
2.44 4.8 4.88 0.000002<br/>
4.88 9.6 9.76 0.000005<br/>
19.5 25 39.0 0.000018<br/>
39.0 50 78.1 0.000037<br/>
78.1 100 125 0.000074<br/>
156 250 312 0.00015<br/>
312 500 500 0.00029<br/>
Table 15: Symbol Rate Step Size<br/>
Note that for 4-(G)FSK, DSSS mode, Manchester mode, and FEC, the data rate and symbol rate is<br/>
not equal. Table 16 shows the relationship between data rate and symbol rate.<br/>
Modulation Format / Data Encoding Data Rate/Symbol Rate Rati o<br/>
2-(G)FSK/OOK/ASK R<br/>
Bit 1<br/>
R<br/>
Symbol<br/>
Manchester Mode R 1<br/>
Bit<br/>
R 2<br/>
Symbol<br/>
4-(G)FSK R<br/>
Bit 2<br/>
R<br/>
Symbol<br/>
DSSS Mode R 1<br/>
Bit<br/>
R Spreading Factor<br/>
Symbol<br/>
FEC R 1<br/>
Bit<br/>
R 2<br/>
Symbol<br/>
Table 16: Data Rate vs. Symbol Rate<br/>
6 Receive Configuration<br/>
6.1 RX Filter Bandwidth<br/>
In order to meet different channel width requirements, the RX filter BW is programmable. The<br/>
CHAN_BW.ADC_CIC_DECFACT and CHAN_BW.BB_CIC_DECFACT register fields control the RX filter<br/>
BW together with the crystal oscillator frequency. It is recommended to use SmartRF Studio [1] to<br/>
generate settings for a given RX filter BW.<br/>
Equation 10 gives the relation between the register settings and the RX filter bandwidth.<br/>
BB_CIC_DECFACT is found in CHAN_BW.<br/>
f<br/>
RX Filter BW xosc [Hz]<br/>
Decimation Factor BB_CIC_DECFACT 2<br/>
Equation 10: RX Filter BW<br/>
SWRU346B Page 30 of 114CC120X<br/>
The decimation factor is 12, 24, or 48 depending on the CHAN_BW.ADC_CIC_DECFACT setting.<br/>
Table 17 lists the RX filter bandwidth configurations supported by the CC120X. The RX filter BW should<br/>
never be set higher than 1666.7 kHz. Note that values marked () are only available on CC1200.<br/>
As a rule of thumb, one should set the decimation factor as high as possible for a given RX filter BW,<br/>
meaning that the preferred setting for 208.3 kHz is ADC_CIC_DECFACT = 2 and<br/>
BB_CIC_DECFACT = 2.<br/>
BB_CIC_DECFACT Decimation Factor BB_CIC_DECFACT Decimation Factor<br/>
12 24 48 12 24 48<br/>
1 1666.7 833.3 416.7 23 72.5 36.2 18.1<br/>
2 833.3 416.7 208.3 24 69.4 34.7 17.4<br/>
3 555.6 277.8 138.9 25 66.7 33.3 16.7<br/>
4 416.7 208.3 104.2 26 64.1 32.1 16.0<br/>
5 333.3 166.7 83.3 27 61.7 30.9 15.4<br/>
6 277.8 138.9 69.4 28 59.5 29.8 14.9<br/>
7 238.1 119.0 59.5 29 57.5 28.7 14.4<br/>
8 208.3 104.2 52.1 30 55.6 27.8 13.9<br/>
9 185.2 92.6 46.3 31 53.8 26.9 13.4<br/>
10 166.7 83.3 41.7 32 52.1 26.0 13.0<br/>
11 151.5 75.8 37.9 33 50.5 25.3 12.6<br/>
12 138.9 69.4 34.7 34 49.0 24.5 12.3<br/>
13 128.2 64.1 32.1 35 47.6 23.8 11.9<br/>
14 119.0 59.5 29.8 36 46.3 23.1 11.6<br/>
15 111.1 55.6 27.8 37 45.0 22.5 11.3<br/>
16 104.2 52.1 26.0 38 43.9 21.9 11.0<br/>
17 98.0 49.0 24.5 39 42.7 21.4 10.7<br/>
18 92.6 46.3 23.1 40 41.7 20.8 10.4<br/>
19 87.7 43.9 21.9 41 40.7 20.3 10.2<br/>
20 83.3 41.7 20.8 42 39.7 19.8 9.9<br/>
21 79.4 39.7 19.8 43 38.8 19.4 9.7<br/>
22 75.8 37.9 18.9 44 37.9 18.9 9.5<br/>
Table 17: RX Filter BW in kHz<br/>
By compensating for a frequency offset between the transmitter and the receiver, the filter bandwidth<br/>
can be reduced and the sensitivity can be improved.<br/>
The following rule should be used when programming the RX filter BW:<br/>
SYNC_CFG0.RX_CONFIG_LIMITATION = 0:<br/>
o The RX filter BW must be larger or equal to twice the symbol rate<br/>
SYNC_CFG0.RX_CONFIG_LIMITATION = 1:<br/>
o The RX filter BW must be larger or equal to the symbol rate<br/>
A narrow bandwidth gives better sensitivity and selectivity at the cost of more accurate RF crystals.<br/>
The CHAN_BW.ADC_CIC_DECFACT sets the bandwidth into the digital low-IF mixer.<br/>
If the selected RX filter bandwidth is large compared to the symbol rate (10 times of more), sensitivity<br/>
can be improved by setting MDMCFG0.DATA_FILTER_EN = 1.<br/>
6.2 DC Offset Removal<br/>
CC120X supports Low-IF and Zero-IF receiver architecture, which is set by the<br/>
IF_MIX_CFG.CMIX_CFG register field. For more information see section 9.12. For Zero-IF the DC<br/>
offset removal must be enabled by setting DCFILT_CFG.DCFILT_FREEZE_COEFF = 0. The<br/>
DCFILT_CFG configures the DC filter bandwidth, both during settling period and during tracking.<br/>
There is a tradeoff between bandwidth and settle time. Narrower DC filter bandwidth requires longer<br/>
settling time, but improves performance.<br/>
For best performance, use Low-IF receiver architecture when possible.<br/>
SWRU346B Page 31 of 114CC120X<br/>
6.3 Feedback to PLL<br/>
Register FREQOFF_CFG enables feedback to the PLL to &quot;increase the RX filter BW&quot;. The noise<br/>
bandwidth, and hence sensitivity, will not increase when enabling this feature. Setting FREQOFF_CFG<br/>
to 0x30 and 0x34 enables feedback to the PLL and increases bandwidth from &quot;programmed RX filter<br/>
BW&quot; to &quot;programmed RX filter BW ± RX filter BW/4&quot; and &quot;programmed RX filter BW ± RX filter BW/8&quot;<br/>
respectively. As an example, RX filter BW is programmed to 33.3 kHz and FREQOFF_CFG = 0x30,<br/>
the feedback to PLL increases this filter to 50 kHz (although 33.3 kHz is still the noise bandwidth).<br/>
Figure 13 shows two plots of PER vs. input power level vs. frequency offset. In the first plot the RX<br/>
filter BW is programmed to 50 kHz and FREQOFF_CFG = 0x22 (i.e. feedback to PLL disabled). In<br/>
the second plot the RX filter BW is programmed to 33.3 kHz and FREQOFF_CFG = 0x30 (i.e.<br/>
feedback to PLL enabled). It is evident from the plots that the noise bandwidth is lower in the second<br/>
plot without the need to use a tighter tolerance crystal.<br/>
50 kHz 33.3 kHz<br/>
No feedback and feedback<br/>
to PLL to PLL<br/>
Figure 13: Feedback to PLL<br/>
SWRU346B Page 32 of 114CC120X<br/>
6.4 Automatic Gain Control<br/>
CC120X contains an Automatic Gain Control (AGC) for adjusting the input signal level to the<br/>
demodulator.<br/>
The AGC behavior depends on the following register fields:<br/>
AGC_CFG2.FE_PERFORMANCE_MODE<br/>
o Sets the correct gain tables to be applied for a given operation mode (See Table 18). See<br/>
the complete register description for what the different modes are.<br/>
~39 dB Index 0 ~27 dB Index 0 ~39 dB Index 0<br/>
~36 dB Index 1 ~24 dB Index 1 ~32 dB Index 1<br/>
~32 dB Index 2 ~21 dB Index 2 ~27 dB Index 2<br/>
~29 dB ~18 dB ~21 dB<br/>
~27 dB ~15 dB ~15 dB<br/>
~24 dB ~12 dB ~9 dB<br/>
~21 dB ~9 dB ~3 dB<br/>
~18 dB ~6 dB ~0 dB Index 7<br/>
~15 dB ~3 dB<br/>
~12 dB ~0 dB<br/>
~9 dB ~-6 dB<br/>
~6 dB ~-12 dB<br/>
~3 dB ~-18 dB<br/>
~0 dB ~-21 dB Index 13<br/>
~-6 dB<br/>
~-12 dB<br/>
~-18 dB<br/>
~-21 dB Index 17<br/>
FE_PERFORMANCE_MODE FE_PERFORMANCE_MODE FE_PERFORMANCE_MODE<br/>
= 0 or 1 = 10 = 11<br/>
b b<br/>
Table 18: AGC Gain Tables<br/>
o The AGC_CFG2.AGC_MAX_GAIN and AGC_CFG3.AGC_MIN_GAIN register fields are used<br/>
to set the table indexes for maximum and minimum gain respectively. For example, setting<br/>
AGC_MAX_GAIN = 2 and AGC_MIN_GAIN = 15 limits the gain table to 14 entries, where<br/>
max gain is ~32 dB and min gain is ~-12 dB. A lower maximum gain will reduce power<br/>
consumption in the receiver front end, since the highest gain settings are avoided. Limiting<br/>
max gain also improves worst case linearity in the front-end, something that is very useful<br/>
when using external LNA.<br/>
AGC_REF.AGC_REFERENCE<br/>
o Sets the reference value for the AGC. The reference value is a compromise between<br/>
blocker tolerance/selectivity and sensitivity. The AGC reference level must be higher than<br/>
the minimum SNR to the demodulator. The AGC reduces the analog front end gain when<br/>
the magnitude output from the channel filter is greater than the AGC reference level. An<br/>
optimum AGC reference level is given by several conditions, but a rule of thumb is given by<br/>
Equation 11.<br/>
AGC_REFERENCE 10 log (RX FILTER BW) 92 RSSI_OFFSET<br/>
10<br/>
Equation 11: AGC Reference9<br/>
9 For Zero-IF configuration, AGC hysteresis &gt; 3 dB, or modem format which needs SNR &gt; 15 dB a<br/>
higher AGC reference value is needed<br/>
SWRU346B Page 33 of 114CC120X<br/>
AGC_CFG3.AGC_SYNC_BEHAVIOR<br/>
o Sets the AGC behavior and RSSI update behavior after a sync word is found<br/>
AGC_CFG1.AGC_WIN_SIZE<br/>
o Sets the AGC integration window size for each value. Samples refer to the RX filter<br/>
sampling frequency, which is 4 times the programmed RX filter BW<br/>
AGC_CFG1.AGC_SETTLE_WAIT<br/>
o Sets the wait time between AGC gain adjustments<br/>
AGC_CFG2.AGC_MAX_GAIN<br/>
o Sets the maximum gain<br/>
AGC_CFG3.AGC_MIN_GAIN<br/>
o Sets the minimum gain<br/>
See Figure 16 for detailed timing information on different AGC signals.<br/>
6.5 Image Compensation<br/>
CC120X has support for the ImageExtinct image compensation algorithm that digitally compensates for<br/>
I/Q mismatch. ImageExtinct removes the image component, removing any issues at the system image<br/>
frequency. ImageExtinct removes the need for time consuming image calibration steps in system<br/>
production test, reducing both test time and test cost. This feature is enabled by setting<br/>
IQIC.IQIC_EN = 1. When this feature is enabled, f &gt; RX filter BW. Figure 14 shows selectivity<br/>
IF<br/>
versus frequency with IQ image compensation enabled and disabled.<br/>
70<br/>
] 60<br/>
M<br/>
d<br/>
[ 50<br/>
e<br/>
v<br/>
it<br/>
a 40<br/>
le<br/>
R<br/>
y<br/>
30<br/>
t<br/>
iv IQ Enabled<br/>
it 20<br/>
c<br/>
e IQ Disabled<br/>
le<br/>
10<br/>
S<br/>
0<br/>
8 9 0 5 4 1 5 7 2 5 5 5 8 3<br/>
.7<br/>
6 8<br/>
.7<br/>
6 8<br/>
0<br/>
0 0 ,8<br/>
0<br/>
.8 6 8<br/>
9<br/>
0 .8 6<br/>
.8<br/>
6 8<br/>
1<br/>
.8 6 8<br/>
9<br/>
1 .8 6<br/>
.8<br/>
6 8<br/>
2<br/>
2 .8 6<br/>
2<br/>
.8 6 8<br/>
7<br/>
2 .8 6<br/>
8<br/>
2 .8 6<br/>
.8<br/>
6 8<br/>
6 8 8 8 8 8<br/>
8<br/>
Frequency [MHz]<br/>
Figure 14: IQIC Enabled/Disabled (image at −206 kHz offset)<br/>
SWRU346B Page 34 of 114CC120X<br/>
6.6 Bit Synchronization<br/>
The bit synchronization algorithm extracts the clock from the incoming symbols. The algorithm<br/>
requires that the expected symbol rate is programmed as described in Section 5.3. Re-<br/>
synchronization is performed continuously to adjust for any offset between the incoming and<br/>
programmed symbol rate.<br/>
It is possible to select between two different bit synchronization algorithms.<br/>
TOC_CFG.TOC_LIMIT sets the bit synchronization algorithm and Table 19 below shows the<br/>
properties of the bit synchronization algorithms.<br/>
TOC_LIMIT Symbol Rate Offset Tolerance Required Preamble Length<br/>
0 &lt; 0.2 % 0.5 byte (only for gain adjustment)<br/>
1 &lt; 2 % 2 - 4 bytes<br/>
2 Reserved<br/>
3 &lt; 12 % 2 - 4 bytes<br/>
Table 19: Bit Synchronization Property<br/>
Using the low tolerance setting (TOC_LIMIT = 0) greatly reduces system settling times and system<br/>
power consumption as no preamble bits are needed for bit synchronization or frequency offset<br/>
compensation (4 bits preamble needed for AGC settling).<br/>
6.7 Byte Synchronization, Sync Word Detection<br/>
Byte synchronization is achieved by a continuous sync word search using the novel WaveMatch<br/>
capture logic (correlation filter). The sync word is configured through the SYNC3/2/1/0 registers and<br/>
can be programmed to be 11, 16, 18, 24 or 32 bits. This is done through the<br/>
SYNC_CFG1.SYNC_MODE register field. In TX mode, these bits are automatically inserted at the start<br/>
of the packet by the modulator. The MSB in the sync word is sent first. In RX mode, the demodulator<br/>
uses the sync word to find the start of the incoming packet.<br/>
The CC120X will continuously calculate a sync word qualifier value to distinguish the sync word from<br/>
background noise. This value is available in the PQT_SYNC_ERR.SYNC_ERROR register field. If the<br/>
sync word qualifier value is less than the programmed sync threshold (SYNC_CFG1.SYNC_THR)<br/>
divided by 2 the demodulator starts to demodulate the packet.<br/>
The CC120X supports DualSync search which makes it possible to concurrently search for 2 different<br/>
16 bit sync words. DualSync search is enabled by settings SYNC_CFG1.SYNC_MODE = 111 . As<br/>
b<br/>
soon as one of the sync words is found, the RX FIFO starts to fill up.<br/>
In addition to continuously calculating a sync word qualifier value the CC120X has several other<br/>
features that can be used to decrease the likelihood of detecting “false” packets.<br/>
Strict Sync Word Bit Check<br/>
This feature is enabled through SYNC_CFG0.STRICT_SYNC_CHECK and allows for additional<br/>
bit check on sync word. This feature is especially useful if the sync word used has weak<br/>
correlation properties. There are three levels of the strict sync check, where level 3 is the<br/>
setting that allows for the least amount of error in the sync word (the strictest setting). Setting<br/>
STRICT_SYNC_CHECK = 11 disables this feature and is the settings that will give the best<br/>
b<br/>
sensitivity.<br/>
Carrier Sense Gating<br/>
When MDMCFG1.CARRIER_SENSE_GATE = 1, the demodulator will not start to look for a sync<br/>
word before CARRIER_SENSE is asserted. See Section 6.9.1 for more details on CS.<br/>
PQT Gating<br/>
When SYNC_CFG0.PQT_GATING_EN = 1, the demodulator will not start to look for a sync<br/>
word before a preamble is detected. The preamble detector must be enabled for this feature to<br/>
work (PREAMBLE_CFG0.PQT_EN = 1). See Section 6.8 for more details on PQT.<br/>
SWRU346B Page 35 of 114CC120X<br/>
6.8 Preamble Detection<br/>
CC120X has a high performance preamble detector which can be turned on by setting<br/>
PREAMBLE_CFG0.PQT_EN = 1.<br/>
The preamble quality estimator uses an 8 bits wide correlation filter to find a valid preamble. A<br/>
preamble qualifier value is available through the PQT_SYNC_ERR.PQT_ERROR register field while the<br/>
threshold is configured with the register field PREAMBLE_CFG0.PQT.<br/>
A preamble is detected if the preamble qualifier value is less than the programmed PQT threshold. A<br/>
“Preamble Quality Reached” signal can be observed on one of the GPIO pins by setting<br/>
IOCFGx.GPIOx_CFG = PQT_REACHED (11). It is also possible to determine if preamble quality is<br/>
reached by checking the PQT_REACHED bit in the MODEM_STATUS1 register. The PQT_REACHED<br/>
signal will stay asserted as long as a preamble is present but will de-assert on sync found. If the<br/>
preamble disappears, the signal will de-assert after a timeout defined by the sync word length + 10<br/>
symbols after preamble was lost. When SYNC_CFG0.PQT_GATING_EN = 1, sync word search is<br/>
only gated if a preamble is detected.<br/>
The PQT can also be used as a qualifier for the optional RX termination timer (see Section 9.5.1 for<br/>
more details).<br/>
A PQT startup timer is available and programmable through the<br/>
PREAMBLE_CFG0.PQT_VALID_TIMEOUT register. The PQT response time is the time it takes from<br/>
entering RX mode until PQT_VALID is asserted. The PQT response time is given by Equation 12,<br/>
where T0 is given by Equation 18 and T1 is given by Equation 13 or Equation 14 depending on the<br/>
SYMBOL_RATE2.SRATE_E setting. BB_CIC_DECFACT is found in register CHAN_BW and the<br/>
decimation factor is 12, 24, or 48, given by the CHAN_BW.ADC_CIC_DECFACT register field. SRATE_E<br/>
and SRATE_M are found in the SYMBOL_RATEn registers (where n = 0, 1, 2) and<br/>
RX_CONFIG_LIMITATION is found in SYNC_CFG0. In Equation 13 or Equation 14, x = Decimation<br/>
Factor·BB_CIC_DECFACT.<br/>
PQT Response Time T0 T1<br/>
Equation 12: PQT Response Time<br/>
238 PQT Startup Timer (2 RX _CONFIG_LIMITATION 2)<br/>
x FLOOR 1<br/>
SRATE_M x 1<br/>
T1 56<br/>
2 .RX _CONFIG_LIMITATION 2 f<br/>
XOSC<br/>
Equation 13: T1 when SRATE_E = 0<br/>
239 PQT Startup Timer (2 RX _CONFIG_LIMITATION 2)<br/>
x FLOOR<br/>
(SRATE_M 220)SRATE_E x 1<br/>
T1 56<br/>
2 .RX _CONFIG_LIMITATION 2 f<br/>
XOSC<br/>
Equation 14: T1 when SRATE_E ≠ 0<br/>
The different PQT startup timer values enables a tradeoff between speed and accuracy as preamble<br/>
search will not be gated before PQT_VALID is asserted. PQT_VALID can be monitored on a GPIO pin<br/>
by setting IOCFGx.GPIOx_CFG = PQT_VALID (12).<br/>
SWRU346B Page 36 of 114CC120X<br/>
6.9 RSSI<br/>
The AGC module returns an estimate on the signal strength received at the antenna called RSSI<br/>
(Received Signal Strength Indicator). The RSSI is a 12 bits two&#x27;s complement number with 0.0625 dB<br/>
resolution hence ranging from –128 to 127 dBm. A value of –128 dBm indicates that the RSSI is<br/>
invalid. The RSSI can be found by reading RSSI1.RSSI_11_4 and RSSI0.RSSI_3_0. It should be<br/>
noted that for most applications using the 8 MSB bits of the RSSI, with 1 dB resolution, is good<br/>
enough.<br/>
To get a correct RSSI value a calibrated RSSI offset value should be added to the value given by<br/>
RSSI[11:0] (the RSSI offset will be a negative number). The RSSI offset value can be found by<br/>
input a signal of known strength to the radio when AGC_GAIN_ADJUST.GAIN_ADJUSTMENT is<br/>
0x0010.<br/>
Example:<br/>
Assume a -65 dBm signal into the antenna and RSSI[11:0] = 0x220 (34) when<br/>
AGC_GAIN_ADJUST.GAIN_ADJUSTMENT = 0x00.<br/>
This means that the offset is −99 dB as 34 dBm + (–99) dB = –65 dBm.<br/>
When the offset is known it can be written to the AGC_GAIN_ADJUST.GAIN_ADJUSTMENT<br/>
register field (GAIN_ADJUSTMENT = 0x9D (−99)). When the same signal is input to the antenna,<br/>
the RSSI[11:0] register will be 0xBF0 (–65).<br/>
The RSSI value is output from a configurable moving average filter in order to reduce uncertainty in<br/>
the RSSI estimates. It is as such possible to trade RSSI computation speed/update rate against RSSI<br/>
accuracy. This trade-off is determined by configuring the AGC_CFG0.RSSI_VALID_CNT register. This<br/>
register field gives the number of new input samples to the moving average filter (internal RSSI<br/>
estimates) that are required before the next update of the RSSI value11. The RSSI_VALID signal will<br/>
be asserted from the first RSSI update. RSSI_VALID is available on a GPIO by setting<br/>
IOCFGx.GPIOx_CFG = RSSI_VALID (13) or can be read from the RSSI0 register.<br/>
Carrier Sense (CS) indication will also be affected by the setting of AGC_CFG0.RSSI_VALID_CNT.<br/>
After the RSSI is valid it will be continuously compared to the CS threshold set in the AGC_CS_THR<br/>
register, but since the RSSI update rate is given by the RSSI_VALID_CNT register field, this will in<br/>
practice limit the CS update rate as well. The exception is when the CS threshold is changed while in<br/>
RX mode. The CARRIER_SENSE signal will then be updated immediately (if needed). For more info<br/>
on CS, see Section 6.9.1. Figure 15 shows when CS is updated with respect to the RSSI.<br/>
Signal Strength<br/>
CS Threshold<br/>
RSSI<br/>
CARRIER_SENSE<br/>
Time<br/>
RSSI Update<br/>
Figure 15: CS vs. RSSI_UPDATE<br/>
Figure 16 shows an example of the behavior of RSSI specific signals given two different values for the<br/>
AGC_CFG0.RSSI_VALID_CNT register value (1 and 10 ).<br/>
b<br/>
10 The RSSI offset changes if MDMCFG1.DVGA_GAIN is changed<br/>
11 By setting the IOCFG3.GPIO3_CFG or IOCFG2.GPIO2_CFG = RSSI_UPDATE (14), a pulse<br/>
will occur on GPIO3 or GPIO2 each time the RSSI value is updated<br/>
SWRU346B Page 37 of 114CC120X<br/>
MARCSTATE IDLE RX<br/>
AGC State IDLE W M W M M M M M M M M M M M M M M M<br/>
Frontend Gain G_MAX G_1 &lt; G_MAX<br/>
AGC_UPDATE<br/>
Internal RSSI Estimate #0 #1 #2 #3 #4 #5 #6 #7 #8 #9 #10 #11 #12 #13 #14 #15<br/>
AGC_STABLE_GAIN<br/>
AGC_HOLD<br/>
RSSI_VALID_CNT 01b<br/>
RSSI[11:0] -128<br/>
RSSI_UPDATE<br/>
CARRIER_SENSE<br/>
CARRIER_SENSE_VALID<br/>
RSSI_VALID_CNT 10b<br/>
RSSI[11:0] -128<br/>
RSSI_UPDATE<br/>
CARRIER_SENSE<br/>
CARRIER_SENSE_VALID<br/>
Time Intervals T0-T3 T1 T2+T3 T1 T2+T3 T2+T3 T2+T3 T2+T3 T2+T3<br/>
Time<br/>
Carrier Sense Response Time<br/>
Figure 16: RSSI/CS Timing Diagram<br/>
SWRU346B Page 38 of 114CC120X<br/>
T0: Start-up delay before RSSI measurements can begin. This delay is dependent on demodulator<br/>
settings and can be found using Table 21, Table 22, and Equation 18.<br/>
T1: The time the AGC waits after adjusting the front end gain to allow signal transients to decay<br/>
before the next signal strength measurement can take place. T1 can be calculated using Equation 15.<br/>
T2: The time the AGC uses to measure the signal strength and potentially adjust the gain. T2 can be<br/>
calculated using Equation 16.<br/>
T3: Pipeline delay. T3 can be calculated using Equation 17.<br/>
The CS response time is the time it takes before CARRIER_SENSE_VALID is asserted. This is the<br/>
maximum time the radio will be in RX state when RX termination based on CS is enabled (see<br/>
Section 9.5.2 for more details). The CS response time is given by Equation 19.<br/>
Figure 16 shows an example of how RSSI computation speed/update rate can be traded against<br/>
RSSI accuracy. In the case where AGC_CFG0.RSSI_VALID_CNT = 1 the number of new input<br/>
samples to the moving average filter is 2, making the CS response time short but might lead to a less<br/>
robust CS indication on the second RSSI update. In the case where AGC_CFG0.RSSI_VALID_CNT<br/>
= 10 (5 samples) there are no failing CS, but the response time is longer.<br/>
b<br/>
BB_CIC_DECFACT12 is found in register CHAN_BW while AGC_SETTLE_WAIT and AGC_WIN_SIZE<br/>
register fields are found in the AGC_CFG1 register. DCFILT_FREEZE_COEFF and<br/>
DCFILT_BW_SETTLE are found in DCFILT_CFG. The decimation factor is 12, 24, or 48, given by the<br/>
CHAN_BW.ADC_CIC_DECFACT register field and CMIX_CFG is found in the IF_MIX_CFG register.<br/>
RSSI_VALID_COUNT is found in AGC_CFG0 and IQIC_EN is found in IQIC.<br/>
The notation m(register field name) means the value in the description field that match the bit pattern.<br/>
For example, m(RSSI_VALID_COUNT) = 9 if RSSI_VALID_COUNT = 11 .<br/>
b<br/>
m(AGC_SETTLE_WAIT) BB_CIC_DECFACT Decimation Factor<br/>
T1 [s]<br/>
RSSI Update Rate Scale Factor f<br/>
xosc<br/>
Equation 15: T1<br/>
2(3 AGC_WIN_SIZE) BB_CIC_DECFACT Decimation Factor<br/>
T2 [s]<br/>
RSSI Update Rate Scale Factor f<br/>
xosc<br/>
Equation 16: T2<br/>
48 t<br/>
T3 CEILING Sample Period [s] , where<br/>
t f<br/>
Sample Period xosc<br/>
BB_CIC_DECFACT Decimation Factor<br/>
t<br/>
Sample Period RSSI Update Rate Scale Factor f<br/>
xosc<br/>
Equation 17: T3<br/>
12 If BB_CIC_DECFACT = 0, use a value of 1<br/>
SWRU346B Page 39 of 114CC120X<br/>
In Equation 15, Equation 16, and Equation 17, the RSSI update rate scale factor is given by<br/>
SYNC_CFG0.RX_CONFIG_LIMITATION as shown in Table 20.<br/>
RX_CONFIG_LIMITATION RSSI Update Rate Scale Factor<br/>
0 2<br/>
1 4<br/>
Table 20: RSSI Update Rate Scale Factor<br/>
Configuration Register Fields/Conditions T0<br/>
CHAN_BW.BB_CIC_DECFACT &gt; 0x01<br/>
0 D + D + D + D<br/>
0 1 2 3<br/>
1 D + D + D + D + D<br/>
0 1 2 3 4<br/>
Table 21: T0 Matrix<br/>
Delay Equation (all delays are given in seconds)<br/>
D 8 Decimation Factor 20<br/>
0<br/>
f<br/>
XOSC<br/>
D 113 (1 DCFILT_FREEZE_COEFF) (2(x3) 1) Decimation Factor<br/>
f<br/>
XOSC<br/>
D 12 BB_CIC_DECFACT Decimation Factor 6<br/>
2<br/>
f<br/>
XOSC<br/>
D14 2 IQIC_EN y 4<br/>
3<br/>
f<br/>
XOSC<br/>
D (15 BB_CIC_DECFACT 2) Decimation Factor 6<br/>
4<br/>
f<br/>
XOSC<br/>
Table 22: D – D<br/>
0 4<br/>
T0 ApplicableDelays|<br/>
Current Configuration<br/>
Equation 18: T0<br/>
The maximum carrier sense response time is given by Equation 19.<br/>
10<br/>
CS Response Time T (T T T ) m(RSSI_VALID_COUNT) T3<br/>
0 1 2 3 f<br/>
xosx<br/>
Equation 19: Max CS Response Time [s]<br/>
If number of AGC_UPDATE pulses before the first RSSI update is known, the CS response time is<br/>
given by Equation 20.<br/>
10<br/>
CS Response Time T T x (T T ) m(RSSI_VALID_COUNT) T3<br/>
0 1 2 3 f<br/>
xosx<br/>
Equation 20: CS Response Time [s] (# of gain reductions is known)<br/>
In cases where AGC_CFG1.AGC_SYNC_BEHAVIOR is set to freeze the RSSI value after a sync word<br/>
is detected, it is important that preamble and sync word is long enough so that the RSSI represent the<br/>
RSSI of the packet and not of noise received prior to the preamble.<br/>
13 x = DCFILT_CFG.DCFILT_BW_SETTLE when DCFILT_CFG.DCFILT_BW_SETTLE &lt; 5,<br/>
else it is 4<br/>
14 y = 0 when IF_MIX_CFG.CMIX_CFG = 0 or 100 , else it is 1<br/>
b<br/>
SWRU346B Page 40 of 114CC120X<br/>
Assume a symbol rate of 2.4 ksps and the following register configurations:<br/>
CHAN_BW.ADC_CIC_DECFACT = 2<br/>
CHAN_BW.BB_CIC_DECFACT = 38<br/>
AGC_CFG1.AGC_WIN_SIZE = 2<br/>
AGC_CFG0.RSSI_VALID_CNT = 1<br/>
AGC_CFG1.SETTLE_WAIT = 1<br/>
SYNC_CFG0.RX_CONFIG_LIMITATION = 0<br/>
Equation 19 can be used to find the max RSSI update rate. For this example it is assumed that the<br/>
radio has been in RX for some time before a packet is received so T0 can be ignored.<br/>
10<br/>
RSSI Update Rate (T T T ) m(RSSI_VALID_COUNT) T3<br/>
1 2 3 f<br/>
xosx<br/>
m(AGC_SETTLE_WAIT) BB_CIC_DECFACT Decimation Factor 32 38 48<br/>
T1 729.6 μs<br/>
RSSI Update Rate Scale Factor f 2 40 106<br/>
xosc<br/>
2(3 AGC_WIN_SIZE) BB_CIC_DECFACT Decimation Factor 2(3 2) 38 48<br/>
T2 729.6 μs<br/>
RSSI Update Rate Scale Factor f 2 40 106<br/>
xosc<br/>
BB_CIC_DECFACT Decimation Factor 38 48<br/>
t 22.8 10 6<br/>
Sample Period RSSI Update Rate Scale Factor f 2 40 106<br/>
xosc<br/>
48 22.8 10 6<br/>
T3 CEILING 1.2 μs<br/>
22.8 10 6 f<br/>
xosc<br/>
10<br/>
RSSI Update Rate (T T T ) m(RSSI_VALID_COUNT) T3<br/>
1 2 3 f<br/>
xosx<br/>
10<br/>
(729 10 6 729 10 6 1.2 10 6) 2 1.2 10 6 2.92 ms<br/>
40 106<br/>
To guarantee that the RSSI measurement is done during the packet and not on noise, preamble +<br/>
sync word should be greater than twice the RSSI update rate.<br/>
With a symbol rate of 2.4 ksps this means that a minimum of 14 bits preamble/sync must be received<br/>
for the RSSI readout to be correct (assume that R /R = 1). For this example it is assumed that<br/>
Bit Symbol<br/>
the radio has been in RX for a time longer than the max CS response time (see Equation 19) when<br/>
the preamble and sync word is received.<br/>
SWRU346B Page 41 of 114CC120X<br/>
6.9.1 Carrier Sense (CS)<br/>
Carrier Sense (CS) is asserted when the RSSI is above a programmable CS threshold, AGC_CS_THR,<br/>
and de-asserted when RSSI is below the same threshold. The CS threshold should be set high<br/>
enough so that CS is de-asserted when only background noise is present and low enough so that CS<br/>
is asserted when a wanted signal is present. Different usage of CS includes:<br/>
Sync word qualifier: When MDMCFG1.CARRIER_SENSE_GATE = 1, the demodulator will not<br/>
start to look for a sync word before CS is asserted<br/>
Clear Channel Assessment (CCA) and TX on CCA<br/>
Avoid interference from other RF sources in the ISM band<br/>
RX termination<br/>
The latter is described in Section 9.5. By setting the IOCFGX.GPIOX_CFG = CARRIER_SENSE (17),<br/>
GPIOx will indicate if a carrier is present. The CS signal is evaluated each time a new internal RSSI<br/>
estimate is computed. The CARRIER_SENSE signal must only be interpreted when it is valid, as<br/>
indicated by CARRIER_SENSE_VALID. This signal can be routed to GPIOX by setting<br/>
IOCFGX.GPIOX_CFG = CARRIER_SENSE_VALID (16) to help evaluate this in real-time. The two<br/>
signals can also be read from the RSSI0 register.<br/>
6.10 Collision Detector<br/>
If a packet is currently being received by the radio (data is put in the RX FIFO) when a preamble is<br/>
found with a RSSI 10 or 16 dB higher than the RSSI at the time when SYNC_EVENT was asserted, a<br/>
collision has found place (COLLISION_FOUND is asserted). A collision can be handled in several<br/>
different ways.<br/>
Not handled. The current packet received will have errors and can be discarded. This method<br/>
will work well in most systems as RF protocols have capabilities for re-transmissions to solve<br/>
these issues.<br/>
RX can be terminated and resumed later.<br/>
RX can be restarted to receive the new packet (this scenario is mainly for high throughput<br/>
protocols where nodes communicate with several nodes at various distances). The SRX strobe<br/>
can be used to immediately restart the demodulator to catch the incoming packet. Since an<br/>
SFRX strobe cannot be issued from RX state one should read the NUM_RXBYTES register to<br/>
find out how many bytes belong to the first packet. CC120X has several signals that can be used<br/>
to indicate a collision. These are RSSI_STEP_FOUND, RSSI_STEP_EVENT,<br/>
COLLISION_FOUND, and COLLISION_EVENT described in Table 10.<br/>
6.11 Clear Channel Assessment (CCA)<br/>
The Clear Channel Assessment (CCA) is used to indicate if the current channel is free or busy. The<br/>
current CCA state is viewable on GPIO1 or GPIO3 by setting IOCFG1/3.GPIO1/3_CFG =<br/>
CCA_STATUS (15). There are also two other flags related to the CCA feature available. These are<br/>
TXONCCA_DONE and TXONCCA_FAILED and are available on GPIO2 and GPIO0 respectively by<br/>
using the same IOCFG configuration as for CCA_STATUS. TXONCCA_DONE is a pulse occurring when<br/>
a decision has been made as to whether the channel is busy or not and TXONCCA_FAILED indicates<br/>
if the radio went to TX or not after TXONCCA_DONE was asserted.<br/>
PKT_CFG2.CCA_MODE selects the mode to use when determining CCA.<br/>
When an STX or SFSTXON command strobe is given while CC120X is in the RX state, the TX or<br/>
FSTXON state is only entered if the clear channel requirements are fulfilled (CCA_STATUS is<br/>
asserted). Otherwise, the chip will remain in RX. If the channel then becomes available, the radio will<br/>
not enter TX or FSTXON state before a new strobe command is sent on the SPI interface15. This<br/>
feature is called TX on CCA/LBT. Five CCA requirements can be programmed:<br/>
15 If PKT_CFG2.CCA_MODE = 100b (LBT) the radio will try to enter TX mode again automatically<br/>
until the channel is clear and TX mode is being entered<br/>
SWRU346B Page 42 of 114CC120X<br/>
Always (CCA disabled, always goes to TX)<br/>
If RSSI is below threshold<br/>
Unless currently receiving a packet<br/>
Both the above (RSSI below threshold and not currently receiving a packet)<br/>
If RSSI is below threshold and ETSI LBT [2] requirements are met<br/>
6.12 Listen Before Talk (LBT)<br/>
ETSI EN 300 220-1 V2.3.1 [2] has specific requirements for LBT. To simplify compliance CC120X has<br/>
built in HW support to automate the LBT algorithm, including random back-offs. The requirements are<br/>
taken from the ETSI specifications, and a summary is shown below.<br/>
6.12.1 LBT Minimum Listening Time<br/>
“The minimum listening time is defined as the minimum time that the equipment listens for a received<br/>
signal at or above the LBT threshold level (…..) immediately prior to transmission to determine<br/>
whether the intended channel is available for use.<br/>
The listening time shall consist of the &quot;minimum fixed listening time&quot; and an additional pseudo random<br/>
part. If during the listening mode another user is detected on the intended channel, the listening time<br/>
shall commence from the instant that the intended channel is free again. Alternatively, the equipment<br/>
may select another channel and again start the listen time before transmission.”<br/>
Changing channel is not supported in HW and must be performed by the MCU.<br/>
6.12.2 Limit for Minimum Listening Time<br/>
“The total listen time, t , consists of a fixed part, t , and a pseudo random part, t , as the following:<br/>
L F PS<br/>
t = t + t<br/>
L F PS<br/>
a) The fixed part of the minimum listening time, t , shall be 5 ms.<br/>
F<br/>
b) The pseudo random listening time t shall be randomly varied between 0 ms and a value of 5<br/>
PS<br/>
ms or more in equal steps of approximately 0,5 ms as the following:<br/>
If the channel is free from traffic at the beginning of the listen time, t , and remains free<br/>
L<br/>
throughout the fixed part of the listen time, t , then the pseudo random part, t , is<br/>
F PS<br/>
automatically set to zero by the equipment itself.<br/>
If the channel is occupied by traffic when the equipment either starts to listen or during the<br/>
listen period, then the listen time commences from the instant that the intended channel is<br/>
free. In this situation the total listen time t shall comprise t and the pseudo random part,<br/>
L F<br/>
t .<br/>
PS<br/>
The limit for total listen time for the receiver consists of the sum of a) and b) together.”<br/>
If LBT is enabled (PKT_CFG2.CCA_MODE = 100 ) the CC120X will run the algorithm until successful<br/>
b<br/>
transmission.<br/>
6.13 Link Quality Indicator (LQI)<br/>
The Link Quality Indicator is a metric of the current quality of the received signal. If<br/>
PKT_CFG1.APPEND_STATUS is enabled, the value is automatically added to the last byte appended<br/>
after the payload. The value can also be read from the LQI_VAL register. The LQI gives an estimate<br/>
of how easily a received signal can be demodulated. LQI is best used as a relative measurement of<br/>
the link quality (a low value indicates a better link than what a high value does), since the value is<br/>
dependent on the modulation format.<br/>
SWRU346B Page 43 of 114CC120X<br/>
7 Transmit Configuration<br/>
7.1 PA Output Power Programming<br/>
PA power ramping is used to improve spectral efficiency of the system by reducing the out of band<br/>
signal energy created by abrupt changes in the output power. PA output power ramping is used when<br/>
starting/ending a transmission and is enabled by setting PA_CFG1.PA_RAMP_SHAPE_EN = 1. The<br/>
power ramping is very flexible and can be controlled by a configurable, piecewise linear function.<br/>
The RF output power level from the device is programmed with the PA_CFG1.PA_POWER_RAMP<br/>
register field. The power level resolution is 0.5 dB.<br/>
PA_POWER_RAMP 1<br/>
Output Power 18 [dBm]<br/>
2<br/>
Equation 21: Output Power16<br/>
Where 3 ≤ PA_POWER_RAMP ≤ 64<br/>
The shaped power ramping is controlled by the PA_CFG0 register. The shaped power ramp up curve<br/>
passes through two intermediate power levels from off-state to programmed output power level<br/>
(PA_CFG1.PA_POWER_RAMP). The intermediate power levels and total ramp time can be<br/>
configured. For the shaped ramp up the output power level is split into 16 sections (see Figure 17<br/>
where 1 equals the output power level). The two intermediate power levels are defined using these 16<br/>
sections. The first intermediate power level can be programmed within the power level range 0 - 7/16<br/>
through PA_CFG0.FIRST_IPL. The second intermediate power level can be programmed within<br/>
power range of 0.5 - 15/16 through PA_CFG0.SECOND_IPL. In Figure 17, FIRST_IPL = 011 and<br/>
b<br/>
SECOND_IPL = 110 .<br/>
b<br/>
Configurable ramping levels<br/>
1<br/>
●<br/>
●<br/>
● 8/16<br/>
●<br/>
●<br/>
● ● 0<br/>
0 1/3 2/3 1<br/>
Configurable: 3/8, 3/2, 3, 6 Ts<br/>
Figure 17: PA Power Ramping Control (configurable in the grey area)<br/>
The PA ramp up time (and ramp down time) is 3/ , 3/ , 3, or 6 symbols and is configured through<br/>
8 2<br/>
PA_CFG0.PA_RAMP_SHAPE.<br/>
16 This equation is an approximation. SmartRF Studio provides recommended values for different<br/>
output powers based on characterization.<br/>
SWRU346B Page 44 of 114CC120X<br/>
7.2 OOK/ASK Bit Shaping<br/>
When using OOK/ASK bit shaping is enabled by setting PA_CFG1.PA_RAMP_SHAPE_EN = 1 and<br/>
the the OOK/ASK shape length is 1/ , 1/ , 1/ , or 1/ symbols (configured through<br/>
32 16 8 4<br/>
PA_CFG0.PA_RAMP_SHAPE). The resolution of an ASK bit transition is given by<br/>
MDMCFG2.ASK_SHAPE. Figure 18 shown the shaping of an ASK bit when the shape length is 1/ and<br/>
8<br/>
the resolution is 8.<br/>
Amplitude<br/>
A<br/>
Max<br/>
PA_RAMP_SHAPE_EN = 0<br/>
A<br/>
Min<br/>
Time<br/>
1/8<br/>
A<br/>
Max<br/>
PA_RAMP_SHAPE_EN = 1<br/>
RAMP_SHAPE = 10<br/>
b<br/>
ASK_SHAPE = 0<br/>
A<br/>
Min<br/>
Time<br/>
Figure 18: OOK/ASK Bit Shaping Configuration<br/>
SWRU346B Page 45 of 114CC120X<br/>
8 Packet Handling Hardware Support<br/>
The CC120X has built-in hardware support for packet oriented radio protocols.<br/>
In transmit mode, the packet handler can be configured to add the following elements to the packet<br/>
stored in the TX FIFO:<br/>
A programmable number of preamble bytes<br/>
An 11, 16, 18, 24 or 32 bit synchronization word<br/>
A 2 byte CRC checksum computed over the data field.<br/>
Whitening of the data with a PN9 sequence<br/>
In receive mode, the packet handling support will de-construct the data packet by implementing the<br/>
following (if enabled):<br/>
Preamble detection<br/>
Sync word detection<br/>
CRC computation and CRC check<br/>
One byte address check<br/>
Packet length check (length byte checked against a programmable maximum length)<br/>
De-whitening<br/>
Optionally, two status bytes (see Table 23 and Table 24) with RSSI value, Link Quality Indication, and<br/>
CRC status can be appended in the RX FIFO by setting PKT_CFG1.APPEND_STATUS = 1.<br/>
Bit Field Name Description<br/>
7:0 RSSI RSSI value<br/>
Table 23: Received Packet Status Byte 1<br/>
(first byte appended after the data)<br/>
Bit Field Name Description<br/>
7 CRC_OK 1: CRC for received data OK<br/>
(or CRC disabled or TX mode)<br/>
0: CRC error in received data<br/>
6:0 LQI Indicating the link quality<br/>
Table 24: Received Packet Status Byte 2<br/>
(second byte appended after the data)<br/>
8.1 Standard Packet Format<br/>
The format of the data packet can be configured and consists of the following items (see Figure 19):<br/>
Preamble<br/>
Synchronization word<br/>
Optional length byte<br/>
Optional address byte<br/>
Payload<br/>
Optional 2 byte CRC<br/>
Preamble bits<br/>
SWRU346B Page 46 of 114<br/>
drow<br/>
cnyS<br/>
dleif<br/>
htgneL<br/>
dleif<br/>
sserddA Data field<br/>
61-CRC<br/>
Optional data whitening<br/>
Legend:<br/>
Optional CRC-16 calculation Inserted automatically in TX,<br/>
processed and removed in RX.<br/>
Optional user-provided fields processed in TX,<br/>
processed but not removed in RX.<br/>
Unprocessed user data (apart from<br/>
whitening)<br/>
max 32 8 8<br/>
8 x n bits 8 x n bits 16 bits<br/>
bits bits bits<br/>
Figure 19: Packet FormatCC120X<br/>
The preamble pattern is an alternating sequence of ones and zeros (1010∙∙/0101∙∙/<br/>
00110011∙∙/11001100∙∙) programmable through the PREAMBLE_CFG1.PREAMBLE_WORD register<br/>
field. The minimum length of the preamble is programmable through the<br/>
PREAMBLE_CFG1.NUM_PREAMBLE register field. When strobing TX, the modulator will start<br/>
transmitting a preamble. When the programmed number of preamble bytes has been transmitted, the<br/>
modulator will send the sync word and then data from the TX FIFO. If the TX FIFO is empty, the<br/>
modulator will continue to send preamble bytes until the first byte is written to the TX FIFO. The<br/>
modulator will then send the sync word and then the data bytes.<br/>
The sync word is set in the SYNC3/2/1/0 registers. The sync word provides byte synchronization of<br/>
the incoming packet. Non-supported sync word lengths can be emulated by using parts of the<br/>
preamble pattern in the SYNC registers.<br/>
CC120X supports both fixed packet length protocols and variable packet length protocols. Variable or<br/>
fixed packet length mode can be used for packets up to 255 bytes. For longer packets, infinite packet<br/>
length mode must be used. The packet length is defined as the payload data and the optional address<br/>
byte, excluding the optional length byte, the optional CRC, and the optional append status.<br/>
8.1.1 Fixed Packet Length<br/>
Fixed packet length mode is selected by setting PKT_CFG0.LENGTH_CONFIG = 00. The desired<br/>
packet length is set by the PKT_LEN register.<br/>
To support non-byte oriented protocols, fixed packet length mode supports packet lengths of n bytes<br/>
+ m bits, where n is programmed through the PKT_LEN register and m is programmed through<br/>
PKT_CFG0.PKT_BIT_LEN. If m ≠ 0, only m bits of the last byte written to the TX FIFO is transmitted<br/>
and RX mode is terminated when the last m bits of the packet is received. This is very useful in low<br/>
power systems where it is important not to stay in TX/RX longer than necessary. CRC is not<br/>
supported when PKT_CFG0.PKT_BIT_LEN ≠ 0. In RX, you will read zero’s from the (8 − m) LSBs in<br/>
the last byte in the RX FIFO.<br/>
Note: If PKT_LEN = 0x00 and PKT_CFG0.PKT_BIT_LEN ≠ 000 the packet length is between 1<br/>
and 7 bits long (given by the PKT_BIT_LEN register field). If PKT_LEN = 0x00 and<br/>
PKT_CFG0.PKT_BIT_LEN = 000 the packet length is 256 bytes.<br/>
8.1.2 Variable Packet Length<br/>
In variable packet length mode, PKT_CFG0.LENGTH_CONFIG = 01, the packet length is configured<br/>
by the first byte after the sync word. The packet length is defined as the payload data and optional<br/>
address field, excluding the length byte and the optional CRC. The PKT_LEN register is used to set<br/>
the maximum packet length allowed in RX. Any packet received with a length byte with a value<br/>
greater than PKT_LEN will be discarded.<br/>
By setting PKT_CFG0.LENGTH_CONFIG = 11 only the 5 LSB of the length byte is used for length<br/>
b<br/>
configuration while the 3 MSB are treated as normal data. Maximum packet length is hence 32 bytes.<br/>
The only difference from standard variable length mode is the masking of 3 MSB bits of the received<br/>
packet length byte, configured through LENGTH_CONFIG.<br/>
8.1.3 Infinite Packet Length<br/>
With PKT_CFG0.LENGTH_CONFIG = 10 , the packet length is set to infinite and transmission and<br/>
b<br/>
reception will continue until turned off manually. As described in the next section, this can be used to<br/>
support packet formats with different length configuration than natively supported by CC120X.<br/>
Note: The minimum packet length supported (excluding the optional length byte and CRC) is<br/>
one byte of payload data.<br/>
SWRU346B Page 47 of 114CC120X<br/>
8.1.4 Arbitrary Length Field Configuration<br/>
The packet length register, PKT_LEN, can be reprogrammed during receive and transmit (this is also<br/>
the case for the PKT_BIT_LEN register field in the PKT_CFG0 register). In combination with fixed<br/>
packet length mode (PKT_CFG0.LENGTH_CONFIG = 0) this opens the possibility to have a different<br/>
length field configuration than supported for variable length packets (in variable packet length mode<br/>
the length byte is the first byte after the sync word). At the start of reception, the packet length is set<br/>
to a large value. The MCU reads out enough bytes to interpret the length field in the packet. Then the<br/>
PKT_LEN value is set according to this value. The end of packet will occur when the byte counter in<br/>
the packet handler is equal to the PKT_LEN register. Thus, the MCU must be able to program the<br/>
correct length before the internal counter reaches the packet length.<br/>
8.1.5 Packet Length &gt; 255<br/>
PKT_CFG0.LENGTH_CONFIG can also be reprogrammed during TX and RX. This opens the<br/>
possibility to transmit and receive packets that are longer than 256 bytes and still be able to use the<br/>
packet handling hardware support. At the start of the packet, the infinite packet length mode<br/>
(PKT_CFG0.LENGTH_CONFIG = 10 ) must be active. On the TX side, the PKT_LEN register is set<br/>
b<br/>
to mod(length, 256). On the RX side the MCU reads out enough bytes to interpret the length field in<br/>
the packet and sets the PKT_LEN register to mod(length, 256)17. When less than 256 bytes remains<br/>
of the packet, the MCU disables infinite packet length mode and activates fixed packet length mode<br/>
(PKT_CFG0.LENGTH_CONFIG = 0). When the internal byte counter reaches the PKT_LEN value,<br/>
the transmission or reception ends (the radio enters the state determined by<br/>
RFEND_CFG0.TXOFF_MODE or RFEND_CFG1.RXOFF_MODE). Automatic CRC appending/checking<br/>
can also be used (by setting PKT_CFG1.CRC_CFG ≠ 0).<br/>
When for example a 600-byte packet is to be transmitted, the MCU should do the following.<br/>
Set PKT_CFG0.LENGTH_CONFIG = 2<br/>
Pre-program the PKT_LEN register to mod(600, 256) = 88<br/>
Transmit at least 345 bytes (600 − 255), for example by filling the 128-byte TX FIFO three times<br/>
(384 bytes transmitted)<br/>
Set PKT_CFG0.LENGTH_CONFIG = 0<br/>
The transmission ends when the packet counter reaches 88. A total of 600 bytes are<br/>
transmitted.<br/>
Internal byte counter in packet handler counts from 0 to 255 and then starts from 0 again<br/>
0 , 1 , .......... , 88 , .................... 255 , 0 , ........ , 88 , .................. , 255 , 0 , ........ , 88 , .................. , 255 , 0 , .......................<br/>
600 bytes transmitted or received<br/>
Infinite packet length enabled Fixed packet length<br/>
enabled when less than 256<br/>
bytes remains of the packet<br/>
Length field transmitted and received. RX and TX PKT_LEN value set to mod(600, 256) = 88)<br/>
Figure 20: Packet Length &gt; 255<br/>
17 Given two positive numbers, a dividend x and a divisor y, mod(x, y) can be thought of as the<br/>
remainder when dividing x by y. For instance, the expression mod(5, 4) would evaluate to 1 because<br/>
5 divided by 4 leaves a remainder of 1<br/>
SWRU346B Page 48 of 114CC120X<br/>
8.1.6 Data Whitening<br/>
From a radio perspective, the ideal over the air data are random and DC free. This results in the<br/>
smoothest power distribution over the occupied bandwidth. This also gives the regulation loops in the<br/>
receiver uniform operation conditions (no data dependencies).<br/>
Real data often contain long sequences of zeros and ones making it difficult to track the data bits. In<br/>
these cases, performance can be improved by whitening the data before transmitting, and de-<br/>
whitening the data in the receiver.<br/>
With CC120X, this can be done automatically. By setting PKT_CFG1.WHITE_DATA = 1, all data,<br/>
except the preamble and the sync word will be XORed with a 9-bit pseudo-random (PN9) sequence<br/>
before being transmitted. This is shown in Figure 21. At the receiver end, the data are XORed with the<br/>
same pseudo-random sequence. In this way, the whitening is reversed, and the original data appear<br/>
in the receiver. The PN9 sequence is initialized to all 1’s. By setting PKT_CFG1.PN9_SWAP_EN = 1,<br/>
the PN9 sequence can be swapped before whitening/de-whitening. This can only be done when the<br/>
radio is using standard packet mode (PKT_CFG2.FG_MODE_EN = 0).<br/>
If CC120X is set up to transmit random data, the PN9 whitening sequence will be transmitted<br/>
(see Table 25).<br/>
8 7 6 5 4 3 2 1 0<br/>
TX_DATA 7 6 5 4 3 2 1 0<br/>
The first TX_DATA byte is shifted in before doing the XOR-operation providing the first TX_OUT[7:0] byte. The<br/>
second TX_DATA byte is then shifted in before doing the XOR-operation providing the second TX_OUT[7:0] byte.<br/>
TX_OUT[7:0]<br/>
Figure 21: Data Whitening in TX Mode<br/>
Assume the following bytes should be transmitted: 0xAB, 0x80, 0xFF, 0x00<br/>
The first byte is XORed with 0xFF (initial value)<br/>
0xAB ⊕ 0xFF = 0x54<br/>
Table 25 shows how the bit shifting and XORing of bit 5 and bit 0 gives the bytes that the remaining<br/>
bytes in the packet should be XORed with.<br/>
SWRU346B Page 49 of 114CC120X<br/>
8 (5 ⊕ 0) 7 6 5 4 3 2 1 0<br/>
1 1 1 1 1 1 1 1 1<br/>
0 1 1 1 1 1 1 1 1<br/>
0 0 1 1 1 1 1 1 1<br/>
0 0 0 1 1 1 1 1 1<br/>
0 0 0 0 1 1 1 1 1<br/>
1 0 0 0 0 1 1 1 1<br/>
1 1 0 0 0 0 1 1 1<br/>
1 1 1 0 0 0 0 1 1<br/>
1 1 1 1 0 0 0 0 1<br/>
0 1 1 1 1 0 0 0 0<br/>
1 0 1 1 1 1 0 0 0<br/>
1 1 0 1 1 1 1 0 0<br/>
1 1 1 0 1 1 1 1 0<br/>
0 1 1 1 0 1 1 1 1<br/>
0 0 1 1 1 0 1 1 1<br/>
0 0 0 1 1 1 0 1 1<br/>
0 0 0 0 1 1 1 0 1<br/>
1 0 0 0 0 1 1 1 0<br/>
0 1 0 0 0 0 1 1 1<br/>
1 0 1 0 0 0 0 1 1<br/>
1 1 0 1 0 0 0 0 1<br/>
0 1 1 0 1 0 0 0 0<br/>
0 0 1 1 0 1 0 0 0<br/>
1 0 0 1 1 0 1 0 0<br/>
1 1 0 0 1 1 0 1 0<br/>
Table 25: PN9 Whitening Sequence<br/>
0x80 ⊕ 0xE1 = 0x61<br/>
0xFF ⊕ 0x1D = 0xE2<br/>
0x00 ⊕ 0x9A = 0x9A<br/>
.<br/>
.<br/>
.<br/>
The complete packet will look like this (assume default preamble, sync word, and CRC configuration):<br/>
0xAA, 0xAA, 0xAA, 0xAA, 0x93, 0x0B, 0x51, 0xDE, 0x54, 0x61, 0xE2, 0x9A, 0xF9, 0x9D<br/>
8.1.7 Data Byte Swap<br/>
If the PKT_CFG2.BYTE_SWAP_EN register field is set than the bits in each byte are swapped,<br/>
meaning that bit 0 becomes bit 7, bit 1 becomes bit 6 etc. until bit 7 becomes bit 0.<br/>
In TX mode all bytes in the TX FIFO are swapped before optional CRC calculation and whitening are<br/>
performed.<br/>
In RX mode the data byte is swapped after all the processing is done, meaning that de-whitening and<br/>
CRC calculation are done on the original received data, and the swapping is done right before the<br/>
actual writing to the RX FIFO. This means that if using address filtering (see Section 8.2.1) is used<br/>
when PKT_CFG2.BYTE_SWAP_EN, the user should swap the address manually in the DEV_ADDR<br/>
register in order to match the received address due to the fact that the packet engine compares the<br/>
address register to the received address before the swapping is done.<br/>
Figure 22 shows the data sent over the air vs. the data written to the TX FIFO when byte swap is<br/>
enabled (assume that whitening and CRC calculation are disabled). If the receiver uses address<br/>
filtering, the address should be programmed to be 0xEA.<br/>
SWRU346B Page 50 of 114CC120X<br/>
Data written to TX FIFO<br/>
0x03 0x57 0x26 0xB2<br/>
0 0 0 0 0 0 1 1 0 1 0 1 0 1 1 1 0 0 1 0 0 1 1 0 1 0 1 1 0 0 1 0<br/>
Data sent on the air<br/>
0xC0 0xEA 0x64 0x4D<br/>
1 1 0 0 0 0 0 0 1 1 1 0 1 0 1 0 0 1 1 0 0 1 0 0 0 1 0 0 1 1 0 1<br/>
Figure 22: Data Byte Swap<br/>
8.1.8 UART Mode<br/>
If UART mode is enabled (PKT_CFG0.UART_MODE_EN = 1), the packet engine inserts and removes<br/>
start/stop bits automatically. In this mode the packet engine will emulate UART back-to-back<br/>
transmissions typically done over an asynchronous RF interface, to enable communication with<br/>
simple RF devices without packet support.<br/>
The start and stop bits are not handled as data, only inserted/removed in the data stream to/from the<br/>
modem, hence all packet features are available in this mode. The value of the start/stop bits is<br/>
configurable through the PKT_CFG0.UART_SWAP_EN register field.<br/>
If whitening is enabled, only the data bits are affected, not the start/stop bits.<br/>
A &quot;framing error&quot; occurs in RX mode when the designated &quot;start&quot; and &quot;stop&quot; bits are not received as<br/>
expected. As the &quot;start&quot; bit is used to identify the beginning of an incoming byte it acts as a reference<br/>
for the remaining bits. If the &quot;start&quot; and &quot;stop&quot; bits are not in their expected value, it means that the<br/>
data is not in line and a framing error will occur (the UART_FRAMING_ERROR signal will be asserted).<br/>
Framing errors will not stop the on-going reception.<br/>
SWRU346B Page 51 of 114CC120X<br/>
8.2 Packet Filtering in Receive Mode<br/>
CC120X supports three different types of packet-filtering; address filtering, maximum length filtering,<br/>
and CRC filtering.<br/>
8.2.1 Address Filtering<br/>
Setting PKT_CFG1.ADDR_CHECK_CFG to any other value than zero enables the address filtering<br/>
where the packet handler engine will compare the address field in the packet (see Figure 19) with the<br/>
programmed node address in the DEV_ADDR register. If PKT_CFG1.ADDR_CHECK_CFG = 10 it will<br/>
b<br/>
in addition check against the 0x00 broadcast address, or both the 0x00 and 0xFF broadcast<br/>
addresses when PKT_CFG1.ADDR_CHECK_CFG = 11 . If the received address matches a valid<br/>
b<br/>
address, the packet is received and written into the RX FIFO. If the address match fails, the packet is<br/>
discarded and the radio controller will either restart RX or go to IDLE dependent on the<br/>
RFEND_CFG0.TERM_ON_BAD_PACKET_EN setting (the RFEND_CFG1.RXOFF_MODE setting is<br/>
ignored18).<br/>
8.2.2 Maximum Length Filtering<br/>
In variable packet length mode, PKT_CFG0.LENGTH_CONFIG = 01, the PKT_LEN register value is<br/>
used to set the maximum allowed packet length. If the received length byte has a larger value than<br/>
this, the packet is discarded and the radio controller will either restart RX or go to IDLE dependent on<br/>
the RFEND_CFG0.TERM_ON_BAD_PACKET_EN setting (the RFEND_CFG1.RXOFF_MODE setting is<br/>
ignored).<br/>
8.2.3 CRC Filtering<br/>
The filtering of a packet when CRC check fails is enabled by setting<br/>
FIFO_CFG.CRC_AUTOFLUSH = 1. The CRC auto flush function will only flush the packet received<br/>
with bad CRC, other packets will remain unchanged in the RX FIFO. After auto flushing the faulty<br/>
packet, the radio controller will either restart RX or go to IDLE dependent on the<br/>
RFEND_CFG0.TERM_ON_BAD_PACKET_EN setting (the RFEND_CFG1.RXOFF_MODE setting is<br/>
ignored).<br/>
When using the auto flush function, the maximum packet length is 127 bytes in variable packet length<br/>
mode and 128 bytes in fixed packet length mode. Note that when PKT_CFG1.APPEND_STATUS is<br/>
enabled, the maximum allowed packet length is reduced by two bytes in order to make room in the<br/>
RX FIFO for the two status bytes appended at the end of the packet. The MCU must not read from<br/>
the current packet until the CRC has been checked as OK.<br/>
RX FIFO is 1st packet 2nd packet 3rd packet 4th packet<br/>
empty CRC OK CRC OK CRC Error CRC OK<br/>
0 RXLAST 0 0 0 0<br/>
1 1 1 1 1<br/>
2 2 2 2 2<br/>
3 3 3 3 3<br/>
4 4 4 4 4<br/>
5 5 RXLAST 5 5 5<br/>
6 6 6 6 6<br/>
7 7 7 7 7<br/>
8 8 8 8 8<br/>
9 9 9 9 9<br/>
10 10 10 RXLAST 10 RXLAST 10<br/>
11 11 11 11 11<br/>
12 12 12 12 CRC Error 12<br/>
13 13 13 13 13<br/>
14 14 14 14 14<br/>
15 15 15 15 RXLAST 15 RXLAST<br/>
16 16 16 16 16<br/>
17 17 17 17 17<br/>
. . . . .<br/>
. . . . .<br/>
. . . . .<br/>
124 124 124 124 124<br/>
125 125 125 125 125<br/>
126 126 126 126 126<br/>
127 127 127 127 127<br/>
Figure 23: CRC Autoflush of Faulty Packet<br/>
18 RFEND_CFG1.RXOFF_MODE can be changed while in active mode<br/>
SWRU346B Page 52 of 114CC120X<br/>
8.2.4 Auto Acknowledge<br/>
By configuring the radio to enter TX after a packet has been received (RFEND_CFG1.RXOFF_MODE =<br/>
TX) and enabling termination on bad packets (RFEND_CFG0.TERM_ON_BAD_PACKET_EN = 1)<br/>
automatic acknowledgement of packets can be achieved. The Ack. packet should be written to the TX<br/>
FIFO before RX mode is being entered. With the settings described above, receiving a bad packet<br/>
(error in address, length, or CRC) will have the radio enter IDLE state while receiving a good packet<br/>
will cause the radio to enter TX state and transmit the packet residing in the TX FIFO.<br/>
8.3 Packet Handling in Transmit Mode<br/>
The payload that is to be transmitted must be written into the TX FIFO. The first byte written must be<br/>
the length byte when variable packet length is enabled (PKT_CFG0.LENGTH_CONFIG = 1). The<br/>
length byte has a value equal to the payload of the packet (including the optional address byte). If<br/>
address recognition is enabled in the receiver (PKT_CFG1.ADDR_CHECK_CFG ≠ 0) the second byte<br/>
written to the TX FIFO must be the address byte (as the address in not automatically inserted).<br/>
If fixed packet length is enabled (PKT_CFG0.LENGTH_CONFIG = 0), the first byte written to the TX<br/>
FIFO should be the address (assuming the receiver uses address recognition).<br/>
The modulator will first send the programmed number of preamble bytes configured through the<br/>
PREAMBLE_CFG1.NUM_PREAMBLE register field. If data is available in the<br/>
TX FIFO, the modulator will send the sync word (programmed through SYNC_CFG1.SYNC_MODE and<br/>
SYNC3/2/1/0) followed by the payload in the TX FIFO. If CRC is enabled<br/>
(PKT_CFG1.CRC_CFG ≠ 0), the checksum is calculated over all the data pulled from the TX FIFO,<br/>
and the result is sent as two extra bytes following the payload data. If the TX FIFO runs empty before<br/>
the complete packet has been transmitted, the radio will enter TX_FIFO_ERR state. The only way to<br/>
exit this state is by issuing an SFTX strobe. Writing to the TX FIFO after it has underflowed will not<br/>
restart TX mode.<br/>
If whitening is enabled, everything following the sync words will be whitened. Whitening is enabled by<br/>
setting PKT_CFG1.WHITE_DATA = 1. For more details on whitening, please see Section 8.1.6.<br/>
8.4 Packet Handling in Receive Mode<br/>
In receive mode, the radio will search for a valid sync word (if SYNC_CFG1.SYNC_MODE ≠ 0) and<br/>
when found, the demodulator has obtained both bit and byte synchronization and will receive the first<br/>
payload byte. For more details on byte synchronization/sync word detection, please see Section 6.7<br/>
If whitening is enabled (PKT_CFG1.WHITE_DATA = 1), the data will be de-whitened at this stage.<br/>
When variable packet length mode is enabled (PKT_CFG0.LENGTH_CONFIG = 1), the first byte is<br/>
the length byte. The packet handler stores this value as the packet length and receives the number of<br/>
bytes indicated by the length byte. If fixed packet length mode is used<br/>
(PKT_CFG0.LENGTH_CONFIG = 0), the packet handler will accept the number of bytes programmed<br/>
through the PKT_LEN.PACKET_LENGHT register field.<br/>
Next, the packet handler optionally checks the address (if PKT_CFG1.ADDR_CHECK_CFG ≠ 0) and<br/>
only continues the reception if the address matches. If automatic CRC check is enabled<br/>
(PKT_CFG1.CRC_CFG ≠ 0), the packet handler computes CRC and matches it with the appended<br/>
CRC checksum.<br/>
At the end of the payload, the packet handler will optionally write two extra packet status bytes (see<br/>
Table 23 and Table 24) that contain CRC status, LQI, and RSSI value if<br/>
PKT_CFG1.APPEND_STATUS = 1.<br/>
8.5 Packet Handling in Firmware<br/>
When implementing a packet oriented radio protocol in firmware, the MCU needs to know when a<br/>
packet has been received/transmitted. Additionally, for packets longer than 128 bytes, the RX FIFO<br/>
needs to be read while in RX and the TX FIFO needs to be refilled while in TX. This means that the<br/>
MCU needs to know the number of bytes that can be read from or written to the RX FIFO and TX<br/>
FIFO respectively. There are two possible solutions to get the necessary status information:<br/>
SWRU346B Page 53 of 114CC120X<br/>
a) Interrupt Driven Solution<br/>
The GPIO pins can be used in both RX and TX to give an interrupt when a sync word has been<br/>
received/transmitted or when a complete packet has been received/transmitted by setting<br/>
IOCFGx.GPIOx_CFG = PKT_SYNC_RXTX (6). In addition, there are four configurations for the<br/>
IOCFGx.GPIOx_CFG register that can be used as an interrupt source to provide information on how<br/>
many bytes are in the RX FIFO and TX FIFO respectively (see 8.6 for more details).<br/>
b) SPI Polling<br/>
The GPIO_STATUS register can be polled at a given rate to get information about the current GPIO<br/>
values. The NUM_RXBYTES and NUM_TXBYTES registers can be polled at a given rate to get<br/>
information about the number of bytes in the RX FIFO and TX FIFO respectively. It is also possible to<br/>
use FIFO_NUM_RXBYTES.FIFO_RXBYTES and FIFO_NUM_TXBYTES.FIFO_TXBYTES. These<br/>
register fields give the number of bytes available in the RX FIFO and free bytes in the TX FIFO, and<br/>
both register values saturates at 15.<br/>
8.6 TX FIFO and RX FIFO<br/>
The CC120X contains two 128 byte FIFOs, one for received data and one for transmit data. The SPI<br/>
interface is used to read from the RX FIFO and write to the TX FIFO. Section 3.2.4 contains details on<br/>
the SPI FIFO access. The FIFO controller will detect under/overflow in both the RX FIFO<br/>
and the TX FIFO.<br/>
A signal will assert when the number of bytes in the FIFO is equal to or higher than a programmable<br/>
threshold. This signal can be viewed on the GPIO pins and can be used for interrupt driven FIFO<br/>
routines to avoid polling the NUM_RXBYTES and NUM_TXBYTES registers. The IOCFGx.GPIOx_CFG<br/>
= RXFIFO_THR (0) and the IOCFGx.GPIOx_CFG = RXFIFO_THR_PKT (1) configurations are<br/>
associated with the RX FIFO while the IOCFGx.GPIOx_CFG = TXFIFO_THR (2) and the<br/>
IOCFGx.GPIOx_CFG = TXFIFO_THR_PKT (3) configurations are associated with the TX FIFO.<br/>
The 7-bit FIFO_CFG.FIFO_THR setting is used to program threshold points. Table 26 lists the<br/>
FIFO_THR settings and the corresponding thresholds for the RX and TX FIFO. The threshold value is<br/>
coded in opposite directions for the two FIFOs to give equal margin to the overflow and underflow<br/>
conditions when the threshold is reached.<br/>
FIFO_THR Bytes in TX FIFO Bytes in RX FIFO<br/>
0 127 1<br/>
1 126 2<br/>
2 125 3<br/>
... ... ...<br/>
126 1 127<br/>
127 0 128<br/>
Table 26: FIFO_THR Settings and the Corresponding FIFO Thresholds<br/>
To simplify debug and advanced FIFO features, the full FIFO buffer is memory mapped and can be<br/>
accessed directly(see Section 3.2.3). Both FIFO content and FIFO data pointers are accessible. This<br/>
can be used to significantly reduce the SPI traffic, see examples below<br/>
1. In a hostile RF environment packets are lost and re-transmissions are often required. Normally<br/>
the packet data must then be written again over the SPI interface. By using the direct FIFO<br/>
access feature and changing the TXFIRST register to point to the head of the previous<br/>
message, a re-transmission can be done without writing the packet over the SPI.<br/>
2. In many protocols only parts of the message is changed between each transmission (e.g.<br/>
changing a read value from a sensor, incrementing a transmission counter). Direct FIFO<br/>
access can then be used to change only the new data (the FIFOs are reached through the<br/>
0x3E command, see Table 4), leaving the rest of the data unchanged. FIFO data pointers<br/>
(TXFIRST and TXLAST) can then be manipulated to re-transmit the packet with changed data.<br/>
SWRU346B Page 54 of 114CC120X<br/>
8.7 IEEE 802.15.4g Support<br/>
802.15.4g hardware support is enabled by setting PKT_CFG2.FG_MODE_EN = 1. This will override<br/>
all other packet configurations. The only register fields that will be recognized are<br/>
PKT_CFG1.CRC_CFG, PKT_CFG1.APPEND_STATUS and PKT_CFG2.BYTE_SWAP_EN. To be<br/>
compliant to the 802.15.4g standard PKT_CFG2.BYTE_SWAP_EN must be set to 0.<br/>
8.7.1 802.15.4g Packet Format<br/>
The format of the 802.15.4g packet format supported by the radio can be seen in Figure 24.<br/>
Preamble bits<br/>
(Programmable)<br/>
SWRU346B Page 55 of 114<br/>
emarF<br/>
tratS<br/>
retimileD<br/>
dleif<br/>
ARHP<br/>
dleif<br/>
BRHP Data field<br/>
23-CRC<br/>
ro<br/>
61CRC<br/>
Optional data whitening<br/>
Legend:<br/>
CRC calculation Inserted automatically in TX,<br/>
processed and removed in RX.<br/>
Unprocessed user data (Except for<br/>
whitening)<br/>
8 8 32 or 16<br/>
8 x 4 bits 2 x 16 bits<br/>
bits bits<br/>
8 x n bits<br/>
bits<br/>
Figure 24: 802.15.4g Packet Format<br/>
PHRA and PHRB in Figure 24 corresponds to PHR[15:8] and PHR[7:0] in the 802.15.4g standard [3]<br/>
(see Figure 25 and Figure 26). The radio supports normal 802.15.4g packets (i.e. packets without MS<br/>
(Mode Switch)). MS packets must be handled by software.<br/>
PHRA[7] PHRA[6:5] PHRA[4] PHRA[3] PHRA[2:0]: PHRB[7:0]<br/>
PHR[15] PHR[14:13] PHR[12] PHR[11] PHR[10:0]<br/>
Bit String Index 0 1 - 2 3 4 5 - 15<br/>
Bit Mapping MS R - R FCS DW L - L<br/>
1 0 10 0<br/>
Field Name Mode switch Reserved FCS type Data whitening Frame length<br/>
Figure 25: Format of PHR without Mode Switch<br/>
PHRA[7] PHRA[6:5] PHRA[4] PHRA[3:0]: PHRB[7:5] PHRB[4:1] PHRB[0]<br/>
PHR[15] PHR[14:13] PHR[12] PHR[11:5] PHR[4:1] PHR[0]<br/>
Bit String Index 0 1 - 2 3 4 - 10 11 - 14 15<br/>
Bit Mapping MS M - M FEC - B - B PC<br/>
1 0 3 0<br/>
Field Name Mode Mode switch New mode New mode Checksum Parity<br/>
switch parameter FEC check<br/>
entry<br/>
Figure 26: Format of PHR with Mode SwitchCC120X<br/>
8.7.2 802.15.4g Packet Control<br/>
The radio will support TX and RX with normal 802.15.4g packets (i.e. non Mode Switch packets). All<br/>
handling of Mode Switch packets must be entirely done in SW.<br/>
8.7.2.1 802.15.4g TX Packets<br/>
When transmitting an 802.15.4g packet the format must comply with the format shown in Figure 24. It<br/>
is up to the application to write a correct PHR bytes and payload to the TXFIFO. The radio will check<br/>
for Mode Switch (MS) and that the frame length is within the specifications before transmitting the<br/>
packet. If MS is not set and the frame length complies with the standard the radio will check the Data<br/>
Whitening (DW) bit field and the Frame Check Sequence (FCS) bit field and apply whitening and FCS<br/>
according to the bit fields. The transmission flow is outlined in Figure 27.<br/>
802.15.4g mode and STX<br/>
ModeSwitch(MS)?<br/>
No<br/>
Yes<br/>
Framelength<br/>
valid ?<br/>
Yes No<br/>
Send packet<br/>
Send packet with Abort transmission<br/>
without<br/>
CRC16/CRC32 No error code<br/>
CRC16/CRC32<br/>
Assert done<br/>
Figure 27: Transmission Flow in 802.15.4g Mode<br/>
SWRU346B Page 56 of 114CC120X<br/>
8.7.2.2 802.15.4g RX Packets<br/>
The radio supports reception of normal (non Mode Switch) 802.15.4g packets. If the MS bit is not set<br/>
and the frame length is valid, the radio will receive the rest of the payload according to the PHR<br/>
configuration. If a Mode Switch packet is received or the frame length field is not valid, the radio will<br/>
abort RX and the Mode Switch frame (PHR bytes) will be available in the RXFIFO. RSSI for Mode<br/>
Switch packets is not available. Figure 28 outlines the reception flow for an 802.15.4g packet.<br/>
802.15.4g mode and SRX<br/>
Receive PHR<br/>
ModeSwitch(MS)<br/>
Yes or No<br/>
Illegal framelength?<br/>
Abort reception Continue PHR-configured<br/>
assert pkt_length_failed reception<br/>
Assert done with appropiate status<br/>
HW<br/>
Successful<br/>
SW(abstraction routine)<br/>
reception<br/>
Yes Marc_status=0x80 No (MS should be performed in parallell)<br/>
MS part of<br/>
Yes<br/>
system?<br/>
Successful 15.4g<br/>
packet SW: Run BCH(15,11)<br/>
No<br/>
and parity check on<br/>
PHR to check for<br/>
MS-packet<br/>
Successful<br/>
15.4g packet has<br/>
15.4g MS Yes MS packet No<br/>
failed<br/>
packet<br/>
Return to MAC layer<br/>
Figure 28: 802.15.4g Packet Reception<br/>
SWRU346B Page 57 of 114CC120X<br/>
8.7.3 802.15.4g Append Status<br/>
If the PKT_CFG1.APPEND_STATUS bit is set, two status bytes containing information on CRC, LQI<br/>
and RSSI will be written to the RXFIFO.<br/>
Bit Field Name Description<br/>
7:0 RSSI RSSI value<br/>
Table 27. Received Packet Status Byte 1<br/>
(first byte appended after the data)<br/>
Bit Field Name Description<br/>
7 CRC_OK 1: CRC32 OK if FCS type = 0 and CRC32 is OK<br/>
1: CRC16 OK if FCS type = 1 and CRC16 is OK<br/>
0: CRC error in received data<br/>
6:0 LQI Indicating the link quality<br/>
Table 28: Received Packet Status Byte 2<br/>
(second byte appended after the data)<br/>
8.7.4 802.15.4g Data Byte - Bit Swapping<br/>
If the PKT_CFG1.BYTE_SWAP_EN register field is set than the bits in each byte are swapped,<br/>
meaning that bit 0 become 7, bit 1 become bit 6 etc. until bit 7 becomes bit 0.<br/>
In TX mode all bytes in the TX FIFO are swapped before optional CRC calculation and whitening are<br/>
performed.<br/>
In RX mode the data byte is swapped after all the processing is done, meaning that de-whitening and<br/>
CRC calculation are done on the original received data, and the swapping is done right before the<br/>
actual writing to the RX FIFO.<br/>
Bit swapping should be turned off to be compliant with the 802.15.4g standard.<br/>
8.7.5 802.15.4g Data Whitening<br/>
Data whitening of the payload is defined by the Data Whitening field (DW) in the PHR. If this bit is set<br/>
all data except the preamble, SFD and PHR field will be XOR-ed with a 9-bit pseudo-random (PN9)<br/>
sequence before being transmitted. At the receiver the DV bit of the PHR is read and the data is<br/>
XOR-ed with the same pseudo-random sequence to de-white the data back to its original form.<br/>
The PN9 generator is defined as seen in Figure 29. The seed in the PN9 generator is set to all 1’s<br/>
and is reinitialized after each packet.<br/>
D D D D D D D D D<br/>
PN9<br/>
Figure 29: PN9 Generator<br/>
SWRU346B Page 58 of 114CC120X<br/>
8.8 802.15.4g Frame Check Sequence (FCS)<br/>
The radio supports both a 16-bit CRC and a 32-bit CRC for the Frame Check Sequence (FCS). The<br/>
type to be used is defined by the FCS field in the PHR bytes. The length of the FCS must be added to<br/>
Frame Length of the PHR in order to have a valid 802.15.4g packet. It is the applications<br/>
responsibility that PHR fields are correct. Table 29 shows the relationship between the FCS Type field<br/>
and the transmitted CRC bytes.<br/>
FCS Type Field Value Transmitted FCS Length<br/>
0 4 byte<br/>
1 2 byte<br/>
Table 29: Transmitted FCS Length<br/>
8.8.1 802.15.4g Forward Error Correction (FEC)<br/>
A Non Recursive and Non Systematic Code (NRNSC) encoder is implemented to support FEC for<br/>
802.15.4g. FEC is optional for 802.15.4g and is indicated by the synchronization word used for the<br/>
packet.<br/>
In addition to set PKT_CFG2.FG_MODE_EN = 1, the following register fields must be set to enable<br/>
802.15.4g FEC support:<br/>
PKT_CFG1.FEC_EN = 1<br/>
SYNC_CFG1.SYNC_MODE = 7 (DualSync Search)<br/>
When receiving an 802.15.4g packet the receiver will check the sync word received and if it matches<br/>
the sync word contained in the two high bytes fields in the sync word registers (SYNC3 and SYNC2) it<br/>
will assume that the packet is FEC encoded.<br/>
When transmitting a FEC encoded 802.15.4g packet it is important to have the FEC defined sync<br/>
word written to the SYNC1 and SYNC0 register field as the CC120X will always send the sync word<br/>
contained in the lower end of the sync word registers when SYNC_CFG1.SYNC_MODE = 7.<br/>
8.9 Transparent and Synchronous Serial Operation<br/>
Several features and modes of operation have been included in the CC120X to provide backward<br/>
compatibility with legacy systems that cannot be supported by the built in packet handling<br/>
functionality. For new systems, it is recommended to use the built-in packet handling features, as they<br/>
give more robust communication, significantly offload the microcontroller, and simplify software<br/>
development. There are two serial modes and they are described in the two following sections.<br/>
Serial mode is only supported for 2’ary modulations. The exception in synchronous serial mode (RX)<br/>
which also supports 4’ary modulation formats. Figure 30 shows SERIAL_CLK and SERIAL_RX for the<br/>
data 0xAA for both 2-FSK and 4-FSK. The symbol rate is the same in both cases.<br/>
2-FSK<br/>
SERIAL_RX<br/>
SERIAL_CLK<br/>
1 0 1 0 1 0 1 0<br/>
2t<br/>
4-FSK<br/>
SERIAL_RX<br/>
SERIAL_CLK<br/>
1 0 1 0 1 0 1 0<br/>
t<br/>
Time<br/>
Figure 30: 2’ary vs. 4’ary Modulation Format in Serial Mode<br/>
SWRU346B Page 59 of 114CC120X<br/>
8.9.1 Synchronous Serial Mode<br/>
In the synchronous serial mode, data is transferred on a two-wire serial interface. The CC120X<br/>
provides a clock (IOCFGx.GPIOx_CFG = SERIAL_CLK (8)) that is used to set up new data on the<br/>
data input line or sample data on the data output line. Data timing recovery is done automatically. The<br/>
data pin is updated on the falling edge of the clock pin at the programmed symbol rate. Sync word<br/>
insertion/detection may or may not be active, depending on the sync mode. If sync word detection is<br/>
enabled (SYNC_CFG1.SYNC_MODE ≠ 0) the serial clock (SERIAL_CLK) will not be output on the<br/>
GPIO before a sync word is transmitted/received. When SYNC_MODE = 0 (blind mode) it is<br/>
recommended to transmit a minimum of 4 bytes preamble.<br/>
Define a GPIO pin to be serial data clock for both TX and RX operation. For RX operation, another<br/>
GPIO pin has to be defined as serial data output (IOCFGx.GPIOx_CFG = SERIAL_RX (9)).<br/>
For TX operation, the GPIO0 pin is explicitly used as serial data input. This is automatically done<br/>
when in TX. In order to avoid internal I/O conflict, GPIO0 should be defined as tri-state. GPIO0 will be<br/>
automatically tri-stated in TX if the GPIO0 is defined as serial clock or serial data output<br/>
(IOCFG0.GPIO0_CFG = 8 or 9). If this is not the case, GPIO0 must be manually tri-stated by<br/>
setting IOCFG0.GPIO0_CFG = HIGHZ (48).<br/>
In synchronous serial mode the TX data must be set up on the falling edge of the data clock output<br/>
from CC120X.<br/>
In addition to set PKT_CFG2.PKT_FORMAT = 1, the following register fields must be set:<br/>
MDMCFG1.FIFO_EN = 0<br/>
MDMCFG0.TRANSPARENT_MODE_EN = 0<br/>
IOCFGx.GPIOx_CFG = 001001 (SERIAL_RX. Only necessary for RX mode)<br/>
b<br/>
IOCFGx.GPIOx_CFG = 001000 (SERIAL_CLK)<br/>
b<br/>
SERIAL_STATUS.IOC_SYNC_PINS_EN = 1 (Only necessary for TX mode19)<br/>
PREAMBLE_CFG1.NUM_PREAMBLE = 0<br/>
Synchronous serial mode is often used in applications needing to be backward compatible, and sync<br/>
detection is disabled (SYNC_CFG1.SYNC_MODE = 0) since the format of the sync word often do not<br/>
match the supported sync word format. Best radio performance is however achieved when<br/>
SYNC_MODE ≠ 0. In cases where the packet has a preamble but not a sync word that matches the<br/>
sync format supported by the CC120X, the radio can simply use the preamble as a sync word.<br/>
Consider the case where a receiver wants to receive packets with 3 different addresses but no<br/>
common sync word:<br/>
Packet 1: 0xAA, 0xAA, 0xAA, 0xAA, Address1, Data0, Data 1, Data 2, …<br/>
Packet 1: 0xAA, 0xAA, 0xAA, 0xAA, Address2, Data0, Data 1, Data 2, …<br/>
Packet 1: 0xAA, 0xAA, 0xAA, 0xAA, Address3, Data0, Data 1, Data 2, …<br/>
By setting SYNC_CFG1.SYNC_MODE = 010 and SYNC1 = SYNC0 = 0xAA a sync word is detected<br/>
b<br/>
somewhere within the preamble and the serial clock will be output on a GPIO when SYNC_EVENT is<br/>
asserted. Now the MCU can manually start searching for the 3 different addresses. When this method<br/>
is used TOC_CFG.TOC_LIMIT should be 0. In blind mode, TOC_LIMIT must be 1 or 11 .<br/>
b<br/>
19 If this bit is set in RX mode, GPIO2 must be hardwired to 0 (IOCFG2.GPIO2_CFG = HW0 (51))<br/>
SWRU346B Page 60 of 114CC120X<br/>
8.9.2 Transparent Serial Mode<br/>
CC120X does not do any timing recovery and just outputs the hard limited baseband signal. In<br/>
transparent serial mode the symbol rate programming does not affect operation. When transparent<br/>
mode is enabled, the device is set up to resemble a legacy purely analog front end device with<br/>
baseband output to support legacy pulse position modulation, PWM modulated signals etc. In<br/>
transparent mode the signal is digitally demodulated and output on GPIO pins through a<br/>
programmable interpolation filter (MDMCFG0.TRANSPARENT_INTFACT). The interpolation filter is used<br/>
to eliminate jitter on the baseband signal. This is useful when using external DSP demodulators as<br/>
jitter introduce noise in the demodulation process. The rate on the GPIO is ((4 x receiver bandwidth) x<br/>
interpolation factor).<br/>
When using transparent serial mode make sure the interfacing MCU/DSP does proper oversampling.<br/>
In transparent serial mode, several of the support mechanisms for the MCU that are included in<br/>
CC120X will be disabled, such as packet handling hardware, buffering in the FIFO, and so on.<br/>
Preamble and sync word insertion/detection is not supported in transparent serial mode.<br/>
For TX operation, the GPIO0 pin is explicitly used as serial data input. This is automatically done<br/>
when in TX. In order to avoid internal I/O conflict, GPIO0 should be defined as tri-state. GPIO0 will be<br/>
automatically tri-stated in TX if the GPIO0 is defined as serial clock or serial data output<br/>
(IOCFG0.GPIO0_CFG = 8 or 9). If this is not the case, GPIO0 must be manually tri-stated by<br/>
setting IOCFG0.GPIO0_CFG = HIGHZ (48).<br/>
Data output can be observed on GPIO0/1/2/3. This is set by the IOCFGx.GPIOx_CFG fields.<br/>
In addition to set PKT_CFG2.PKT_FORMAT = 11 , the following register fields must be set:<br/>
b<br/>
MDMCFG1.FIFO_EN = 0<br/>
MDMCFG0.TRANSPARENT_MODE_EN = 1<br/>
IOCFGx.GPIOx_CFG = 001001 (SERIAL_RX. Only necessary for RX mode)<br/>
b<br/>
SERIAL_STATUS.IOC_SYNC_PINS_EN = 1 (Only necessary for TX mode)<br/>
In transparent mode, the frequency offset correction is calculated based on the incoming samples<br/>
clocked with a rate equal to 2·RX filter BW. If the data stream contains a row of equal symbols the<br/>
correction factor will move too far to one side with reduced sensitivity as a result. For systems where it<br/>
is not possible to have a white data stream the following may be done to improve sensitivity:<br/>
Set FREQOFF_CFG.FOC_KI_FACTOR = 3 to select the slowest loop<br/>
For a system where the frequency error is less than the deviation the frequency offset<br/>
correction may be turned off by setting FREQOFF_CFG.FOC_EN = 0<br/>
SWRU346B Page 61 of 114CC120X<br/>
9 Radio Control<br/>
CC120X has a built-in state machine that is used to switch between different operational states<br/>
(modes). The change of state is done either by using command strobes or by internal events such as<br/>
TX FIFO underflow. A simplified state diagram is shown in Figure 2. The numbers refer to the state<br/>
numbers readable from the MARCSTATE.MARC_STATE register field.<br/>
9.1 Power-On Start-Up Sequence<br/>
When the power supply is turned on, the system must be reset. This is achieved by one of the two<br/>
sequences described below, i.e. automatic power-on reset (POR) or manual reset.<br/>
9.1.1 Automatic POR<br/>
A power-on reset circuit is included in the CC120X. The internal power-up sequence is completed when<br/>
CHIP_RDYn goes low. CHIP_RDYn is observed on the SO pin after CSn is pulled low (See Section<br/>
3.1.2 for more details).<br/>
When the CC120X reset is completed, the chip will be in the IDLE state and the crystal oscillator will be<br/>
running. If the chip has had sufficient time for the crystal oscillator to stabilize after the power-on-<br/>
reset, the SO pin will go low immediately after taking CSn low. If CSn is taken low before reset is<br/>
completed, the SO pin will first go high, indicating that the crystal oscillator is not stabilized, before<br/>
going low as shown in Figure 31.<br/>
CSn<br/>
SO<br/>
XOSC Stable<br/>
Figure 31: Power-On Reset<br/>
9.1.2 Manual Reset<br/>
The other reset possibilities on the CC120X are issuing using the SRES command strobe or using the<br/>
RESET_N pin. By issuing a manual reset, all internal registers are set to their default values and the<br/>
radio will enter IDLE state.<br/>
9.2 Crystal Control<br/>
The crystal oscillator (XOSC) is either automatically controlled or always on, if<br/>
XOSC2.XOSC_CORE_PD_OVERRIDE = 1. If the XOSC is forced on, the crystal will always stay on<br/>
even if an SXOFF, SPWD, or SWOR command strobe has been issued. This can be used to enable fast<br/>
start-up from SLEEP/XOFF at the expense of a higher current consumption. If<br/>
XOSC2.XOSC_CORE_PD_OVERRIDE = 0, the XOSC will be turned off if the SXOFF, SPWD, or SWOR<br/>
command strobes are issued; the state machine then goes to XOFF or SLEEP state. This can only be<br/>
done from the IDLE state. The XOSC will be automatically turned on again when CSn goes low, and<br/>
the radio will enter IDLE state. The SO pin on the SPI interface must be pulled low before the SPI<br/>
interface is ready to be used, as described in Section 3.1.2.<br/>
Crystal oscillator start-up time depends on crystal ESR and load capacitances.<br/>
9.3 Voltage Regulator Control<br/>
The voltage regulator to the digital core is controlled by the radio controller. When the chip enters the<br/>
SLEEP state which is the state with the lowest current consumption, the voltage regulator is disabled.<br/>
This occurs after CSn is released when a SPWD or SWOR command strobe has been sent on the SPI<br/>
interface. The chip is then in the SLEEP state. Setting CSn low again will turn on the regulator and<br/>
crystal oscillator and make the chip enter the IDLE state.<br/>
SWRU346B Page 62 of 114CC120X<br/>
9.4 Active Modes<br/>
CC120X has two active modes: receive (RX) and transmit (TX). These modes are activated directly by<br/>
the MCU by using the SRX and STX command strobes, or automatically by eWOR (RX mode).<br/>
The MCU can manually change the state from RX to TX and vice versa by using the command<br/>
strobes. If the radio controller is currently in transmit and the SRX strobe is used, the current<br/>
transmission will be ended and the transition to RX will be done. If the radio controller is in RX when<br/>
the STX or SFSTXON command strobes are used, the TX-on-CCA function will be used. If the channel<br/>
is clear, TX (or FSTXON state) is entered. The PKT_CFG2.CCA_MODE setting controls the conditions<br/>
for clear channel assessment (see Section 6.11 for more details).<br/>
The SIDLE command strobe can always be used to force the radio controller to go to the IDLE state.<br/>
9.4.1 RX<br/>
When RX is activated, the chip will remain in receive mode until:<br/>
A packet is received<br/>
An SIDLE, SRX20, STX, or SFSTXON command strobe is being issued<br/>
The RX FIFO overflows/underflows<br/>
The RX termination timer expires<br/>
A CS or PQT based termination takes place<br/>
When a packet is successfully received, the radio controller goes to the state indicated by the<br/>
RFEND_CFG1.RXOFF_MODE setting, i.e. IDLE, FSTXON, TX or RX. When a bad packet is received<br/>
(packet length/address/CRC error) the radio controller will either restart RX or go to IDLE depending<br/>
on the RFEND_CFG0.TERM_ON_BAD_PACKET_EN setting.<br/>
When an RX FIFO overflow or underflow occurs, the radio will enter RX_FIFO_ERR state. When RX<br/>
terminates due to the RX termination timer or lack of CS/PQT, the radio will enter IDLE mode (via<br/>
CALIBRATE depending on the SETTLING_CFG.FS_AUTOCAL setting).<br/>
Please see Section 9.6 for details on which states the radio enters after RX when eWOR is used.<br/>
9.4.2 TX<br/>
Similarly, when TX is active the chip will remain in the TX state until:<br/>
The current packet has been transmitted<br/>
An SIDLE or SRX command strobe is being issued<br/>
The TX FIFO overflows/underflows<br/>
When a packet is successfully transmitted, the radio controller goes to the state indicated by the<br/>
RFEND_CFG0.TXOFF_MODE setting. The possible destinations are the same as for RX.<br/>
20 When an SRX strobe is issued in RX state, RX is restarted (the modulator starts searching for a<br/>
sync word). If the radio was in the middle of a packet reception, part of the “old” packet will remain in<br/>
the RX FIFO so NUM_RXBYTES or RX_LAST should be read before strobing SRX to keep track of<br/>
where the old and new packets are located in the RX FIFO.<br/>
SWRU346B Page 63 of 114CC120X<br/>
9.5 RX Termination<br/>
RX can be terminated by the use of an RX termination timer or based on the assertion of<br/>
CARRIER_SENSE and/or PQT_REACHED. When RX terminates, the chip will always go back to IDLE if<br/>
eWOR is disabled and back to SLEEP (via IDLE) if eWOR is enabled.<br/>
9.5.1 RX Termination Timer<br/>
CC120X has functionality to allow for automatic termination of RX after a programmable timeout. The<br/>
main use for this functionality is in eWOR mode, but it is also useful for other applications as it<br/>
reduces the need for a dedicated MCU timer. The termination timer starts when the chip has entered<br/>
RX state, and the timeout is programmable with the RFEND_CFG1.RX_TIME setting. When the timer<br/>
expires, the radio controller will check the condition for staying in RX.<br/>
The programmable conditions are:<br/>
RFEND_CFG1.RX_TIME_QUAL = 0: Continue receive if sync word has been found<br/>
RFEND_CFG1.RX_TIME_QUAL = 1: Continue receive if sync word has been found, or if PQT<br/>
is reached or CS is asserted<br/>
Equation 22 can be used to calculate the RX timeout.<br/>
EVENT0 1250<br/>
RX Timeout MAX 1,FLOOR 24WOR_RES [s]<br/>
2RX_TIME 3 f<br/>
XOSC<br/>
Equation 22: RX Timeout<br/>
EVENT0 is programmed through WOR_EVENT0_MSB and WOR_EVENT0_LSB, RX_TIME is found in<br/>
RFEND_CFG1 and WOR_RES in WOR_CFG1.<br/>
Figure 32 shows how the radio stays in RX until a packet has been received since a sync word was<br/>
found before the RX termination timer expired (after 10 ms).<br/>
RX_TIME_QUAL = 0<br/>
No sync found after 10 ms<br/>
IDLE RX IDLE<br/>
Time [ms]<br/>
1 2 3 4 5 14 15 16<br/>
RX_TIME_QUAL = 0<br/>
Sync found within 10 ms<br/>
Preamble Sync Payload CRC<br/>
IDLE RX IDLE<br/>
Time [ms]<br/>
1 2 3 4 5 14 15 16 17 18 19 20<br/>
Figure 32: RX Termination when RX_TIME_QUAL = 0 (RX Timeout = 10 ms)<br/>
SWRU346B Page 64 of 114CC120X<br/>
Figure 33 shows how the radio behaves when RX_TIME_QUAL = 1 (assume that<br/>
RFEND_CFG0.ANT_DIV_RX_TERM_CFG = 0). When the RX termination timer expires, the radio will<br/>
check if a sync word is found or if CARRIER_SENSE or PQT_REACHED has been asserted (to check on<br/>
PQT_REACHED, PREAMBLE_CFG0.PQT_EN should be set). If this is the case the radio will remain in<br/>
RX until a packet has been received. This is the case even if the condition for staying in RX is no<br/>
longer true. As shown in the figure, the radio remains in RX after the 10 ms timeout even if a<br/>
preamble is no longer present (PQT_REACHED will be de-asserted) as it only checks the condition for<br/>
staying in RX once when the termination timer expires. The radio will not exit RX mode until a packet<br/>
has been received.<br/>
RX_TIME_QUAL = 1<br/>
No sync found after 10 ms<br/>
IDLE RX IDLE<br/>
Time [ms]<br/>
1 2 3 4 5 14 15 16<br/>
RX_TIME_QUAL = 1<br/>
Preamble Sync Payload CRC<br/>
Preamble found within 10 ms<br/>
IDLE RX IDLE<br/>
Time [ms]<br/>
1 2 3 4 5 20 21 22 23 24 25<br/>
RX_TIME_QUAL = 1<br/>
Preamble found within 10 ms<br/>
Preamble Preamble Sync Payload CRC<br/>
IDLE RX IDLE<br/>
Time [ms]<br/>
1 2 3 4 5 31 32 33<br/>
Figure 33: RX Termination when RX_TIME_QUAL = 1 (RX Timeout = 10 ms)<br/>
SWRU346B Page 65 of 114CC120X<br/>
9.5.2 RX Termination Based on CS<br/>
If RFEND_CFG0.ANT_DIV_RX_TERM_CFG = 1 the device will use the first RSSI sample to<br/>
determine if a carrier is present in the channel. If no carrier is present (CARRIER_SENSE not<br/>
asserted), RX will terminate. The RSSI samples are continually evaluated, and if the RSSI level falls<br/>
below the threshold (programmed through the AGC_CS_THR register) RX will terminate if not sync is<br/>
found. This can be used to achieve very low power by reducing the time in RX mode to a minimum.<br/>
Figure 34 shows how RX mode will be terminated based on CS for different scenarios. Note that sync<br/>
detection will keep the radio in RX until the packet is received regardless of the state of the<br/>
CARRIER_SENSE signal.<br/>
RX_TIME_QUAL = 0<br/>
RFEND_CFG0.ANT_DIV_RX_TERM_CFG = 001b<br/>
RX RX terminated due to lack of carrier<br/>
IDLE IDLE<br/>
AGC_CARRIER_SENSE<br/>
Time [ms]<br/>
1 2 3 4 5 14 15 16<br/>
RX_TIME_QUAL = 0<br/>
RFEND_CFG0.ANT_DIV_RX_TERM_CFG = 001b<br/>
RX terminated when carrier is no<br/>
longer present<br/>
IDLE RX IDLE<br/>
AGC_CARRIER_SENSE<br/>
Time [ms]<br/>
1 2 3 4 5 14 15 16<br/>
RX_TIME_QUAL = 0<br/>
RFEND_CFG0.ANT_DIV_RX_TERM_CFG = 001b<br/>
RX terminated at RX timeout due to<br/>
no sync word found<br/>
(RX_TIME_QUAL = 0)<br/>
IDLE RX IDLE<br/>
CARRIER_SENSE<br/>
Time [ms]<br/>
1 2 3 4 5 14 15 16<br/>
RX_TIME_QUAL = 1<br/>
RX terminated when carrier is no<br/>
RFEND_CFG0.ANT_DIV_RX_TERM_CFG = 001b longer present (not terminated at RX<br/>
timeout since carrier is present at<br/>
that time and RX_TIME_QUAL = 1)<br/>
IDLE RX IDLE<br/>
CARRIER_SENSE<br/>
Time [ms]<br/>
1 2 3 4 5 14 15 16<br/>
Figure 34: RX Termination Based on CS (RX Timeout = 10 ms)<br/>
RX termination based on CS can be used even if the RX termination timer is not used<br/>
(RFEND_CFG1.RX_TIME = 111 ).<br/>
b<br/>
9.5.3 RX Termination Based on PQT<br/>
If RFEND_CFG0.ANT_DIV_RX_TERM_CFG = 100 the device will use the PQT indication to<br/>
b<br/>
determine if RX mode should be terminated or not. If no preamble is detected, RX will be terminated.<br/>
The PQT indication is continually evaluated, and if the PQT level falls below the threshold RX will<br/>
terminate if no sync is found. This can be used to achieve very low power by reducing the time in RX<br/>
mode to a minimum.<br/>
RX termination based on PQT can be used even if the RX termination timer is not used<br/>
(RFEND_CFG1.RX_TIME = 111 ).<br/>
b<br/>
SWRU346B Page 66 of 114CC120X<br/>
9.6 Enhanced Wake on Radio (eWOR)<br/>
The optional enhanced Wake on Radio (eWOR) functionality enables CC120X to periodically wake up<br/>
from SLEEP and listen for incoming packets without MCU interaction.<br/>
When the SWOR strobe command is sent on the SPI interface, the CC120X will go to the SLEEP state<br/>
when CSn is released. Unless an external crystal is used (EXT_CTRL.EXT_40K_CLOCK_EN = 1)<br/>
the RC oscillator must be enabled by setting WOR_CFG0.RC_PD = 0 before the SWOR strobe is<br/>
issued, as it is the clock source for the eWOR timer (see Section 9.9 for more info on the RC<br/>
oscillator). The on-chip eWOR timer will set CC120X into IDLE state and then RX state. After a<br/>
programmable time in RX (see Section 9.5.1), the chip will go back to the SLEEP state, unless a<br/>
packet is received.<br/>
To exit eWOR mode, CSn must be pulled low.<br/>
The on-chip eWOR timer will be clocked, independently of eWOR mode, whenever the RC oscillator<br/>
is running. This preserves the timing when exiting eWOR mode. The on-chip eWOR timer can be<br/>
reset to the Event 1 value by issuing the SWORRST strobe command. The value of the eWOR timer is<br/>
available through WOR_TIME1 and WOR_TIME0.<br/>
Every time a sync word is found, the current value of the eWOR timer will be captured and it can be<br/>
read through the WOR_CAPTURE1 and WOR_CAPTURE0 registers. This feature is useful in applications<br/>
where re-synchronization of the eWOR timer is required.<br/>
CC120X can be configured to signal the MCU that a packet has been received by using a GPIO pin.<br/>
When the MCU has read the packet, it can put the chip back into SLEEP with the SWOR strobe from<br/>
the IDLE state.<br/>
9.6.1 WOR EVENT 0, 1, and 2<br/>
The eWOR timer has three events, Event 0, Event 1, and Event 2. In the SLEEP state with eWOR<br/>
activated, reaching Event 0 will turn on the digital regulator and start the crystal oscillator (unless<br/>
WOR_CFG1.WOR_MODE = 100 ). Event 1 follows Event 0 after a programmed timeout (t ).<br/>
b Event1<br/>
Figure 35 shows the timing relationship between Event 0 timeout and Event 1 timeout.<br/>
Rx Timeout<br/>
State: SLEEP IDLE RX SLEEP IDLE RX<br/>
Event0 Event1 Event0 Event1<br/>
t<br/>
t<br/>
Event0<br/>
t<br/>
Event0<br/>
t t<br/>
Event1 Event1<br/>
t<br/>
SLEEP<br/>
Figure 35: Event 0 and Event 1 Relationship<br/>
The time between two consecutive Event 0’s is programmed with a mantissa value given by<br/>
WOR_EVENT0_MSB and WOR_EVENT0_LSB and an exponent value set by WOR_CFG1.WOR_RES. t<br/>
Event0<br/>
is given by Equation 23.<br/>
1<br/>
t EVENT0 25WOR_RES [s]<br/>
Event0 f<br/>
RCOSC<br/>
Equation 23: t<br/>
Event0<br/>
The Event 1 timeout is programmed with a mantissa value decoded by the WOR_CFG1.EVENT1<br/>
setting.<br/>
SWRU346B Page 67 of 114CC120X<br/>
WOR_CFG1.EVENT1 WOR_EVENT1 t [µs] (f = 40 kHz)<br/>
Event1 RCOSC<br/>
000 4 100<br/>
001 6 150<br/>
010 8 200<br/>
011 12 300<br/>
100 16 400<br/>
101 24 600<br/>
110 32 800<br/>
111 48 1200<br/>
Table 30: Event 1<br/>
Equation 24 gives the Event 1 timeout.<br/>
1<br/>
t WOR_EVENT1 [s]<br/>
Event1 f<br/>
RCOSC<br/>
Equation 24: t<br/>
Event1<br/>
An SRX strobe is issued on Event 1 if t is larger than the crystal start-up time. If t is shorter<br/>
Event1 Event1<br/>
than the crystal start-up time (CHIP_RDYn not asserted when Event 1 occurs), the SRX strobe will be<br/>
issued as soon as CHIP_RDYn is asserted.<br/>
Event 2 can used to autonomously take the system out of SLEEP at regular intervals to perform RC<br/>
oscillator calibration. This will improve the accuracy of the timer.<br/>
The Event 2 timing is programmed with an exponent value decoded by the WOR_CFG0.EVENT2_CFG<br/>
setting.<br/>
WOR_CFG0.EVENT2_CFG WOR_EVENT2 t [s] (f = 40 kHz)<br/>
Event2 RCOSC<br/>
00 Disabled<br/>
01 15 ~0.82<br/>
10 18 ~6.55<br/>
11 21 ~52.4<br/>
Table 31: WOR_EVENT2<br/>
t is given by Equation 25.<br/>
Event2<br/>
2WOR_EVENT2<br/>
t [s]<br/>
Event2 f<br/>
RCOSC<br/>
Equation 25: t<br/>
Event2<br/>
When setting EVENT2_CFG ≠ 0, t must be greater than t and RC oscillator calibration must<br/>
Event0 Event2<br/>
be enabled (WOR_CFG0.RC_MODE = 10 ).<br/>
b<br/>
All three events21 can be monitored on the GPIO pins by setting IOCFGx.GPIOx_CFG =<br/>
WOR_EVENT0/1/2 (54/55/56).<br/>
21 If IOCFGx.GPIOx_CFG = WOR_EVENT2 (56), WOR_CFG0.EVENT2_CFG must be ≠ 0<br/>
SWRU346B Page 68 of 114CC120X<br/>
9.6.2 eWOR Modes<br/>
The different eWOR modes are programmed through the WOR_CFG1.WOR_MODE register field. The<br/>
three most common eWOR modes are Feedback Mode, Normal Mode, and Legacy Mode.<br/>
Feedback Mode<br/>
The radio wakes up on Event 0 and strobes SRX on Event 1. If a good packet is being received<br/>
the radio enters the state indicated by the RFEND_CFG1.RXOFF_MODE setting. When a bad<br/>
packet is received (packet length/address/CRC error) the radio will either restart RX or enter<br/>
SLEEP mode, depending on RFEND_CFG0.TERM_ON_BAD_PACKET_EN. If<br/>
TERM_ON_BAD_PACKET_EN = 1, the radio will go to IDLE instead of SLEEP after receiving 16<br/>
bad packets in a row22. When this occurs, a GPIO pin can be used to wake up the MCU by<br/>
setting IOCFGx.GPIOx_CFG = MCU_WAKEUP (20). Please see Section 3.4.1.2 for more<br/>
details on MCU Wake-Up.<br/>
Normal Mode<br/>
This mode is equivalent to Feedback Mode without the bad packet counter feature. This means<br/>
that the radio can go back to SLEEP when a bad packet is received as long as<br/>
TERM_ON_BAD_PACKET_EN = 1, but it does not give any feedback to the MCU regarding this.<br/>
Legacy Mode<br/>
As long as a sync word has been received, the radio will not go back to SLEEP automatically. If<br/>
a good packet is being received the radio enters the state indicated by the<br/>
RFEND_CFG1.RXOFF_MODE setting and when a bad packet is received it will either restart RX<br/>
or enter IDLE mode, depending on RFEND_CFG0.TERM_ON_BAD_PACKET_EN.<br/>
There are also two other modes using the eWOR timer as a general sleep timer or to generate timing<br/>
signals for the MCU.<br/>
Event 1 Mask Mode enables the radio to wake up from SLEEP on Event 0 without going to RX mode<br/>
while Event 0 Mask Mode keeps the radio in SLEEP mode ignoring all the events. In both cases the<br/>
WOR_EVENT0/1 signals can still be made available on the GPIO pins to be used by the MCU or other<br/>
peripherals in the system by setting IOCFGx.GPIOx_CFG = WOR_EVENT0/1 (55/56).<br/>
9.6.3 eWOR Usage<br/>
eWOR can be used in systems where a transmitter sends a packet at a given interval (see Figure 36).<br/>
TX TX TX TX<br/>
Preamble + sync<br/>
Payload<br/>
Time<br/>
1 s 1 s 1 s<br/>
RX RX RX RX<br/>
XOSC Start-Up<br/>
RX Timeout<br/>
Extra time in RX<br/>
to receive the packet Time<br/>
1 s 1 s 1 s<br/>
Figure 36: eWOR Mode (RX and TX in sync.)<br/>
Under ideal circumstances, the receiver and transmitter is in sync as shown in Figure 36, but in most<br/>
cases this is not the case. Assume the transmitter is sending packets at a slower rate than the<br/>
receiver wakes up to look for packet as shown in Figure 37.<br/>
22 To not receive a packet at all is in this content equivalent to receiving a bad packet<br/>
SWRU346B Page 69 of 114CC120X<br/>
TX TX TX TX<br/>
Preamble + sync<br/>
Payload<br/>
Time<br/>
1.x s 1.x s 1.x s<br/>
RX RX RX<br/>
XOSC Start-Up<br/>
RX Timeout<br/>
Extra time in RX<br/>
to receive the packet Time<br/>
1 s 1 s 1 s<br/>
Figure 37: eWOR Mode (RX and TX out of sync.)<br/>
In this case, the WOR_CAPTURE1 and WOR_CAPTURE0 registers on the receivers would show a higher<br/>
and higher value for every packet received, indicating that the transmitter is sending at a slower rate<br/>
than t . The receiver should therefore increase t to stay in sync with the transmitter (see<br/>
EVENT0 EVENT0<br/>
Figure 38).<br/>
TX TX TX TX<br/>
Preamble + sync<br/>
Payload<br/>
Time<br/>
1.x s 1.x s 1.x s<br/>
RX RX RX RX<br/>
XOSC Start-Up<br/>
RX Timeout<br/>
Extra time in RX<br/>
to receive the packet<br/>
1 s 1.x s 1.x s<br/>
Figure 38: eWOR Mode (RX and TX re-synchronized)<br/>
9.7 RX Sniff Mode<br/>
For battery operated systems the RX current is an important parameter and to increase battery<br/>
lifetime a novel RX Sniff Mode feature has been designed for the CC120X family to autonomously sniff<br/>
for RF activity using an ultra-low-power algorithm. RX Sniff Mode can either be enabled by using<br/>
eWOR together with RX termination based on CS (see 9.5.2) or PQT (see 9.5.3) or by using the RX<br/>
duty cycle timer (see Section 9.8 for more details).<br/>
The CC120X platform is designed for extremely fast settling time hence the receiver can be turned on<br/>
and off quickly. Together with the ability to quickly and reliably detect if there is RF activity or not this<br/>
is a key parameter to reduce the power consumption.<br/>
The CC120X family use strong DSP logic to detect a sync word and the preamble is only needed for<br/>
AGC settling, i.e. settling the gain of the front end. A 4 bits preamble is enough for settling including<br/>
frequency offset compensation (AFC).<br/>
SWRU346B Page 70 of 114CC120X<br/>
9.7.1 RX Sniff Mode Usage<br/>
RX Sniff Mode is extremely useful in cases where you do not know when the transmitter is going to<br/>
send a packet. Figure 39 shows ordinary RX mode, where the radio must stay continuously in RX to<br/>
make sure that it will receive the transmitted packet.<br/>
TX<br/>
4 bits<br/>
Sync Payload<br/>
preamble<br/>
RX<br/>
Time<br/>
Figure 39: Ordinary RX Mode<br/>
By increasing the preamble of the transmitted packet, the receiver can implement RX Sniff Mode and<br/>
wake up at an interval that ensures that at least 4 bits of preamble is received. RX termination based<br/>
on CS greatly reduces the time in RX and forces the radio back in SLEEP if there is no signal on the<br/>
air.<br/>
TX<br/>
Preamble<br/>
(4 bytes) Sync Payload<br/>
R R R<br/>
RX<br/>
X X X<br/>
Time<br/>
Figure 40: RX Sniff Mode<br/>
The wake-up interval (t ) can be increased further by letting the receiver look for an 11 bits sync<br/>
Event0<br/>
word (16 bits are sent on the air). This way, the 5 MSBs can be used for AGC settling and no<br/>
preamble is needed (see Figure 41).<br/>
TX<br/>
Preamble<br/>
(4 bytes) Sync Payload<br/>
R R R<br/>
RX<br/>
X X X<br/>
Time<br/>
Figure 41: RX Sniff Mode (no preamble)<br/>
SWRU346B Page 71 of 114CC120X<br/>
9.8 RX Duty Cycle Mode<br/>
In systems with high symbol rate and/or very short preamble one should use the RX duty cycle timer<br/>
instead of the eWOR timer to implement RX Sniff Mode, as the RX duty cycle timer provides smaller<br/>
timeouts/gives finer resolution on the time not spent in RX. The radio should still be configured to use<br/>
RX termination based on CS or PQT.<br/>
When the RX duty cycle timer is used (WOR_CFG0.RX_DUTY_CYCLE_MODE ≠ 0), the radio will enter<br/>
RXDCM state instead of SLEEP state when the radio is not in RX. Table 32 lists the different RX duty<br/>
cycle modes and the RX modules enabled when the radio is in RXDCM state. Figure 42 shows the<br/>
different states the radio will enter when RX duty cycle mode is used.<br/>
RX_DUTY_CYCLE_MODE Mode RX Modules Enabled while in RXDCM State<br/>
0 RXDCM Off RXDCM state not reachable<br/>
1 RXDCM0 Digital RX modules turned off. Analog RX modules enabled. Next state is RX.<br/>
This is the mode that provides lowest current reduction<br/>
2 RXDCM1 All modules in the FS_LOCK state. Next state is IFADCON. This is the mode that<br/>
provides medium current reduction<br/>
3 RXDCM2 All modules in IDLE state. Next state is BIAS_SETTLE. This is the state the<br/>
provides the highest current reduction<br/>
Table 32: RX Duty Cycle Mode<br/>
The time spent in RXDCM (t ) state is controlled via the RXDCM_TIME.RX_DUTY_CYCLE_TIME<br/>
RXDCM<br/>
and WOR_CFG1.WOR_RES register fields and can be calculated using Equation 2623.<br/>
t RX _DUTY _CYCLE_TIME 2WOR_RES [ s]<br/>
RXDCM<br/>
Equation 26: t<br/>
RXDCM<br/>
RX duty cycle mode must not be used together with eWOR mode or antenna diversity. To enter<br/>
RXDCM, an SRX strobe should be issued when WOR_CFG0.RX_DUTY_CYCLE_MODE ≠ 0.<br/>
IDLE<br/>
SFRX<br/>
BIAS_SETTLE RX_DUTY_CYCLE_MODE = 11b<br/>
&amp; duty_cycle done<br/>
REG_SETTLE RXOFF_MODE = 0<br/>
FS_AUTOCAL = 01b RX_FIFO_ERROR | RX timeout<br/>
&amp; SRX<br/>
SRX<br/>
STARTCAL<br/>
RXDCM<br/>
CAL_COMPLETE<br/>
RXFIFO_<br/>
BWBOOST UNDER/OVERFLOW<br/>
FS_LOCK<br/>
IFADCON rx_duty_cycle &amp;<br/>
(CS/PQT termination<br/>
RX_DUTY_CYCLE_MODE = 10b | RX timeout)<br/>
&amp; duty_cycle done<br/>
SRX<br/>
RX_DUTY_CYCLE_MODE = 01b<br/>
&amp; duty_cycle done<br/>
RX<br/>
RXOFF_MODE = 11b<br/>
| packet failed<br/>
Done | RXFIFO_<br/>
OVERFLOW |<br/>
packet failed | RX_END<br/>
RX timeout<br/>
Figure 42: RXDCM State Diagram<br/>
23 For RX_DUTY_CYCLE_MODE = 0, t 2WOR_RES[µs]<br/>
RXDCM<br/>
SWRU346B Page 72 of 114CC120X<br/>
9.9 RC Oscillator Calibration<br/>
The frequency of the low-power RC oscillator used for the eWOR functionality varies with temperature<br/>
and supply voltage. In order to keep the frequency as accurate as possible, the RC oscillator should<br/>
be calibrated whenever possible. Two automatic RC calibration options are available that are<br/>
controlled by the WOR_CFG0.RC_MODE setting:<br/>
RC calibration is enabled when the XOSC is running<br/>
RC calibration is enabled on every 4th time the device is powered up and goes from IDLE to<br/>
RX (should only be used together with eWOR).<br/>
During calibration the eWOR timer will be clocked on a down-divided version of the XOSC clock.<br/>
When the chip goes to the SLEEP state, the RC oscillator will use the last valid calibration result. The<br/>
frequency of the RC oscillator is calibrated to the main crystal frequency divided by 1000 (40 kHz).<br/>
In applications where the radio wakes up very often, typically several times every second, it is<br/>
possible to do the RC oscillator calibration once and then turn off calibration to reduce the current<br/>
consumption. If the RC oscillator calibration is turned off, it will have to be manually turned on again to<br/>
resume calibration. This will be necessary if temperature and supply voltage changes to maintain<br/>
accuracy.<br/>
When the WOR_CFG0.RC_MODE setting is altered from 0 or 1 to 10 or 11 (enabled), an SIDLE<br/>
b b<br/>
command strobe must be issued before the new configuration is taken into account. If it is altered<br/>
from 10 or 11 to 0 or 1 (disabled), an SPWD, SWOR, or SXOFF strobe must be issued.<br/>
b b<br/>
When not using eWOR and RC calibration is enabled, staying in TX or RX mode over a long period of<br/>
time will cause internal heating of the chip, which again might cause the RC OSC period to increase.<br/>
It is therefore recommended to turn off RCOSC calibration during active mode.<br/>
9.10 Antenna Diversity and Multiple Path Transmission<br/>
CC120X has two different antenna diversity modes: Single-switch mode and continuous-switch mode.<br/>
Single switch mode is useful for very low power schemes where the device only checks each antenna<br/>
once for a signal and directly returns to power down if a signal is not detected (automated using the<br/>
eWOR feature). If a signal is found on the first antenna checked, it does not check the second<br/>
antenna.<br/>
Continuous mode is useful when staying in RX for longer intervals.<br/>
The antenna diversity algorithm can operate based on PQT or CS. The user can configure how the<br/>
device will act in regards to antenna diversity and RX termination as described in Table 33.<br/>
RFEND_CFG0. Description<br/>
ANT_DIV_RX_TERM_CFG<br/>
000 Antenna diversity and termination based on CS/PQT are disabled<br/>
001 RX termination base on CS is enabled (Antenna diversity OFF). See 9.5.2 for details.<br/>
010 Single-switch antenna diversity on CS enabled.<br/>
One or both antenna is CS evaluated once and RX will terminate<br/>
if CS failed on both antennas.<br/>
011 Continuous-switch antenna diversity on CS enabled.<br/>
Antennas are switched until CS is asserted or RX timeout occurs<br/>
(if RX timeout is enabled)<br/>
100 RX termination base on PQT is enabled (Antenna diversity OFF).<br/>
See 9.5.3 for details.<br/>
101 Single-switch antenna diversity on PQT enabled.<br/>
One or both antenna is PQT evaluated once and RX will terminate if PQT is not<br/>
reached on any of the antennas.<br/>
110 Continuous-switch antenna diversity on PQT enabled.<br/>
Antennas are switched until PQT is reached or RX timeout occurs<br/>
(if RX timeout is enabled)<br/>
111 Reserved<br/>
Table 33: RFEND_CFG0.ANT_DIV_RX_TERM_CFG Setting<br/>
SWRU346B Page 73 of 114CC120X<br/>
9.10.1 Antenna Diversity Features<br/>
The device supports antenna diversity by controlling an external RF switch using the<br/>
ANTENNA_SELECT control signal available on GPIO (IOCFGx.GPIOx_CFG = ANTENNA_SELECT<br/>
(36)).<br/>
The device will remember the last antenna used (when not entering SLEEP mode24) and use the last<br/>
antenna for the next RX or TX transition. Staying with the same antenna will make sure:<br/>
In RX, that the last antenna used for good reception will be the first one to be checked<br/>
(minimize time for the next reception)<br/>
In TX, the device will transmit acknowledge with the same antenna that received the packet.<br/>
9.11 Random Number Generator<br/>
A random number generator is available and can be enabled by setting RNDGEN.RNDGEN_EN = 1. A<br/>
random number can be read from RNDGEN.RNDGEN_VALUE in any state, but the number will be<br/>
further randomized when in RX by XORing the feedback with receiver noise.<br/>
9.12 RF Programming<br/>
RF programming in CC120X is given by two factors; the VCO frequency programming and the LO<br/>
divider programming (RF band selection). The relation is given in Equation 27 below.<br/>
f<br/>
f VCO [Hz]<br/>
RF LO Divider<br/>
Equation 27: Radio Frequency<br/>
The VCO frequency is given by the 24 bit (unsigned) frequency word FREQ located in the FREQ2,<br/>
FREQ1, and FREQ0 registers. There is also a possibility to perform VCO frequency offset<br/>
programming, given by the 16 bit (signed) frequency offset word FREQOFF located in the FREQOFF1<br/>
and FREQOFF0 registers. This is intended to adjust for crystal intolerance or fine adjustments of the<br/>
RF programming.<br/>
FREQ FREQOFF<br/>
f f f [Hz]<br/>
VCO 216 XOSC 218 XOSC<br/>
Equation 28: VCO Frequency<br/>
Note that the FREQOFF programming and FREQOFF_EST (found in FREQOFF_EST1 and<br/>
FREQOFF_EST0) have identical formats hence the frequency estimate can be accumulated directly to<br/>
the FREQOFF programming. This can be done either manually or automatically through the SAFC<br/>
command strobe. A SAFC command strobe can be issued in any state but does not take effect until<br/>
the next time the radio enters active mode (TX or RX).<br/>
24 In SLEEP mode the GDIOx pin will be hardwired to 0 or 1 depending on which GDIO pin is used<br/>
and what the value of IOCFGx_GPIOx_INV is. Please see Section 3.4 for more details.<br/>
SWRU346B Page 74 of 114CC120X<br/>
The LO divider/band select decoding is shown in Table 34.<br/>
FS_CFG.FSD_BANDSELECT LO Divider RF Band [MHz]<br/>
0000 - 0001 - Not in use<br/>
0010 4 820 - 960<br/>
0011 - Not in use<br/>
0100 8 410 - 480<br/>
0101 - Not in use<br/>
0110 12 273.3 - 320<br/>
0111 - Not in use<br/>
1000 16 205 - 240<br/>
1001 - Not in use<br/>
1010 20 164 - 192<br/>
1011 24 136.7 - 160<br/>
1100 - 1111 - Not in use<br/>
Table 34: RF Band Selection Decoding<br/>
Since the RF band is determined by the LO divider setting, the different RF bands will also have<br/>
different frequency resolution. Note that the frequency offset word is related to the VCO frequency<br/>
programming, and hence any crystal inaccuracy compensation is therefore independent of the<br/>
selected RF band.<br/>
See Table 35 for an overview of the RF resolution.<br/>
RF Band [MHz] RF Programming Resolution [Hz]<br/>
820 - 960 38.1<br/>
410 - 480 19.1<br/>
273.3 - 320 12.7<br/>
205 - 240 9.5<br/>
164 - 192 7.6<br/>
136.7 - 160 6.4<br/>
Table 35: RF Programming Resolution<br/>
9.13 Frequency Synthesizer Configuration<br/>
If any frequency programming registers are altered when the frequency synthesizer is running, the<br/>
synthesizer may give an undesired response. Hence, the frequency programming should only be<br/>
updated when the radio is in the IDLE state.<br/>
9.14 IF Programming<br/>
The IF frequency is programmed through the IF_MIX_CFG.CMIX_CFG register field. The supported<br/>
IF frequencies (f ) are listed in Table 36. The decimation factor is given by<br/>
IF<br/>
CHAN_BW.ADC_CIC_DECFACT.<br/>
CMIX_CFG Decimation Factor Comment<br/>
12 24 48<br/>
0 0 0 0 Zero-IF<br/>
1 -833.33 -416.67 -208.33 f<br/>
f xosc<br/>
IF Decimation Factor 4<br/>
2 -555.56 -277.78 -138.89 f<br/>
f xosc<br/>
IF Decimation Factor 6<br/>
3 -416.67 -208.33 -104.17 f<br/>
f xosc<br/>
IF Decimation Factor 8<br/>
4 0 0 0 Zero-IF<br/>
5 833.33 416.67 208.33 f<br/>
f xosc<br/>
IF Decimation Factor 4<br/>
6 555.56 277.78 138.89 f<br/>
f xosc<br/>
IF Decimation Factor 6<br/>
7 416.67 208.33 104.17 f<br/>
f xosc<br/>
IF Decimation Factor 8<br/>
Table 36: IF Frequency [kHz]<br/>
SWRU346B Page 75 of 114CC120X<br/>
9.15 FS Calibration<br/>
The internal on-chip FS characteristics will vary with temperature and supply voltage changes as well<br/>
as the desired operating frequency. In order to ensure reliable operation, CC120X includes frequency<br/>
synthesizer self-calibration circuitry. This calibration should be done regularly, and must be performed<br/>
after turning on power and before using a new radio frequency.<br/>
CC120X has one manual calibration option (using the SCAL strobe), and three automatic calibration<br/>
options that are controlled by the SETTLING_CFG.FS_AUTOCAL setting:<br/>
Calibrate when going from IDLE to either RX or TX (or FSTXON)<br/>
Calibrate when going from either RX or TX to IDLE automatically<br/>
Calibrate every fourth time when going from either RX or TX to IDLE automatically<br/>
If the radio goes from TX or RX to IDLE by issuing an SIDLE strobe, calibration will not be performed.<br/>
Note: The calibration values are maintained in SLEEP mode, so the calibration is still valid<br/>
after waking up from SLEEP mode unless supply voltage or temperature has changed<br/>
significantly.<br/>
9.16 FS Out of Lock Detection<br/>
To check whether the PLL is out of lock, the user can enable the lock detector through the<br/>
FS_LOCK_EN bit in the FS_CFG register. The lock indication can either be read through<br/>
FSCAL_CTRL.LOCK or set available on GDO0 or GDO1 (IOCFG0/1.GPIO0/1_CFG = LOCK (35))<br/>
as an interrupt to the MCU. A negative transition on the lock indication indicates that the FS is out of<br/>
lock. The state of the LOCK signal is only valid in RX, TX, and FSTXON state.<br/>
Note that the lock detector average time is configurable and can be set through the<br/>
FS_CAL0.LOCK_CFG register field.<br/>
SWRU346B Page 76 of 114CC120X<br/>
10 AES<br/>
The CC120X contains an AES accelerator that can be used as a stand-alone AES module for AES<br/>
block operations. In this mode the MCU write and read back data over SPI to perform security<br/>
operations for maximum flexibility.<br/>
In addition there are built in commands to do automatic in-line security operations on the FIFO<br/>
content for minimum impact on MCU / SPI traffic.<br/>
10.1 AES Block Operation<br/>
To encrypt a 128 bit data block with the AES module using cipher block chaining (CBC), the following<br/>
procedure must be followed:<br/>
Write the 128 bit long AES key to the key location in the AES workspace (AES_KEY15 is the 7<br/>
MSB and starts at address 0x2FE0)<br/>
Write the 128 bit data block to the buffer location in the AES workspace (AES_BUFFER15 is the<br/>
7 MSB and starts at address 0x2FF0)<br/>
Execute encryption by setting AES.AES_RUN = 1. The bit will be set low by HW when<br/>
operation is finished.<br/>
Read encrypted data block from the buffer location in the AES workspace (address 0x2FF0)<br/>
10.2 AES Commands<br/>
The CC120x has built-in high level AES commands that can be called when the radio is in IDLE state<br/>
(these commands must not be called from any other states). These high level commands can<br/>
accelerate AES operations on the FIFO content and are triggered by issuing an SIDLE strobe while<br/>
the radio is in IDLE state. The AES commands are controlled by the MARC_SPARE.AES_COMMANDS<br/>
register field.<br/>
Table 37 shows the different AES commands.<br/>
MARC_SPARE.AES_COMMANDS Command Description<br/>
0x09 AES_TXFIFO AES CTR on the TX FIFO content<br/>
0x0A AES_RXFIFO AES CTR on the RX FIFO content<br/>
Table 37: AES Commands<br/>
GPIO0 will be asserted when an AES command is activated, and de-asserted when the AES<br/>
command is completed if IOCFG0.GPIO0_CFG = AES_COMMAND_ACTIVE (22).<br/>
10.3 AES Parameters<br/>
Several parameters are needed for each AES command. These parameters must be written to given<br/>
locations in the AES command workspace (part of the free area) using direct memory access25. The<br/>
following sections show where to write which parameters for each of the two AES commands<br/>
available.<br/>
10.3.1 AES TXFIFO<br/>
The AES_TXFIFO command is used to perform CTR on the TX FIFO content. Parameters needed to<br/>
be initialized are shown in Table 38. The nonce is located at memory location 0x80 in the AES<br/>
command workspace (free area, SERIAL_STATUS.SPI_DIRECT_ACCESS_CFG = 1) and are<br/>
reached using direct memory access (0x3E is the command preceding the address).<br/>
Address Parameter<br/>
0xF0 Pointer to first entry in the TXFIFO to encrypt (the packet<br/>
must always be written to a flushed TXFIFO meaning that<br/>
the first byte in the packet is at location 0x00)<br/>
0xF2 Number of bytes in the TXFIFO that shall be encrypted<br/>
Table 38: AES TXFIFO Parameters<br/>
25 Direct memory access starts with the command 0x3E (see Table 3 for more details)<br/>
SWRU346B Page 77 of 114CC120X<br/>
10.3.2 AES RXFIFO<br/>
The AES_TXFIFO command is used to perform CTR on the RX FIFO content. Parameters needed to<br/>
be initialized are shown in Table 39. The nonce is located at memory location 0x80 in the AES<br/>
command workspace (free area, SERIAL_STATUS.SPI_DIRECT_ACCESS_CFG = 1) and are<br/>
reached using direct memory access (0x3E is the command preceding the address).<br/>
Address Parameter<br/>
0xF0 Pointer to first entry in the RXFIFO to decrypt (the RXFIFO<br/>
must be flushed before the packet is received meaning that<br/>
the first byte in the packet is at location 0x00)<br/>
0xF2 Number of bytes in the RXFIFO that shall be decrypted<br/>
Table 39: RXFIFO Parameters<br/>
10.4 AES TX/RXFIFO Operation<br/>
The following section will show the steps necessary to encrypt the TXFIFO content and decrypt the<br/>
RXFIFO content using counter mode (CTR).<br/>
10.4.1 TXFIFO Encryption<br/>
Make sure the radio is in IDLE state<br/>
Flush the TXFIFO using the SFTX command strobe<br/>
Write the packet to the TXFIFO<br/>
Set MARC_SPARE.AES_COMMAND = 0x09 (AES_TXFIFO)<br/>
Write the 128 bit long AES key to the key location in the AES workspace (AES_KEY15 is the 7<br/>
MSB and starts at address 0x2FE0)<br/>
Set SERIAL_STATUS.SPI_DIRECT_ACCESS_CFG = 1<br/>
Write the AES TXFIFO parameters (see Table 38) to the AES command workspace using<br/>
direct memory access<br/>
Write the nonce to address 0x80 in the AES command workspace using direct memory access<br/>
Strobe SIDLE to execute the AES_TXFIFO command<br/>
A falling edge on GPIO0 indicates that the operation is done (if IOCFG0.GPIO0_CFG =<br/>
AES_COMMAND_ACTIVE (22)) and an STX strobe can be issued.<br/>
10.4.2 RXFIFO Decryption<br/>
Make sure the radio is in IDLE state<br/>
Flush the RXFIFO using the SFRX command strobe<br/>
Issue an SRX strobe and wait for a packet to be received<br/>
Set MARC_SPARE.AES_COMMAND = 0x0A (AES_RXFIFO)<br/>
Write the 128 bit long AES key to the key location in the AES workspace (AES_KEY15 is the 7<br/>
MSB and starts at address 0x2FE0)<br/>
Set SERIAL_STATUS.SPI_DIRECT_ACCESS_CFG = 1<br/>
Write the AES RXFIFO parameters (see Table 39) to the AES command workspace using<br/>
direct memory access<br/>
Write the nonce to address 0x80 in the AES command workspace using direct memory access<br/>
Strobe SIDLE to execute the AES_RXFIFO command<br/>
A falling edge on GPIO0 indicates that the operation is done (if IOCFG0.GPIO0_CFG =<br/>
AES_COMMAND_ACTIVE (22)) and the RXFIFO can be read.<br/>
SWRU346B Page 78 of 114CC120X<br/>
11 System Considerations and Guidelines<br/>
11.1 Voltage Regulators<br/>
CC120X contains several on-chip linear voltage regulators that generate the supply voltages needed by<br/>
the low-voltage modules. These voltage regulators are invisible to the user, and can be viewed as<br/>
integral parts of the various modules. The user must however make sure that the absolute maximum<br/>
ratings and required pin voltages are not exceeded.<br/>
By setting the CSn pin low, the voltage regulator to the digital core turns on and the crystal oscillator<br/>
starts. The SO pin on the SPI interface must go low before the first positive edge of SCLK (setup time<br/>
is given in Table 1.If the chip is programmed to enter power-down mode (SPWD or SWOR strobe<br/>
issued), the power will be turned off after CSn goes high. The power and crystal oscillator will be<br/>
turned on again when CSn goes low.<br/>
The voltage regulator for the digital core requires one external decoupling capacitor.<br/>
The voltage regulator output should only be used for driving the CC120X.<br/>
11.2 SRD Regulations<br/>
International regulations and national laws regulate the use of radio receivers and transmitters. Short<br/>
Range Devices (SRDs) for license free operation below 1 GHz are usually operated in the 169 MHz,<br/>
433 MHz, 868 MHz, 915 MHz, or 950 MHz frequency bands. The CC120X is specifically designed for<br/>
operation in these bands.<br/>
Please note that compliance with regulations is dependent on the complete system performance. It is<br/>
the customer’s responsibility to ensure that the system complies with regulations.<br/>
11.3 Frequency Hopping and Multi-Channel Systems<br/>
The 433 MHz, 868 MHz, or 915 MHz bands are shared by many systems both in industrial, office, and<br/>
home environments. It is therefore recommended to use frequency hopping spread spectrum (FHSS)<br/>
or a multi-channel protocol because frequency diversity makes the system more robust with respect<br/>
to interference from other systems operating in the same frequency band. FHSS also combats<br/>
multipath fading.<br/>
CC120X is highly suited for FHSS or multi-channel systems due to its agile frequency synthesizer and<br/>
effective communication interface. Using the packet handling support and data buffering is also<br/>
beneficial in such systems as these features will significantly offload the host controller.<br/>
Charge pump current, VCO current, and VCO capacitance array calibration data is required for each<br/>
frequency when implementing frequency hopping for CC120X. There are 2 ways of obtaining the<br/>
calibration data from the chip:<br/>
1) Frequency hopping with calibration for each hop.<br/>
2) Fast frequency hopping without calibration for each hop can be done by performing the necessary<br/>
calibration at start-up and saving the resulting FS_CHP, FS_VCO4, and FS_VCO2 register values in<br/>
MCU memory. Between each frequency hop, the calibration process can then be replaced by writing<br/>
the calibration values that corresponds to the next RF frequency.<br/>
The recommended settings change with frequency. This means that one should always use<br/>
SmartRF Studio to get the correct settings for a specific frequency before doing a calibration,<br/>
regardless of which calibration method is being used.<br/>
11.4 Continuous Transmissions<br/>
In data streaming applications, the CC120X opens up for continuous transmissions at an effective data<br/>
rate of up to 1 Mbps. As the modulation is done with a closed loop PLL, there is no limitation in the<br/>
length of a transmission (open loop modulation used in some transceivers often prevents this kind of<br/>
continuous data streaming and reduces the effective data rate).<br/>
11.5 Battery Operated Systems<br/>
In low power applications, the SLEEP state with the crystal oscillator core switched off should be used<br/>
when the CC120X is not active. It is possible to leave the crystal oscillator core running in the SLEEP<br/>
state if start-up time is critical. The eWOR functionality should be used in low power applications.<br/>
SWRU346B Page 79 of 114CC120X<br/>
12 Register Description<br/>
For a detailed description of the register fields, please see SmartRF Studio [1]<br/>
IOCFG3 - GPIO3 Pin Configuration<br/>
Bit # Name Reset R/W Description<br/>
7 GPIO3_ATRAN 0x00 R/W Analog transfer enable<br/>
0 Standard digital pad<br/>
1 Pad in analog mode (digital GPIO input and output disabled)<br/>
6 GPIO3_INV 0x00 R/W Invert output enable<br/>
0 Invert output disabled<br/>
1 Invert output enable<br/>
5:0 GPIO3_CFG 0x06 R/W Output selection<br/>
Default: PKT_SYNC_RXTX<br/>
IOCFG2 - GPIO2 Pin Configuration<br/>
Bit # Name Reset R/W Description<br/>
7 GPIO2_ATRAN 0x00 R/W Analog transfer enable. Refer to IOCFG3<br/>
6 GPIO2_INV 0x00 R/W Invert output enable. Refer to IOCFG3<br/>
5:0 GPIO2_CFG 0x07 R/W Output selection<br/>
Default: PKT_CRC_OK<br/>
IOCFG1 - GPIO1 Pin Configuration<br/>
Bit # Name Reset R/W Description<br/>
7 GPIO1_ATRAN 0x00 R/W Analog transfer enable. Refer to IOCFG3<br/>
6 GPIO1_INV 0x00 R/W Invert output enable. Refer to IOCFG3<br/>
5:0 GPIO1_CFG 0x30 R/W Output selection<br/>
Default: HIGHZ<br/>
Note that GPIO1 is shared with the SPI and act as SO when CSn is asserted (active low).<br/>
The system must ensure pull up/down on this pin<br/>
IOCFG0 - GPIO0 Pin Configuration<br/>
Bit # Name Reset R/W Description<br/>
7 GPIO0_ATRAN 0x00 R/W Analog transfer enable. Refer to IOCFG3<br/>
6 GPIO0_INV 0x00 R/W Invert output enable. Refer to IOCFG3<br/>
5:0 GPIO0_CFG 0x3C R/W Output selection<br/>
Default: EXT_OSC_EN<br/>
SYNC3 - Sync Word Configuration [31:24]<br/>
Bit # Name Reset R/W Description<br/>
7:0 SYNC31_24 0x93 R/W Sync word [31:24]<br/>
SYNC2 - Sync Word Configuration [23:16]<br/>
Bit # Name Reset R/W Description<br/>
7:0 SYNC23_16 0x0B R/W Sync word [23:16]<br/>
SYNC1 - Sync Word Configuration [15:8]<br/>
Bit # Name Reset R/W Description<br/>
7:0 SYNC15_8 0x51 R/W Sync word [15:8]<br/>
SYNC0 - Sync Word Configuration [7:0]<br/>
Bit # Name Reset R/W Description<br/>
7:0 SYNC7_0 0xDE R/W Sync word [7:0]<br/>
SWRU346B Page 80 of 114CC120X<br/>
SYNC_CFG1 - Sync Word Configuration Reg. 1<br/>
Bit # Name Reset R/W Description<br/>
7:5 SYNC_MODE 0x05 R/W Sync word configuration. When SYNC_MODE = 0, all samples (noise or data)<br/>
received after RX mode is entered will either be put in the RX FIFO or output on a<br/>
GPIO configured as SERIAL_RX. Note that when 4&#x27;ary modulation is used the<br/>
sync word uses 2&#x27;ary modulation (the symbol rate is kept the same)<br/>
000 No sync word<br/>
001 11 bits [SYNC15_8[2:0]:SYNC7_0]<br/>
010 16 bits [SYNC15_8: SYNC7_0]<br/>
011 18 bits [SYNC23_16[1:0]: SYNC15_8: SYNC7_0]<br/>
100 24 bits [SYNC23_16: SYNC15_8: SYNC7_0]<br/>
101 32 bits [SYNC31_24: SYNC23_16: SYNC15_8: SYNC7_0]<br/>
110 16H bits [SYNC31_24: SYNC23_16]<br/>
111 16D bits (DualSync search). When this setting is used in TX mode<br/>
[SYNC15_8:SYNC7_0] is transmitted<br/>
4:0 SYNC_THR 0x0A R/W Soft decision sync word threshold. A sync word is accepted when the calculated<br/>
sync word qualifier value (PQT_SYNC_ERR.SYNC_ERROR) is less than<br/>
SYNC_THR/2). A low threshold value means a strict sync word qualifier (sync word<br/>
must be of high quality to be accepted) while a high threshold value will accept<br/>
sync word of a poorer quality (increased probability of detecting ‘false’ sync<br/>
words)<br/>
SYNC_CFG0 - Sync Word Configuration Reg. 0<br/>
Bit # Name Reset R/W Description<br/>
7:6 SYNC_CFG0_NOT_USED 0x00 R<br/>
5 AUTO_CLEAR 0x00 R/W Auto clear enable<br/>
Auto clear of symbol rate offset estimate when TOC_CFG.TOC_LIMIT ≠ 0 and<br/>
MDMCFG1.CARRIER_SENSE_GATE = 1. The symbol rate offset estimate will be<br/>
cleared when CARRIER_SENSE is de-asserted.<br/>
Auto clear of IQIC coefficient when IQIC.IQIC_EN = 1. The receiver image<br/>
compensation coefficient is cleared when the image signal dissappears<br/>
0 Auto clear disabled<br/>
1 Auto clear enabled<br/>
4 RX_CONFIG_LIMITATION 0x00 R/W Receiver configuration limitation. The decimation factor is given by<br/>
CHAN_BW.ADC_CIC_DECFACT.<br/>
When this bit is set, RX filter BW must be less than 1500 kHz.<br/>
When RX_CONFIG_LIMITATION = 1 the AGC_CFG1.AGC_WIN_SIZE should<br/>
be incremented by 1 and the wait time between AGC gain adjustment<br/>
programmed through AGC_CFG1.AGC_SETTLE_WAIT should be doubled<br/>
0 RX Filter BW f<br/>
Symbol Rate xosc [Hz]<br/>
2 Decimation Factor CHAN_BW.BB_CIC_DECFACT 4<br/>
1 f<br/>
Symbol Rate RX Filter BW xosc [Hz]<br/>
Decimation Factor CHAN_BW.BB_CIC_DECFACT 2<br/>
3 PQT_GATING_EN 0x00 R/W PQT gating enable<br/>
0 PQT gating disabled<br/>
1 PQT gating enabled. The demodulator will not start to look for a sync<br/>
word before a preamble is detected (i.e. PQT_REACHED is asserted). The<br/>
preamble detector must be enabled for this feature to work<br/>
(PREAMBLE_CFG0.PQT_EN = 1)<br/>
2 EXT_SYNC_DETECT 0x00 R/W External sync detect can be used in blind mode to make the receiver change<br/>
modem parameters after a sync word has been detected by the MCU. GPIO2<br/>
needs to be configured as SYNC_DETECT (IOCFG2.GPIO2_CFG = HIGHZ (48))<br/>
and the MCU should set this input when a sync word is detected. This will make<br/>
the receiver switch modem parameters from sync search settings to packet<br/>
receive settings similar to what is done in FIFO mode/normal mode<br/>
0 External sync detect disabled<br/>
1 External sync detect enabled<br/>
1:0 STRICT_SYNC_CHECK 0x03 R/W Strict sync word bit check. This feature is useful in cases where the sync word has<br/>
weak correlation properties (level 3 is the strictest sync check)<br/>
00 Strict sync word check level 1<br/>
01 Strict sync word check level 2<br/>
10 Strict sync word check level 3<br/>
11 Strict sync word check disabled<br/>
DEVIATION_M - Frequency Deviation Configuration<br/>
Bit # Name Reset R/W Description<br/>
7:0 DEV_M 0x06 R/W Frequency deviation (mantissa part)<br/>
Maximum fdev = ~1.2 MHz<br/>
DEV_E &gt; 0: f<br/>
f xosc (256 DEV_M) 2DEV_E [Hz]<br/>
dev 222<br/>
DEV_E = 0: f<br/>
f xosc DEV_M [Hz]<br/>
dev 221<br/>
SWRU346B Page 81 of 114CC120X<br/>
MODCFG_DEV_E - Modulation Format and Frequency Deviation Configuration<br/>
Bit # Name Reset R/W Description<br/>
7:6 MODEM_MODE 0x00 R/W Modem mode configuration<br/>
00 Normal mode<br/>
01 DSSS repeat mode. Requires that SYNC_CFG1.SYNC_MODE = 1 or<br/>
010b.<br/>
TX mode: PKT_CFG2.PKT_FORMAT = 0<br/>
RX mode: PKT_CFG2.PKT_FORMAT = 1<br/>
MDMCFG1.FIFO_EN = 0<br/>
MDMCFG0.TRANSPARENT_MODE_EN = 0<br/>
In RX mode, data is only available on GPIO by configuring<br/>
IOCFGx.GPIOx_CFG = 18<br/>
10 DSSS PN mode. Both FIFO mode and synchronous serial mode are<br/>
supported (PKT_CFG2.PKT_FORMAT = 0 or 1)<br/>
11 Carrier sense mode. This mode can be used to measure the channel<br/>
power (sync search is disabled in this mode)<br/>
5:3 MOD_FORMAT 0x00 R/W Modulation format<br/>
000 2-FSK<br/>
001 2-GFSK<br/>
010 Reserved<br/>
011 ASK/OOK<br/>
100 4-FSK<br/>
101 4-GFSK<br/>
110 Reserved<br/>
111 Reserved<br/>
2:0 DEV_E 0x03 R/W Frequency deviation (exponent part). See DEVIATION_M<br/>
DCFILT_CFG - Digital DC Removal Configuration<br/>
Bit # Name Reset R/W Description<br/>
7 DCFILT_CFG_NOT_USED 0x00 R<br/>
6 DCFILT_FREEZE_COEFF 0x01 R/W DC filter override<br/>
0 DC filter algorithm estimates and compensates for DC error<br/>
1 Manual DC compensation through registers DCFILTOFFSET_I1,<br/>
DCFILTOFFSET_I0, DCFILTOFFSET_Q1, and DCFILTOFFSET_Q0<br/>
5:3 DCFILT_BW_SETTLE 0x01 R/W Settling period of high pass DC filter after AGC adjustment<br/>
f<br/>
Sample Rate XOSC [Hz]<br/>
Decimation Factor<br/>
The decimation factor is 12, 24, or 48, depending on the<br/>
CHAN_BW.ADC_CIC_DECFACT setting<br/>
000 8 samples<br/>
001 16 samples<br/>
010 32 samples<br/>
011 64 samples<br/>
100 128 samples<br/>
101 128 samples<br/>
110 128 samples<br/>
111 128 samples<br/>
2:0 DCFILT_BW 0x04 R/W Cut-off frequency (fCut-Off ) of high pass DC filter<br/>
DCFILT_BW = 0 - 011b:<br/>
f<br/>
f DC Filter~ XOSC [Hz]<br/>
Cutt-Off Decimation Factor 2(DCFILT_BW 3)<br/>
DCFILT_BW = 110b - 111b:<br/>
f<br/>
f DC Filter~ XOSC [Hz]<br/>
Cutt-Off Decimation Factor 2(2DCFILT_BW)<br/>
The decimation factor is 12, 24, or 48, depending on the<br/>
CHAN_BW.ADC_CIC_DECFACT setting<br/>
SWRU346B Page 82 of 114CC120X<br/>
PREAMBLE_CFG1 - Preamble Configuration Reg. 1<br/>
Bit # Name Reset R/W Description<br/>
7:6 PREAMBLE_CFG1_NOT_USED 0x00 R<br/>
5:2 NUM_PREAMBLE 0x05 R/W Sets the minimum number of preamble bits to be transmitted<br/>
0000 No preamble<br/>
0001 0.5 byte<br/>
0010 1 byte<br/>
0011 1.5 bytes<br/>
0100 2 bytes<br/>
0101 3 bytes<br/>
0110 4 bytes<br/>
0111 5 bytes<br/>
1000 6 bytes<br/>
1001 7 bytes<br/>
1010 8 bytes<br/>
1011 12 bytes<br/>
1100 24 bytes<br/>
1101 30 bytes<br/>
1110 Reserved<br/>
1111 Reserved<br/>
1:0 PREAMBLE_WORD 0x00 R/W Preamble byte configuration. PREAMBLE_WORD determines how a preamble<br/>
byte looks like. Note that when 4&#x27;ary modulation is used the preamble uses<br/>
2&#x27;are modulation (the symbol rate is kept the same)<br/>
00 10101010 (0xAA)<br/>
01 01010101 (0x55)<br/>
10 00110011 (0x33)<br/>
11 11001100 (0xCC)<br/>
PREAMBLE_CFG0 - Preamble Configuration Reg. 0<br/>
Bit # Name Reset R/W Description<br/>
7 PQT_EN 0x01 R/W Preamble detection enable<br/>
0 Preamble detection disabled<br/>
1 Preamble detection enabled<br/>
6:4 PQT_VALID_TIMEOUT 0x05 R/W PQT start-up timer. PQT_VALID_TIMEOUT sets the number of symbols that<br/>
must be received before PQT_VALID is asserted<br/>
000 11 symbols<br/>
001 12 symbols<br/>
010 13 symbols<br/>
011 15 symbols<br/>
100 16 symbols<br/>
101 17 symbols<br/>
110 24 symbols<br/>
111 32 symbols<br/>
3:0 PQT 0x0A R/W Soft decision PQT. A preamble is detected when the calculated preamble<br/>
qualifier value (PQT_SYNC_ERR.PQT_ERROR) is less than PQT. A low<br/>
threshold value means a strict preamble qualifier (preamble must be of high<br/>
quality to be accepted) while a high threshold value will accept preamble of a<br/>
poorer quality (increased probability of detecting ‘false’ preamble)<br/>
SWRU346B Page 83 of 114CC120X<br/>
IQIC - Digital Image Channel Compensation Configuration<br/>
Bit # Name Reset R/W Description<br/>
7 IQIC_EN 0x01 R/W IQ image compensation enable. When this bit is set the following must be true:<br/>
fIF &gt; RX filter BW<br/>
(see IF_MIX_CFGCMIX_CFG for how to program fIF)<br/>
0 IQ image compensation disabled<br/>
1 IQ image compensation enabled<br/>
6 IQIC_UPDATE_COEFF_EN 0x01 R/W IQIC update coefficients enable<br/>
0 IQIC update coefficient disabled (IQIE_I1, IQIE_I0, IQIE_Q1,<br/>
and IQIE_Q0 registers are not updated)<br/>
1 IQIC update coefficients enabled (IQIE_I1, IQIE_I0, IQIE_Q1,<br/>
and IQIE_Q0 registers are updated)<br/>
5:4 IQIC_BLEN_SETTLE 0x00 R/W IQIC block length when settling. The IQIC module will do a coarse estimation of<br/>
IQ imbalance coefficients during settling mode. Long block length increases<br/>
settling time and improves image rejection<br/>
00 8 samples<br/>
01 32 samples<br/>
10 128 samples<br/>
11 256 samples<br/>
3:2 IQIC_BLEN 0x01 R/W IQIC block length. Long block length increases settling time and improves image<br/>
rejection<br/>
00 8 samples<br/>
01 32 samples<br/>
10 128 samples<br/>
11 256 samples<br/>
1:0 IQIC_IMGCH_LEVEL_THR 0x00 R/W IQIC image channel level threshold. Image rejection will be activated when image<br/>
carrier is present. The IQIC image channel level threshold is an image carrier<br/>
detector. High threshold imply that image carrier must be high to enable IQIC<br/>
compensation module<br/>
00 &gt; 256<br/>
01 &gt; 512<br/>
10 &gt; 1024<br/>
11 &gt; 2048<br/>
CHAN_BW - Channel Filter Configuration<br/>
Bit # Name Reset R/W Description<br/>
7:6 ADC_CIC_DECFACT 0x02 R/W ADC_CIC_DECFACT is a table index which programs the first decimation filter and<br/>
program the RX filter bandwidth. ADC_CIC_DECFACT table index:<br/>
00 Decimation factor 12<br/>
01 Decimation factor 24<br/>
10 Decimation factor 48<br/>
11 Reserved<br/>
5:0 BB_CIC_DECFACT 0x14 R/W BB_CIC_DECFACT configures the RX filter BW by changing decimation factor in<br/>
the second decimation filter<br/>
Device ADC_CIC_DECFACT BB_CIC_DECFACT RX Filter BW<br/>
Range [kHz]<br/>
CC1200 12 1 - 44 37.9 - 1666.7<br/>
CC1200 24 1 - 44 18.9 - 833.3<br/>
CC1200 48 1 - 44 9.5 - 416.7<br/>
CC1201 12 1 - 33 50.5 - 1666.7<br/>
CC1201 24 1 - 16 52.1 - 833.3<br/>
CC1201 48 1 - 8 52.1 - 416.7<br/>
SWRU346B Page 84 of 114CC120X<br/>
MDMCFG2 - General Modem Parameter Configuration Reg. 2<br/>
Bit # Name Reset R/W Description<br/>
7:6 ASK_SHAPE 0x00 R/W Sets the resolution of an ASK bit transition (# of points). The following rule must<br/>
be satisfied:<br/>
ASK_SHAPE &lt; 3:<br/>
MDMCFG2.UPSAMPLER_P ≥ 4 - PA_CFG0.RAMP_SHAPE + ASK_SHAPE<br/>
ASK_SHAPE = 3:<br/>
MDMCFG2.UPSAMPLER_P ≥ 5 - PA_CFG0.RAMP_SHAPE + ASK_SHAPE<br/>
00 8<br/>
01 16<br/>
10 32<br/>
11 128<br/>
5:4 SYMBOL_MAP_CFG 0x00 R/W Symbol map configuration. Configures the modulated symbol mapping<br/>
definition from data bit to modulated symbols.<br/>
For 2&#x27;ary modulation schemes the symbol mapping definition is as follows:<br/>
SYMBOL_MAP_CFG<br/>
Data bit 00 01 10 11<br/>
0 −Dev [AMIN] Dev [AMAX] Dev [AMAX] Dev [AMAX]<br/>
1 Dev [AMAX] −Dev [AMIN] −Dev [AMIN] −Dev [AMIN]<br/>
OOK/ASK: AMAX = Maximum amplitude, AMIN = Minimum amplitude<br/>
For 4&#x27;ary modulation schemes the symbol mapping definition is as follows:<br/>
SYMBOL_MAP_CFG<br/>
Data bit 00 01 10 11<br/>
00 −Dev/3 −Dev Dev/3 Dev<br/>
01 −Dev −Dev/3 Dev Dev/3<br/>
10 Dev/3 Dev −Dev/3 −Dev<br/>
11 Dev Dev/3 −Dev −Dev/3<br/>
3:1 UPSAMPLER_P 0x04 R/W UPSAMPLER_P configures the variable upsampling factor P for the TX<br/>
upsampler. The total upsampling factor = 16∙P. The upsampler factor P must<br/>
satisfy the following:<br/>
f<br/>
Symbol Rate 16 P XOSC , where P should be as large as possible<br/>
4<br/>
The upsampler reduces repetitive spectrum at 16·symbol rate<br/>
000 TX upsampler factor P = 1 (bypassed)<br/>
001 TX upsampler factor P = 2<br/>
010 TX upsampler factor P = 4<br/>
011 TX upsample factor P = 8<br/>
100 TX upsampler Factor P = 16<br/>
101 TX upsampler Factor P = 32<br/>
110 TX upsampler Factor P = 64<br/>
111 Not used<br/>
0 CFM_DATA_EN 0x00 R/W Custom frequency modulation enable<br/>
0 CFM mode disabled<br/>
1 CFM mode enabled (write frequency word directly)<br/>
SWRU346B Page 85 of 114CC120X<br/>
MDMCFG1 - General Modem Parameter Configuration Reg. 1<br/>
Bit # Name Reset R/W Description<br/>
7 CARRIER_SENSE_GATE 0x00 R/W When CARRIER_SENSE_GATE is 1, the demodulator will not start to look for a<br/>
sync word before CARRIER_SENSE is asserted<br/>
0 Search for sync word regardless of CS<br/>
1 Do not start sync search before CARRIER_SENSE is asserted<br/>
6 FIFO_EN 0x01 R/W FIFO enable. Specifies if data to/from modem will be passed through the FIFOs or<br/>
directly to the serial pin<br/>
0 Data in/out through the serial pin(s) (the FIFOs are bypassed)<br/>
1 Data in/out through the FIFOs<br/>
5 MANCHESTER_EN 0x00 R/W Manchester mode enable. Manchester encoding/decoding is only applicable to<br/>
payload data including optional CRC. Manchester encoding/decoding is not<br/>
supported for 4-(G)FSK<br/>
0 NRZ<br/>
1 Manchester encoding/decoding<br/>
4 INVERT_DATA_EN 0x00 R/W Invert data enable. Invert payload data stream in RX and TX (only applicable to<br/>
payload data including optional CRC)<br/>
0 Invert data disabled<br/>
1 Invert data enabled<br/>
3 COLLISION_DETECT_EN 0x00 R/W Collision detect enable. After a sync word is detected (SYNC_EVENT asserted),<br/>
the receiver will always receive a packet. If collision detection is enabled, the<br/>
receiver will continue to search for preamble. If a new preamble is found<br/>
(PQT_REACHED asserted) and the RSSI has increased 10 or 16 dB during packet<br/>
reception (depending on AGC_CFG1.RSSI_STEP_THR) a collision is detected and<br/>
the COLLISION_FOUND flag will be asserted<br/>
0 Collision detect disabled<br/>
1 Collision detect enabled<br/>
2:1 DVGA_GAIN 0x03 R/W Fixed DVGA gain configuration. The DVGA configuration has impact on the RSSI<br/>
offset<br/>
00 0 dB DVGA (preferred setting for RX filter bandwidth &lt; 100 kHz)<br/>
01 -18 dB DVGA (preferred setting for RX filter bandwidth ≥ 100 kHz)<br/>
10 Reserved<br/>
11 Reserved<br/>
0 SINGLE_ADC_EN 0x00 R/W Configure the number of active receive channels. If this bit is set the power<br/>
consumption will be reduced but the sensitivity level will be reduced by ~3 dB.<br/>
Image rejection will not work<br/>
0 IQ-channels<br/>
1 Only I-channel<br/>
SWRU346B Page 86 of 114CC120X<br/>
MDMCFG0 - General Modem Parameter Configuration Reg. 0<br/>
Bit # Name Reset R/W Description<br/>
7 MDMCFG0_RESERVED7 0x00 R/W For test purposes only, use values from SmartRF Studio<br/>
6 TRANSPARENT_MODE_EN 0x00 R/W Transparent mode enable<br/>
0 Transparent mode disabled<br/>
1 Transparent mode enabled<br/>
5:4 TRANSPARENT_INTFACT 0x00 R/W Transparent signal interpolation factor. The sample rate gives the jitter of the<br/>
samples and the sample rate is given by<br/>
Sample Rate<br/>
f<br/>
XOSC<br/>
Interpolation Factor<br/>
[Hz]<br/>
Decimation Factor CHAN_BW.BB_CIC_DECFACT<br/>
The decimation factor is given by CHAN_BW.ADC_CIC_DECFACT while the<br/>
interpolation factor is given below<br/>
00 1x transparent signal interpolated one time before output (reset)<br/>
01 2x transparent signal interpolated two times before output<br/>
10 4x transparent signal interpolated four times before output<br/>
11 Reserved<br/>
3 DATA_FILTER_EN 0x01 R/W Transparent data filter and extended data filter enable. Enabling transparent<br/>
data filter and/or extended data filter might improve sensitivity.<br/>
When TRANSPARENT_MODE_EN = 0 this bit should only be set when RX<br/>
filter bandwidth/symbol rate &gt; 10 and TOC_CFG.TOC_LIMIT = 0.<br/>
The table below shows the status of the transparent data filter and the<br/>
extended data filter for all combinations of TRANSPARENT_MODE_EN (MSB)<br/>
and DATA_FILTER_EN (LSB)<br/>
00 Transparent data filter disabled and extended data filter disabled<br/>
01 Transparent data filter disabled and extended data filter enabled<br/>
10 Transparent data filter disabled and extended data filter disabled<br/>
11 Transparent data filter enabled and extended data filter disabled<br/>
2 VITERBI_EN 0x01 R/W Viterbi detection enable. Enabling Viterbi detection improves the sensitivity.<br/>
The latency from the antenna to the signal is available in the RXFIFO or on<br/>
the GPIO is increased by 5 bits for 2-ary modulation formats and 10 bits for<br/>
4-ary modulation formats. Minimum packet length = 2 bytes when Viterbi<br/>
detection and 4-(G)FSK is enabled<br/>
0 Viterbi detection disabled<br/>
1 Viterbi detection enabled<br/>
1:0 MDMCFG0_RESERVED1_0 0x01 R/W For test purposes only, use values from SmartRF Studio<br/>
SWRU346B Page 87 of 114CC120X<br/>
SYMBOL_RATE2 - Symbol Rate Configuration Exponent and Mantissa [19:16]<br/>
Bit # Name Reset R/W Description<br/>
7:4 SRATE_E 0x04 R/W Symbol rate (exponent part)<br/>
(220 SRATE_M) 2SRATE_E<br/>
SRATE_E &gt; 0: R f [ksps]<br/>
Symbol 239 XOSC<br/>
SRATE_E = 0: R SRATE_M f [ksps]<br/>
Symbol 238 XOSC<br/>
Modulation format / Data rate/symbol rate ratio<br/>
data encoding<br/>
2-(G)FSK 1<br/>
4-(G)FSK 2<br/>
Manchester mode 0.5<br/>
DSSS mode 1/spreading factor<br/>
FEC 0.5<br/>
3:0 SRATE_M_19_16 0x03 R/W Symbol rate (mantissa part [19:16]). See SRATE_E<br/>
SYMBOL_RATE1- Symbol Rate Configuration Exponent and Mantissa [15:8]<br/>
Bit # Name Reset R/W Description<br/>
7:0 SRATE_M_15_8 0xA9 R/W Symbol rate (mantissa part [15:8]). See SYMBOL_RATE2<br/>
SYMBOL_RATE0 - Symbol Rate Configuration Exponent and Mantissa [7:0]<br/>
Bit # Name Reset R/W Description<br/>
7:0 SRATE_M_7_0 0x2A R/W Symbol rate (mantissa part [7:0]). See SYMBOL_RATE2<br/>
AGC_REF - AGC Reference Level Configuration<br/>
Bit # Name Reset R/W Description<br/>
7:0 AGC_REFERENCE 0x36 R/W AGC reference level. The AGC reference level must be higher than the minimum SNR<br/>
to the demodulator. The AGC reduces the analog front end gain when the magnitude<br/>
output from channel filter &gt; AGC reference level. An optimum AGC reference level is<br/>
given by several conditions, but a rule of thumb is to use the formula:<br/>
AGC_REFERENCE 10 log (RX Filter BW) 92 RSSI Offset<br/>
10<br/>
RX filter BW AGC_REFERENCE<br/>
10 kHz 0x2F (MDMCFG1.DVGA_GAIN = 0, RSSI offset ≈ −99 dB)<br/>
100 kHz 0x27 (MDMCFG1.DVGA_GAIN = 1, RSSI offset ≈ −81 dB)<br/>
200 kHz 0x2D (MDMCFG1.DVGA_GAIN = 1, RSSI offset ≈ −81 dB)<br/>
500 kHz 0x2F (MDMCFG1.DVGA_GAIN = 1, RSSI offset ≈ −81 dB)<br/>
1600 kHz 0x33 (MDMCFG1.DVGA_GAIN = 1, RSSI offset ≈ −81 dB)<br/>
For zero-IF configuration, AGC hysteresis &gt; 3 dB, or modem format which needs SNR<br/>
&gt; 15 dB a higher AGC reference value is needed.<br/>
AGC_CS_THR - Carrier Sense Threshold Configuration<br/>
Bit # Name Reset R/W Description<br/>
7:0 AGC_CS_TH 0x00 R/W AGC carrier sense threshold. Two&#x27;s complement number with 1 dB resolution<br/>
AGC_GAIN_ADJUST - RSSI Offset Configuration<br/>
Bit # Name Reset R/W Description<br/>
7:0 GAIN_ADJUSTMENT 0x00 R/W AGC gain adjustment. This register is used to adjust RSSI[11:0] to the actual carrier<br/>
input signal level to compensate for interpolation gains (two&#x27;s complement with 1 dB<br/>
resolution)<br/>
SWRU346B Page 88 of 114CC120X<br/>
AGC_CFG3 - Automatic Gain Control Configuration Reg. 3<br/>
Bit # Name Reset R/W Description<br/>
7:5 AGC_SYNC_BEHAVIOUR 0x05 R/W AGC behavior after sync word detection<br/>
000 No AGC gain freeze. Keep computing/updating RSSI<br/>
001 AGC gain freeze. Keep computing/updating RSSI<br/>
010 No AGC gain freeze. Keep computing/updating RSSI (AGC slow<br/>
mode enabled)<br/>
011 Freeze both AGC gain and RSSI<br/>
100 No AGC gain freeze. Keep computing/updating RSSI<br/>
101 Freeze both AGC gain and RSSI<br/>
110 No AGC gain freeze. Keep computing/updating RSSI (AGC slow<br/>
mode enabled)<br/>
111 Freeze both AGC gain and RSSI<br/>
4:0 AGC_MIN_GAIN 0x11 R/W AGC minimum gain. Limits the AGC minimum gain compared to the preset<br/>
gain table range. AGC_MIN_GAIN can have a value in the range<br/>
0 to 17 when AGC_CFG2.FE_PERFORMANCE_MODE = 0 or 1,<br/>
0 to 13 when AGC_CFG2.FE_PERFORMANCE_MODE = 10b and<br/>
0 to 7 when AGC_CFG2.FE_PERFORMANCE_MODE = 11b<br/>
AGC_CFG2 - Automatic Gain Control Configuration Reg. 2<br/>
Bit # Name Reset R/W Description<br/>
7 START_PREVIOUS_GAIN_EN 0x00 R/W 0 Receiver starts with maximum gain value<br/>
1 Receiver starts from previous gain value<br/>
6:5 FE_PERFORMANCE_MODE 0x01 R/W Controls which gain tables to be applied<br/>
00 Optimized linearity mode<br/>
01 Normal operation mode<br/>
10 Low power mode with reduced gain range<br/>
11 Zero-IF mode<br/>
4:0 AGC_MAX_GAIN 0x00 R/W AGC maximum gain. Limits the AGC maximum gain compared to the preset<br/>
gain table range. AGC_MAX_GAIN can have a value in the range<br/>
0 to 17 when AGC_CFG2.FE_PERFORMANCE_MODE = 0 or 1,<br/>
0 to 13 when AGC_CFG2.FE_PERFORMANCE_MODE = 10b and<br/>
0 to 7 when AGC_CFG2.FE_PERFORMANCE_MODE = 11b<br/>
AGC_CFG1 - Automatic Gain Control Configuration Reg. 1<br/>
Bit # Name Reset R/W Description<br/>
7 AGC_CFG1_NOT_USED 0x00 R/W<br/>
6 RSSI_STEP_THR 0x01 R/W AGC has a built in function to signal if there has been a step in the RSSI<br/>
value. During sync search the difference between the current and the<br/>
previous RSSI value is compared against the RSSI step (3 or 6 dB), while<br/>
during packet reception, the difference between the current value and the<br/>
value at sync found is compared against 10 or 16 dB<br/>
0 RSSI step is 3 dB during sync search<br/>
RSSI step is 10 dB during packet reception<br/>
1 RSSI step is 6 dB during sync search<br/>
RSSI step is 16 dB during packet reception<br/>
5:3 AGC_WIN_SIZE 0x02 R/W AGC integration window size for each value. Samples refer to the RX filter<br/>
sampling frequency, which is programmed to be 4 times the desired RX filter<br/>
BW<br/>
000 8 samples<br/>
001 16 samples<br/>
010 32 samples<br/>
011 64 samples<br/>
100 128 samples<br/>
101 256 samples<br/>
110 Reserved<br/>
111 Reserved<br/>
2:0 AGC_SETTLE_WAIT 0x02 R/W Sets the wait time between AGC gain adjustments<br/>
000 24 samples<br/>
001 32 samples<br/>
010 40 samples<br/>
011 48 samples<br/>
100 64 samples<br/>
101 80 samples<br/>
110 96 samples<br/>
111 127 samples<br/>
SWRU346B Page 89 of 114CC120X<br/>
AGC_CFG0 - Automatic Gain Control Configuration Reg. 0<br/>
Bit # Name Reset R/W Description<br/>
7:6 AGC_HYST_LEVEL 0x03 R/W AGC hysteresis level. The difference between the desired signal level and the<br/>
actual signal level must be larger than AGC hysteresis level before the AGC<br/>
changes the front end gain<br/>
00 2 dB<br/>
01 4 dB<br/>
10 7 dB<br/>
11 10 dB<br/>
5:4 AGC_SLEWRATE_LIMIT 0x00 R/W AGC slew rate limit. Limits the maximum front end gain adjustment<br/>
00 60 dB<br/>
01 30 dB<br/>
10 18 dB<br/>
11 9 dB<br/>
3:2 RSSI_VALID_CNT 0x00 R/W Gives the number of new input samples to the moving average filter (internal<br/>
RSSI estimates) that are required before the next update of the RSSI value.<br/>
The RSSI_VALID signal will be asserted from the first RSSI update.<br/>
RSSI_VALIDis available on a GPIO or can be read from the RSSI0 register<br/>
00 1<br/>
01 2<br/>
10 5<br/>
11 9<br/>
1:0 AGC_ASK_DECAY 0x03 R/W The OOK/ASK receiver uses a max peak magnitude (logic 1) tracker and low<br/>
peak magnitude (logic 0) tracker to estimate ASK_THRESHOLD (decision<br/>
level) as the average of the max and min value. The max peak magnitude value<br/>
is also used by the AGC to set the gain. AGC_ASK_DECAY controls the max<br/>
peak magnitude decay steps in OOK/ASK mode and defines the number of<br/>
samples required for the max peak level to be reduced to 10% when receiving<br/>
logic 0’s after receiving a logic 1.<br/>
f Interpolation Factor<br/>
SampleRate XOSC [Hz]<br/>
Decimation Factor CHAN_BW.BB_CIC_DECFACT<br/>
The decimation factor is given by CHAN_BW.ADC_CIC_DECFACT and the<br/>
interpolation factor is given by SYNC_CFG0.RX_CONFIG_LIMITATION as<br/>
follows:<br/>
RX_CONFIG_LIMITATION = 0: Int. factor = 2<br/>
RX_CONFIG_LIMITATION = 1: Int. factor = 4<br/>
00 1200 samples<br/>
01 2400 samples<br/>
10 4700 samples<br/>
11 9500 samples<br/>
FIFO_CFG - FIFO Configuration<br/>
Bit # Name Reset R/W Description<br/>
7 CRC_AUTOFLUSH 0x01 R/W Automatically flushes the last packet received in the RX FIFO if a CRC error<br/>
occurred. If this bit has been turned off and should be turned on again, an SFRX<br/>
strobe must first be issued<br/>
6:0 FIFO_THR 0x00 R/W Threshold value for the RX and TX FIFO. The threshold value is coded in<br/>
opposite directions for the two FIFOs to give equal margin to the overflow and<br/>
underflow conditions when the threshold is reached. I.e.; FIFO_THR = 0<br/>
means that there are 127 bytes in the TX FIFO and 1 byte in the RX FIFO,<br/>
while FIFO_THR = 127 means that there are 0 bytes in the TX FIFO and 128<br/>
bytes in the RX FIFO when the thresholds are reached<br/>
DEV_ADDR - Device Address Configuration<br/>
Bit # Name Reset R/W Description<br/>
7:0 DEVICE_ADDR 0x00 R/W Address used for packet filtering in RX<br/>
SWRU346B Page 90 of 114CC120X<br/>
SETTLING_CFG - Frequency Synthesizer Calibration and Settling Configuration<br/>
Bit # Name Reset R/W Description<br/>
7:5 SETTLING_CFG_NOT_USED 0x00 R<br/>
4:3 FS_AUTOCAL 0x01 R/W Auto calibration is performed:<br/>
00 Never (manually calibrate using SCAL strobe)<br/>
01 When going from IDLE to RX or TX (or FSTXON)<br/>
10 When going from RX or TX back to IDLE automatically<br/>
11 Every 4th time when going from RX or TX to IDLE automatically<br/>
2:1 LOCK_TIME 0x01 R/W Sets the time for the frequency synthesizer to settle to lock state. The table<br/>
shows settling after calibration and settling when switching between TX and<br/>
RX. Use values from SmartRF Studio<br/>
00 50/20 µs<br/>
01 75/30 µs<br/>
10 100/40 µs<br/>
11 150/60 µs<br/>
0 FSREG_TIME 0x01 R/W Frequency synthesizer regulator settling time. Use values from SmartRF Studio<br/>
0 30 µs<br/>
1 60 µs<br/>
FS_CFG - Frequency Synthesizer Configuration<br/>
Bit # Name Reset R/W Description<br/>
7:5 FS_CFG_NOT_USED 0x00 R<br/>
4 FS_LOCK_EN 0x00 R/W Out of lock detector enable<br/>
0 Out of lock detector disabled<br/>
1 Out of lock detector enabled<br/>
3:0 FSD_BANDSELECT 0x02 R/W Band select setting for LO divider<br/>
0000 Not in use<br/>
0001 Not in use<br/>
0010 820.0 - 960.0 MHz band (LO divider = 4)<br/>
0011 Not in use<br/>
0100 410.0 - 480.0 MHz band (LO divider = 8)<br/>
0101 Not in use<br/>
0110 273.3 - 320.0 MHz band (LO divider = 12)<br/>
0111 Not in use<br/>
1000 205.0 - 240.0 MHz band (LO divider = 16)<br/>
1001 Not in use<br/>
1010 164.0 - 192.0 MHz band (LO divider = 20)<br/>
1011 136.7 - 160.0 MHz band (LO divider = 24)<br/>
1100 - Not in use<br/>
1111<br/>
SWRU346B Page 91 of 114CC120X<br/>
WOR_CFG1 - eWOR Configuration Reg. 1<br/>
Bit # Name Reset R/W Description<br/>
7:6 WOR_RES 0x00 R/W eWOR timer resolution. Controls the tEvent0 and RX timeout resolution<br/>
t<br/>
1<br/>
EVENT0 25*WOR_RES [s]<br/>
Event0 f<br/>
RCOSC<br/>
and<br/>
RX Timeout MAX 1,FLOOR<br/>
EVENT0<br/>
24WOR_RES<br/>
1250<br/>
[s]<br/>
2RFEND_CFG1.RX_TIME3 f<br/>
XOSC<br/>
00 High resolution<br/>
01 Medium high resolution<br/>
10 Medium low resolution<br/>
11 Low resolution<br/>
5:3 WOR_MODE 0x01 R/W eWOR mode<br/>
000 Feedback mode<br/>
001 Normal mode<br/>
010 Legacy mode<br/>
011 Event1 mask mode<br/>
100 Event0 mask mode<br/>
101 - 111 Reserved<br/>
2:0 EVENT1 0x00 R/W Event 1 timeout<br/>
1<br/>
t WOR_EVENT1 [s]<br/>
Event1 f<br/>
RCOSC<br/>
EVENT1 WOR_EVENT1<br/>
000 4<br/>
001 6<br/>
010 8<br/>
011 12<br/>
100 16<br/>
101 24<br/>
110 32<br/>
111 48<br/>
WOR_CFG0 - eWOR Configuration Reg. 0<br/>
Bit # Name Reset R/W Description<br/>
7:6 RX_DUTY_CYCLE_MODE 0x00 R RX duty cycle mode configuration. eWOR mode and RXDCM cannot be enabled<br/>
at the same time. Both modes can be used in RX Sniff mode implementation<br/>
00 RXDCM disabled<br/>
01 RXDCM 0<br/>
10 RXDCM 1<br/>
11 RXDCM 2<br/>
5 DIV_256HZ_EN 0x01 R/W Clock division enable. Enables clock division in SLEEP mode<br/>
0 Clock division disabled<br/>
1 Clock division enabled<br/>
Setting DIV_256HZ_EN = 1 will lower the current consumption in SLEEP mode.<br/>
Note that when this bit is set the radio should not be woken from SLEEP by<br/>
pulling CSn low.<br/>
4:3 EVENT2_CFG 0x00 R/W Event 2 timeout<br/>
2WOR_EVENT2<br/>
t [s]<br/>
Event2 f<br/>
RCOSC<br/>
EVENT2_CFG WOR_EVENT2<br/>
00 Disabled<br/>
01 15<br/>
10 18<br/>
11 21<br/>
2:1 RC_MODE 0x00 R/W RCOSC calibration mode. Configures when the RCOSC calibration sequence is<br/>
performed. If calibration is enabled, WOR_CFG0.RC_PD must be 0<br/>
00 RCOSC calibration disabled<br/>
01 RCOSC calibration disabled<br/>
10 RCOSC calibration enabled<br/>
11 RCOSC calibration is enabled on every 4th time the device is<br/>
powered up and goes from IDLE to RX. This setting should only<br/>
be used together with eWOR<br/>
0 RC_PD 0x01 R/W RCOSC power down signal<br/>
0 RCOSC is running<br/>
1 RCOSC is in power down<br/>
SWRU346B Page 92 of 114CC120X<br/>
WOR_EVENT0_MSB - Event 0 Configuration MSB<br/>
Bit # Name Reset R/W Description<br/>
7:0 EVENT0_15_8 0x00 R/W Event 0 timeout (MSB)<br/>
t<br/>
1<br/>
EVENT0 25*WOR_CFG1.WOR_RES [s]<br/>
Event0 f<br/>
RCOSC<br/>
WOR_EVENT0_LSB - Event 0 Configuration LSB<br/>
Bit # Name Reset R/W Description<br/>
7:0 EVENT0_7_0 0x00 R/W Event 0 timeout (LSB). See WOR_EVENT0_MSB<br/>
RXDCM_TIME - RX Duty Cycle Mode Configuration<br/>
Bit # Name Reset R/W Description<br/>
7:0 RX_DUTY_CYCLE_TIME 0x00 R/W Configures the time spent in RXDCM state<br/>
RX_DUTY_CYCLE_TIME = 0:<br/>
t 2WOR_CFG1.WOR_RES[µs]<br/>
RXDCM<br/>
RX_DUTY_CYCLE_TIME ≠ 0:<br/>
t RX_DUTY_CYCLE_TIME 2WOR_CFG1.WOR_RES [µs]<br/>
RXDCM<br/>
PKT_CFG2 - Packet Configuration Reg. 2<br/>
Bit # Name Reset R/W Description<br/>
7 PKT_CFG2_NOT_USED 0x00 R<br/>
6 BYTE_SWAP_EN 0x00 R/W TX/RX data byte swap enable. In RX, all bits in the received data byte are<br/>
swapped before written to the RX FIFO. In TX, all bits in the TX FIFO data byte<br/>
are swapped before being transmitted<br/>
0 Data byte swap disabled<br/>
1 Data byte swap enabled<br/>
5 FG_MODE_EN 0x00 R/W Select between standard packet mode or 802.15.4g packet mode<br/>
0 Standard packet mode enabled<br/>
1 802.15.4g packet mode enabled (will override other packet engine<br/>
configuration settings)<br/>
4:2 CCA_MODE 0x01 R/W CCA mode. Selects the definition of a clear channel (when to assert the CCA<br/>
signal)<br/>
000 Always give a clear channel indication<br/>
001 Indicates clear channel when RSSI is below threshold<br/>
010 Indicates clear channel unless currently receiving a packet<br/>
011 Indicates clear channel when RSSI is below threshold and currently<br/>
not receiving a packet<br/>
100 Indicates clear channel when RSSI is below threshold and ETSI<br/>
LBT requirements are met<br/>
101 - 111 Reserved<br/>
1:0 PKT_FORMAT 0x00 R/W Packet format configuration<br/>
00 Normal mode/FIFO mode (MDMCFG1.FIFO_EN must be set to 1<br/>
and MDMCFG0.TRANSPARENT_MODE_EN must be set to 0)<br/>
01 Synchronous serial mode (MDMCFG1.FIFO_EN must be set to 0 and<br/>
MDMCFG0.TRANSPARENT_MODE_EN must be set to 0). This mode<br/>
is only supported for 2’ary modulations formats in TX. In RX, both<br/>
2’ary and 4’ary modulation formats are supported<br/>
10 Random mode. Send random data using PN9 generator (Set<br/>
TXLAST != TXFIRST before strobing STX)<br/>
11 Transparent serial mode (MDMCFG1.FIFO_EN must be set to 0 and<br/>
MDMCFG0.TRANSPARENT_MODE_EN must be set to 1). This mode is<br/>
only supported for 2’ary modulations formats.<br/>
SWRU346B Page 93 of 114CC120X<br/>
PKT_CFG1 - Packet Configuration Reg. 1<br/>
Bit # Name Reset R/W Description<br/>
7 FEC_EN 0x00 R/W Forward error correction enable<br/>
0 FEC disabled<br/>
1 FEC enabled<br/>
6 WHITE_DATA 0x00 R/W Whitening enable<br/>
0 Data whitening disabled<br/>
1 Data whitening enabled<br/>
5 PN9_SWAP_EN 0x00 R/W PN9 sequence swap enable Determines if the PN9 sequence is swapped prior to<br/>
whitening/de-whitening. This settings is only used when WHITE_DATA = 1 and<br/>
PKT_CFG2.FG_MODE_EN = 0<br/>
0 PN9 sequence swap disabled<br/>
1 PN9 sequence swap enabled<br/>
4:3 ADDR_CHECK_CFG 0x00 R/W Address check configuration. Controls how address check is performed in RX<br/>
mode<br/>
00 No address check<br/>
01 Address check, no broadcast<br/>
10 Address check, 0x00 broadcast<br/>
11 Address check, 0x00 and 0xFF broadcast<br/>
2:1 CRC_CFG 0x01 R/W CRC configuration<br/>
00 CRC disabled for TX and RX<br/>
01 CRC calculation in TX mode and CRC check in RX mode enabled.<br/>
CRC16(X16+X15+X2+1). Initialized to 0xFFFF<br/>
10 CRC calculation in TX mode and CRC check in RX mode enabled.<br/>
CRC16(X16+X12+X5+1). Initialized to 0x0000<br/>
11 CRC calculation in TX mode and CRC check in RX mode enabled. 1&#x27;s<br/>
complement of CRC16(X16+X12+X5+1). Initialized to 0x1D0F<br/>
0 APPEND_STATUS 0x01 R/W Append status bytes to RX FIFO. The status bytes contain info about CRC, RSSI,<br/>
and LQI. When CRC_CFG = 0, the CRC_OK field in the status byte will be 0<br/>
0 Status byte not appended<br/>
1 Status byte appended<br/>
PKT_CFG0 - Packet Configuration Reg. 0<br/>
Bit # Name Reset R/W Description<br/>
7 PKT_CFG0_RESERVED7 0x00 R/W<br/>
6:5 LENGTH_CONFIG 0x00 R/W Packet length configuration<br/>
00 Fixed packet length mode. Packet length configured through the PKT_LEN<br/>
register<br/>
01 Variable packet length mode. Packet length configured by the first byte<br/>
received after sync word<br/>
10 Infinite packet length mode<br/>
11 Variable packet length mode. Length configured by the 5 LSB of the first<br/>
byte received after sync word<br/>
4:2 PKT_BIT_LEN 0x00 R/W In fixed packet length mode this field (when not zero) indicates the number of bits<br/>
to send/receive after PKT_LEN number of bytes are sent/received. CRC is not<br/>
supported when PKT_LEN_BIT ≠ 0<br/>
1 UART_MODE_EN 0x00 R/W UART mode enable. When enabled, the packet engine will insert/remove a start<br/>
and stop bit to/from the transmitted/received bytes<br/>
0 UART mode disabled<br/>
1 UART mode enabled<br/>
0 UART_SWAP_EN 0x00 R/W Swap start and stop bits values<br/>
0 Swap disabled. Start/stop bits values are &#x27;1&#x27;/&#x27;0&#x27;<br/>
1 Swap enabled. Start/stop bits values are &#x27;0&#x27;/&#x27;1&#x27;<br/>
SWRU346B Page 94 of 114CC120X<br/>
RFEND_CFG1 - RFEND Configuration Reg. 1<br/>
Bit # Name Reset R/W Description<br/>
7:6 RFEND_CFG1_NOT_USED 0x00 R<br/>
5:4 RXOFF_MODE 0x00 R/W RXOFF mode. Determines the state the radio will enter after receiving a good<br/>
packet<br/>
00 IDLE<br/>
01 FSTXON<br/>
10 TX<br/>
11 RX<br/>
3:1 RX_TIME 0x07 R/W RX timeout for sync word search in RX<br/>
EVENT0 1250<br/>
RX Timeout MAX 1,FLOOR 24WOR_CFG1.WOR_RES [s]<br/>
2RX_TIME 3 f<br/>
XOSC<br/>
The RX timeout is disabled when RX_TIME = 111b<br/>
EVENT0 is found in the WOR_EVENT0_MSB and WOR_EVENT0_LSB registers<br/>
0 RX_TIME_QUAL 0x01 R/W RX timeout qualifier<br/>
0 Continue RX mode on RX timeout if sync word is found<br/>
1 Continue RX mode on RX timeout if sync word has been found, or if<br/>
PQT is reached or CS is asserted<br/>
RFEND_ CFG0 - RFEND Configuration Reg. 0<br/>
Bit # Name Reset R/W Description<br/>
7 RFEND_CFG0_NOT_USED 0x00 R<br/>
6 CAL_END_WAKE_UP_EN 0x00 R/W Enable additional wake-up pulses on the end of calibration. To be used<br/>
together with the MCU_WAKEUP signal (MARC_STATUS_OUT will be 0)<br/>
0 Disable additional wake-up pulse<br/>
1 Enable additional wake-up pulse<br/>
5:4 TXOFF_MODE 0x00 R/W TXOFF mode. Determines the state the radio will enter after transmitting a<br/>
packet<br/>
00 IDLE<br/>
01 FSTXON<br/>
10 TX<br/>
11 RX<br/>
3 TERM_ON_BAD_PACKET_EN 0x00 R/W Terminate on bad packet enable<br/>
0 Terminate on bad packet disabled. When a bad packet is received<br/>
(address, length, or CRC error) the radio stays in RX regardless of<br/>
the RFEND_CFG1.RXOFF_MODE<br/>
1 Terminate on bad packet enabled. RFEND_CFG1.RXOFF_MODE is<br/>
ignored and the radio enters IDLE mode (or SLEEP mode if eWOR<br/>
is used) when a bad packet has been received<br/>
2:0 ANT_DIV_RX_TERM_CFG 0x00 R/W Direct RX termination and antenna diversity configuration<br/>
000 Antenna diversity and termination based on CS/PQT are disabled<br/>
001 RX termination based on CS is enabled (Antenna diversity OFF)<br/>
010 Single-switch antenna diversity on CS enabled. One or both<br/>
antenna is CS evaluated once and RX will terminate if CS failed on<br/>
both antennas<br/>
011 Continuous-switch antenna diversity on CS enabled. Antennas are<br/>
switched until CS is asserted or RX timeout occurs (if RX timeout is<br/>
enabled)<br/>
100 RX termination based on PQT is enabled (Antenna diversity OFF).<br/>
MDMCFG1.CARRIER_SENSE_GATE must be 0 when this feature is<br/>
used<br/>
101 Single-switch antenna diversity on PQT enabled. One or both<br/>
antennas are PQT evaluated once and RX will terminate if PQT is<br/>
not reached on any of the antennas.<br/>
MDMCFG1.CARRIER_SENSE_GATE must be 0 when this feature is<br/>
used<br/>
110 Continuous-switch antenna diversity on PQT enabled. Antennas are<br/>
switched until PQT is reached or RX timeout occurs (if RX timeout is<br/>
enabled). MDMCFG1.CARRIER_SENSE_GATE must be 0 when this<br/>
feature is used<br/>
111 Reserved<br/>
SWRU346B Page 95 of 114CC120X<br/>
PA_CFG1 - Power Amplifier Configuration Reg. 1<br/>
Bit # Name Reset R/W Description<br/>
7 PA_CFG1_NOT_USED 0x00 R/W<br/>
6 PA_RAMP_SHAPE_EN 0x01 R/W PA ramping and ASK/OOK shaping enable<br/>
0 PA ramping and ASK/OOK shaping disabled<br/>
1 PA ramping and ASK/OOK shaping enabled<br/>
5:0 PA_POWER_RAMP 0x3F R/W PA power ramp target level<br/>
PA_POWER_RAMP 1<br/>
Output Power 18 [dBm]<br/>
2<br/>
PA_POWER_RAMP &gt;= 0x03 for the equation to be valid. {0x00, 0x01, 0x02} are<br/>
special power levels<br/>
PA_CFG0 - Power Amplifier Configuration Reg. 0<br/>
Bit # Name Reset R/W Description<br/>
7:5 FIRST_IPL 0x02 R/W First intermediate power level. The first intermediate power level can be<br/>
programmed within the power level range 0 - 7/16 in steps of 1/16<br/>
4:2 SECOND_IPL 0x05 R/W Second intermediate power level. The second intermediate power level can be<br/>
programmed within the power level range 8/16 - 15/16 in steps of 1/16<br/>
1:0 RAMP_SHAPE 0x02 R/W PA ramp time and ASK/OOK shape length. Note that only certain values of<br/>
MDMCFG2.UPSAMPLER_P complies with the different ASK/OOK shape lengths<br/>
00 3/8 symbol ramp time and 1/32 symbol ASK/OOK shape length<br/>
(legal UPSAMPLER_P values: 100b, 101b, and 110b)<br/>
01 3/2 symbol ramp time and 1/16 symbol ASK/OOK shape length<br/>
(legal UPSAMPLER_P values: 011b, 100b, 101b, and 110b)<br/>
10 3 symbol ramp time and 1/8 symbol ASK/OOK shape length<br/>
(legal UPSAMPLER_P values: 010b, 011b, 100b, 101b, and 110b)<br/>
11 6 symbol ramp time and 1/4 symbol ASK/OOK shape length<br/>
(legal UPSAMPLER_P values: 010b , 010b, 011b, 100b, 101b,<br/>
and 110b )<br/>
ASK_CFG - ASK Configuration<br/>
Bit # Name Reset R/W Description<br/>
7:6 AGC_ASK_BW 0x00 R/W Controls the bandwidth of the data filter in ASK/OOK mode. The -3 dB cut-off<br/>
frequency (fCut-Off) is given below<br/>
RX_CONFIG_LIMITATION = 0:<br/>
f 4 ASK BW Scale Factor RX Filter BW [Hz]<br/>
Cut Off<br/>
RX_CONFIG_LIMITATION = 1:<br/>
f 8 ASK BW Scale Factor RX Filter BW [Hz]<br/>
Cut Off<br/>
RX_CONFIG_LIMITATION is found in SYNC_CFG0<br/>
A rule of thumb is to set fCut-Off ≥ 5∙symbol rate<br/>
00 ASK BW scale factor = 0.28<br/>
01 ASK BW scale factor = 0.18<br/>
10 ASK BW scale factor = 0.15<br/>
11 ASK BW scale factor = 0.14<br/>
5:0 ASK_DEPTH 0x0F R/W ASK/OOK depth<br/>
(PA_CFG1.PA_POWER_RAMP 1)<br/>
A 18 [dBm]<br/>
MAX 2<br/>
(PA_CFG1.PA_POWER_RAMP 1 ASK_DEPTH)<br/>
A 18 [dBm]<br/>
MIN 2<br/>
Minimum PA power level is -16 dBm. PA_POWER_RAMP - ASK_DEPTH = 0x00 is<br/>
OOK off state (&lt; −50 dBm)<br/>
PKT_LEN - Packet Length Configuration<br/>
Bit # Name Reset R/W Description<br/>
7:0 PACKET_LENGTH 0x00 R/W In fixed length mode this field indicates the packet length, and a value of 0 indicates<br/>
the length to be 256 bytes. In variable length packet mode, this value indicates the<br/>
maximum allowed length packets<br/>
SWRU346B Page 96 of 114CC120X<br/>
IF_MIX_CFG - IF Mix Configuration<br/>
Bit # Name Reset R/W Description<br/>
7:5 IF_MIX_CFG_NOT_USED 0x00 R<br/>
4:2 CMIX_CFG 0x00 R/W Intermediate frequency configuration. The decimation factor is given by<br/>
CHAN_BW.ADC_CIC_DECFACT<br/>
000 Zero-IF<br/>
001<br/>
f<br/>
f<br/>
xosc [kHz]<br/>
IF Decimation Factor 4<br/>
010<br/>
f<br/>
f<br/>
xosc [kHz]<br/>
IF Decimation Factor 6<br/>
011<br/>
f<br/>
f<br/>
xosc [kHz]<br/>
IF Decimation Factor 8<br/>
100 Zero-IF<br/>
101<br/>
f<br/>
f<br/>
xosc [kHz]<br/>
IF Decimation Factor 4<br/>
110<br/>
f<br/>
f<br/>
xosc [kHz]<br/>
IF Decimation Factor 6<br/>
111<br/>
f<br/>
f<br/>
xosc [kHz]<br/>
IF Decimation Factor 8<br/>
1:0 IF_MIX_CFG_RESERVED1_0 0x00 R/W For test purposes only, use values from SmartRF Studio<br/>
FREQOFF_CFG - Frequency Offset Correction Configuration<br/>
Bit # Name Reset R/W Description<br/>
7:6 FREQOFF_CFG_NOT_USED 0x00 R<br/>
5 FOC_EN 0x01 R/W Frequency offset correction enable<br/>
0 Frequency offset correction disabled<br/>
1 Frequency offset correction enabled<br/>
4:3 FOC_CFG 0x00 R/W Frequency offset correction configuration. FOC_CFG ≠ 0 enables a narrower<br/>
RX filter BW than FOC_CFG = 0 but needs longer settle time. When FOC in FS<br/>
is enabled, the device automatically switch to &#x27;FOC after channel filter&#x27; when a<br/>
sync word is detected<br/>
00 FOC after channel filter (typical 0 - 1 preamble bytes for settling)<br/>
01 FOC in FS enabled. Loop gain factor is 1/128 (typical 2 - 4 preamble<br/>
bytes for settling)<br/>
10 FOC in FS enabled. Loop gain factor is 1/256 (typical 2 - 4 preamble<br/>
bytes for settling)<br/>
11 FOC in FS enabled. Loop gain factor is 1/512 (typical 2 - 4 preamble<br/>
bytes for settling)<br/>
2 FOC_LIMIT 0x00 R/W FOC limit. This is the maximum frequency offset correction in the frequency<br/>
synthesizer. Only valid when FOC_CFG ≠ 0<br/>
0 RX filter bandwidth/4<br/>
1 RX filter bandwidth/8<br/>
1:0 FOC_KI_FACTOR 0x00 R/W Frequency offset correction.<br/>
MDMCFG0.TRANSPARENT_MODE_EN | FOC_KI_FACTOR<br/>
000 Frequency offset compensation disabled after sync detected (typical<br/>
setting for short packets)<br/>
001 Frequency offset compensation during packet reception with loop gain<br/>
factor = 1/32 (fast loop)<br/>
010 Frequency offset compensation during packet reception with loop gain<br/>
factor = 1/64<br/>
011 Frequency offset compensation during packet reception with loop gain<br/>
factor = 1/128 (slow loop)<br/>
100 Frequency offset compensation with loop gain factor 1/128 (fast loop)<br/>
101 Frequency offset compensation with loop gain factor 1/256<br/>
110 Frequency offset compensation with loop gain factor 1/512<br/>
111 Frequency offset compensation with loop gain factor 1/1024 (slow<br/>
loop)<br/>
SWRU346B Page 97 of 114CC120X<br/>
TOC_CFG - Timing Offset Correction Configuration<br/>
Bit # Name Reset R/W Description<br/>
7:6 TOC_LIMIT 0x00 R/W Timing offset correction limit. TOC_LIMIT specifies maximum symbol rate<br/>
offset the receiver is able to handle. TOC_LIMIT ≠ 0 requires 2 - 4 bytes<br/>
preamble for symbol rate offset compensation<br/>
00 &lt; 0.2 %<br/>
01 &lt; 2 % ppm<br/>
10 Reserved<br/>
11 &lt; 12 % ppm (MDMCFG1.CARRIER_SENSE_GATE<br/>
must be set)<br/>
5:3 TOC_PRE_SYNC_BLOCKLEN 0x01 R/W When TOC_LIMIT = 0 the receiver uses a block based time offset error<br/>
calculation algorithm where the block length is configurable through register<br/>
TOC_CFG. Before a sync word is found (SYNC_EVENT is asserted) the<br/>
TOC_PRE_SYNC_BLOCKLEN sets the actual block length used for the time<br/>
offset algorithm<br/>
000 8 symbols integration window<br/>
001 16 symbols integration window<br/>
010 32 symbols integration window<br/>
011 64 symbols integration window<br/>
100 128 symbols integration window<br/>
101 256 symbols integration window<br/>
110 Reserved<br/>
111 Reserved<br/>
If TOC_LIMIT ≠ 0: Symbol by symbol timing error proportional scale factor<br/>
000 Proportional scale factor = 8/16<br/>
001 Proportional scale factor = 6/16<br/>
010 Proportional scale factor = 2/16<br/>
011 Proportional scale factor = 1/16<br/>
1xx Proportional scale factor = 1/16 after sync found<br/>
2:0 TOC_POST_SYNC_BLOCKLEN 0x03 R/W When TOC_LIMIT = 0 the receiver uses a block based time offset error<br/>
calculation algorithm where the block length is configurable through register<br/>
TOC_CFG. After a sync word is found (SYNC_EVENT is asserted) the<br/>
TOC_POST_SYNC_BLOCKLEN sets the actual block length used for the time<br/>
offset algorithm<br/>
000 8 symbols integration window<br/>
001 16 symbols integration window<br/>
010 32 symbols integration window<br/>
011 64 symbols integration window<br/>
100 128 symbols integration window<br/>
101 256 symbols integration window<br/>
110 Reserved<br/>
111 Reserved<br/>
If TOC_LIMIT ≠ 0: Symbol by symbol timing error proportional scale factor<br/>
000 Freeze integral value<br/>
001 Integral scale factor = 6/32<br/>
010 Integral scale factor = 2/32<br/>
011 Integral scale factor = 1/32<br/>
1xx Integral scale factor = 1/32 after sync found<br/>
MARC_SPARE - MARC Spare<br/>
Bit # Name Reset R/W Description<br/>
7:4 MARC_SPARE_NOT_USED 0x00 R<br/>
3:0 AES_COMMANDS 0x00 R/W High level commands used to accelerate AES operations on the FIFO<br/>
content<br/>
0000 - 1000 Reserved<br/>
1001 AES_TXFIFO<br/>
1010 AES_RXFIFO<br/>
1011 - 1111 Reserved<br/>
SWRU346B Page 98 of 114CC120X<br/>
ECG_CFG - External Clock Frequency Configuration<br/>
Bit # Name Reset R/W Description<br/>
7:5 ECG_CFG_NOT_USED 0x00 R<br/>
4:0 EXT_CLOCK_FREQ 0x00 R/W External clock frequency. Controls the division factor<br/>
00000 64<br/>
00001 62<br/>
00010 60<br/>
00011 58<br/>
00100 56<br/>
00101 54<br/>
00110 52<br/>
00111 50<br/>
01000 48<br/>
01001 46<br/>
01010 44<br/>
01011 42<br/>
01100 40<br/>
01101 38<br/>
01110 36<br/>
01111 34<br/>
10000 32<br/>
10001 30<br/>
10010 28<br/>
10011 26<br/>
10100 24<br/>
10101 22<br/>
10110 20<br/>
10111 18<br/>
11000 16<br/>
11001 14<br/>
11010 12<br/>
11011 10<br/>
11100 8<br/>
11101 6<br/>
11110 4<br/>
11111 3<br/>
EXT_CTRL - External Control Configuration<br/>
Bit # Name Reset R/W Description<br/>
7:3 EXT_CTRL_NOT_USED 0x00 R<br/>
2 PIN_CTRL_EN 0x00 R/W Pin control enable. Pin control reuses the SPI interface pins to execute SRX,<br/>
STX, SPWD, and IDLE strobes<br/>
0 Pin control disabled<br/>
1 Pin control enabled<br/>
1 EXT_40K_CLOCK_EN 0x00 R/W External 40k clock enable<br/>
0 External 40k clock disabled<br/>
1 External 40k clock enabled. IOCFG3.GPIO3_CFG must be set to<br/>
HIGHZ (EXT_40K_CLOCK)<br/>
0 BURST_ADDR_INCR_EN 0x01 R/W Burst address increment enable<br/>
0 Burst address increment disabled (i.e. consecutive writes to the<br/>
same address location in burst mode)<br/>
1 Burst address increment enabled (i.e. the address is incremented<br/>
during burst access)<br/>
RCCAL_FINE - RC Oscillator Calibration Fine<br/>
Bit # Name Reset R/W Description<br/>
7 RCCAL_FINE_NOT_USED 0x00 R<br/>
6:0 RCC_FINE 0x00 R/W 40 kHz RCOSC calibrated fine value<br/>
RCCAL_COURSE - RC Oscillator Calibration Course<br/>
Bit # Name Reset R/W Description<br/>
7 RCCAL_COURSE_NOT_USED 0x00 R<br/>
6:0 RCC_ COURSE 0x00 R/W 40 kHz RCOSC calibrated course value<br/>
SWRU346B Page 99 of 114CC120X<br/>
RCCAL_OFFSET - RC Oscillator Calibration Clock Offset<br/>
Bit # Name Reset R/W Description<br/>
7:5 RCCAL_OFFSET_NOT_USED 0x00 R<br/>
4:0 RCCAL_OFFSET_RESERVED4_0 0x00 R/W For test purposes only, use values from SmartRF Studio<br/>
FREQOFF1 - Frequency Offset MSB<br/>
Bit # Name Reset R/W Description<br/>
7:0 FREQ_OFF_15_8 0x00 R/W Frequency offset [15:8]. Updated by user or SAFC strobe. The value is in<br/>
two&#x27;s complement format<br/>
FREQOFF0 - Frequency Offset LSB<br/>
Bit # Name Reset R/W Description<br/>
7:0 FREQ_OFF_7_0 0x00 R/W Frequency offset [7:0]. Updated by user or SAFC strobe. The value is in<br/>
two&#x27;s complement format<br/>
FREQ2 - Frequency Configuration [23:16]<br/>
Bit # Name Reset R/W Description<br/>
7:0 FREQ_23_16 0x00 R/W Frequency [23:16]<br/>
f<br/>
f VCO [Hz]<br/>
RF LO Divider<br/>
where<br/>
FREQ FREQOFF<br/>
f f f [Hz]<br/>
VCO 216 XOSC 218 XOSC<br/>
and the LO Divider is given by FS_CFG.FSD_BANDSELECT<br/>
FREQ1 - Frequency Configuration [15:8]<br/>
Bit # Name Reset R/W Description<br/>
7:0 FREQ_15_8 0x00 R/W Frequency [15:8]. See FREQ2<br/>
FREQ0 - Frequency Configuration [7:0]<br/>
Bit # Name Reset R/W Description<br/>
7:0 FREQ_7_0 0x00 R/W Frequency [7:0]. See FREQ2<br/>
IF_ADC2 - Analog to Digital Converter Configuration Reg. 2<br/>
Bit # Name Reset R/W Description<br/>
7:4 IF_ADC2_NOT_USED 0x00 R<br/>
3:0 IF_ADC2_RESERVED3_0 0x02 R/W For test purposes only, use values from SmartRF Studio<br/>
IF_ADC1 - Analog to Digital Converter Configuration Reg. 1<br/>
Bit # Name Reset R/W Description<br/>
7:0 IF_ADC1_RESERVED7_0 0x5A R/W For test purposes only, use values from SmartRF Studio<br/>
IF_ADC0 - Analog to Digital Converter Configuration Reg. 0<br/>
Bit # Name Reset R/W Description<br/>
7:6 IF_ADC0_NOT_USED 0x00 R<br/>
5:0 IF_ADC0_RESERVED5_0 0x1A R/W For test purposes only, use values from SmartRF Studio<br/>
FS_DIG1 - Frequency Synthesizer Digital Reg. 1<br/>
Bit # Name Reset R/W Description<br/>
7:6 FS_DIG1_NOT_USED 0x00 R<br/>
5:0 FS_DIG1_RESERVED5_0 0x08 R/W For test purposes only, use values from SmartRF Studio<br/>
SWRU346B Page 100 of 114CC120X<br/>
FS_DIG0 - Frequency Synthesizer Digital Reg. 0<br/>
Bit # Name Reset R/W Description<br/>
7:4 FS_DIG0_RESERVED7_4 0x05 R/W For test purposes only, use values from SmartRF Studio<br/>
3:2 RX_LPF_BW 0x02 R/W FS loop bandwidth in RX<br/>
00 200 kHz<br/>
01 300 kHz<br/>
10 400 kHz<br/>
11 500 kHz<br/>
1:0 TX_LPF_BW 0x02 R/W FS loop bandwidth in TX<br/>
00 200 kHz<br/>
01 300 kHz<br/>
10 400 kHz<br/>
11 500 kHz<br/>
FS_CAL3 - Frequency Synthesizer Calibration Reg. 3<br/>
Bit # Name Reset R/W Description<br/>
7 FS_CAL3_ RESERVED7 0x00 R For test purposes only, use values from SmartRF Studio<br/>
6 KVCO_HIGH_RES_CFG 0x00 R/W KVCO high resolution enable<br/>
0 High resolution disabled (normal resolution mode)<br/>
1 High resolution enabled (increased charge pump calibration, but will<br/>
extend the calibration time)<br/>
5:0 FS_CAL3_RESERVED5_0 0x00 R/W For test purposes only, use values from SmartRF Studio<br/>
FS_CAL2 - Frequency Synthesizer Calibration Reg. 2<br/>
Bit # Name Reset R/W Description<br/>
7:6 FS_CAL2_NOT_USED 0x00 R<br/>
5:0 FS_CAL2_RESERVED5_0 0x20 R/W For test purposes only, use values from SmartRF Studio<br/>
FS_CAL1 - Frequency Synthesizer Calibration Reg. 1<br/>
Bit # Name Reset R/W Description<br/>
7:0 FS_CAL1_RESERVED7_0 0x00 R/W For test purposes only, use values from SmartRF Studio<br/>
FS_CAL0 - Frequency Synthesizer Calibration Reg. 0<br/>
Bit # Name Reset R/W Description<br/>
7:4 FS_CAL0_NOT_USED 0x00 R<br/>
3:2 LOCK_CFG 0x00 R/W Out of lock detector average time<br/>
00 Average the measurement over 512 cycles<br/>
01 Average the measurement over 1024 cycles<br/>
10 Average the measurement over 256 cycles<br/>
11 Infinite average<br/>
1:0 FS_CAL0_RESERVED1_0 0x00 R/W For test purposes only, use values from SmartRF Studio<br/>
FS_CHP - Frequency Synthesizer Charge Pump Configuration<br/>
Bit # Name Reset R/W Description<br/>
7:6 FS_CHP_NOT_USED 0x00 R<br/>
5:0 FS_CHP_RESERVED5_0 0x28 R/W For test purposes only, use values from SmartRF Studio<br/>
FS_DIVTWO - Frequency Synthesizer Divide by 2<br/>
Bit # Name Reset R/W Description<br/>
7:2 FS_DIVTWO_NOT_USED 0x00 R<br/>
1:0 FS_DIVTWO_RESERVED1_0 0x01 R/W For test purposes only, use values from SmartRF Studio<br/>
FS_DSM1 - FS Digital Synthesizer Module Configuration Reg. 1<br/>
Bit # Name Reset R/W Description<br/>
7:3 FS_DSM1_NOT_USED 0x00 R<br/>
2:0 FS_DSM1_RESERVED2_0 0x00 R/W For test purposes only, use values from SmartRF Studio<br/>
FS_DSM0 - FS Digital Synthesizer Module Configuration Reg. 0<br/>
Bit # Name Reset R/W Description<br/>
7:0 FS_DSM0_RESERVED7_0 0x03 R/W For test purposes only, use values from SmartRF Studio<br/>
FS_DVC1 - Frequency Synthesizer Divider Chain Configuration Reg. 1<br/>
Bit # Name Reset R/W Description<br/>
7:0 FS_DVC1_RESERVED7_0 0xFF R/W For test purposes only, use values from SmartRF Studio<br/>
SWRU346B Page 101 of 114CC120X<br/>
FS_DVC0 - Frequency Synthesizer Divider Chain Configuration Reg. 0<br/>
Bit # Name Reset R/W Description<br/>
7:5 FS_DVC0_NOT_USED 0x00 R<br/>
4:0 FS_DVC0_RESERVED4_0 0x1F R/W For test purposes only, use values from SmartRF Studio<br/>
FS_LBI - Frequency Synthesizer Local Bias Configuration<br/>
Bit # Name Reset R/W Description<br/>
7:0 FS_LBI_NOT_USED 0x00 R<br/>
FS_PFD - Frequency Synthesizer Phase Frequency Detector Configuration<br/>
Bit # Name Reset R/W Description<br/>
7 FSD_PFD_NOT_USED 0x00 R<br/>
6:0 FS_PFD_RESERVED6_0 0x51 R/W For test purposes only, use values from SmartRF Studio<br/>
FS_PRE - Frequency Synthesizer Prescaler Configuration<br/>
Bit # Name Reset R/W Description<br/>
7 FS_PRE_NOT_USED 0x00 R<br/>
6:0 FS_PRE_RESERVED6_0 0x2C R/W For test purposes only, use values from SmartRF Studio<br/>
FS_REG_DIV_CML - Frequency Synthesizer Divider Regulator Configuration<br/>
Bit # Name Reset R/W Description<br/>
7:5 FS_REG_DIV_CML_NOT_USED 0x00 R<br/>
4:0 FS_REG_DIV_CML_RESERVED4_0 0x11 R/W For test purposes only, use values from SmartRF Studio<br/>
FS_SPARE - Frequency Synthesizer Spare<br/>
Bit # Name Reset R/W Description<br/>
7:0 FS_SPARE_RESERVED7_0 0x00 R/W For test purposes only, use values from SmartRF Studio<br/>
FS_VCO4 - FS Voltage Controlled Oscillator Configuration Reg. 4<br/>
Bit # Name Reset R/W Description<br/>
7:5 FS_VCO4_NOT_USED 0x00 R<br/>
4:0 FS_VCO4_RESERVED4_0 0x14 R/W For test purposes only, use values from SmartRF Studio<br/>
FS_VCO3 - FS Voltage Controlled Oscillator Configuration Reg. 3<br/>
Bit # Name Reset R/W Description<br/>
7:1 FS_VCO3_NOT_USED 0x00 R<br/>
0 FS_VCO3_RESERVED0 0x00 R/W For test purposes only, use values from SmartRF Studio<br/>
FS_VCO2 - FS Voltage Controlled Oscillator Configuration Reg. 2<br/>
Bit # Name Reset R/W Description<br/>
7 FS_VCO2_NOT_USED 0x00 R<br/>
6:0 FS_VCO2_RESERVED6_0 0x00 R/W For test purposes only, use values from SmartRF Studio<br/>
FS_VCO1 - FS Voltage Controlled Oscillator Configuration Reg. 1<br/>
Bit # Name Reset R/W Description<br/>
7:2 FSD_VCDAC 0x00 R/W<br/>
1:0 FS_VCO1_RESERVED1_0 0x00 R/W For test purposes only, use values from SmartRF Studio<br/>
FS_VCO0 - FS Voltage Controlled Oscillator Configuration Reg. 0<br/>
Bit # Name Reset R/W Description<br/>
7:0 FS_VCO0_RESERVED7_0 0x81 R/W For test purposes only, use values from SmartRF Studio<br/>
GBIAS6 - Global Bias Configuration Reg. 6<br/>
Bit # Name Reset R/W Description<br/>
7:6 GBIAS6_NOT_USED 0x00 R<br/>
5:0 GBIAS6_RESERVED5_0 0x00 R/W For test purposes only, use values from SmartRF Studio<br/>
GBIAS5 - Global Bias Configuration Reg. 5<br/>
Bit # Name Reset R/W Description<br/>
7:4 GBIAS5_NOT_USED 0x00 R<br/>
3:0 GBIAS5_RESERVED3_0 0x02 R/W For test purposes only, use values from SmartRF Studio<br/>
GBIAS4 - Global Bias Configuration Reg. 4<br/>
Bit # Name Reset R/W Description<br/>
7:6 GBIAS4_NOT_USED 0x00 R<br/>
5:0 GBIAS4_RESERVED5_0 0x00 R/W For test purposes only, use values from SmartRF Studio<br/>
SWRU346B Page 102 of 114CC120X<br/>
GBIAS3 - Global Bias Configuration Reg. 3<br/>
Bit # Name Reset R/W Description<br/>
7:6 GBIAS3_NOT_USED 0x00 R<br/>
5:0 GBIAS3_RESERVED5_0 0x00 R/W For test purposes only, use values from SmartRF Studio<br/>
GBIAS2 - Global Bias Configuration Reg. 2<br/>
Bit # Name Reset R/W Description<br/>
7 GBIAS2_NOT_USED 0x00 R<br/>
6:0 GBIAS2_RESERVED6_0 0x10 R/W For test purposes only, use values from SmartRF Studio<br/>
GBIAS1 - Global Bias Configuration Reg. 1<br/>
Bit # Name Reset R/W Description<br/>
7:5 GBIAS1_NOT_USED 0x00 R<br/>
4:0 GBIAS1_RESERVED4_0 0x00 R/W For test purposes only, use values from SmartRF Studio<br/>
GBIAS0 - Global Bias Configuration Reg. 0<br/>
Bit # Name Reset R/W Description<br/>
7:2 GBIAS0_NOT_USED 0x00 R<br/>
1:0 GBIAS0_RESERVED1_0 0x00 R/W For test purposes only, use values from SmartRF Studio<br/>
IFAMP - Intermediate Frequency Amplifier Configuration<br/>
Bit # Name Reset R/W Description<br/>
7:4 IFAMP_NOT_USED 0x00 R<br/>
3:2 IFAMP_BW 0x00 R/W Single side bandwidth control bits covering frequency range from 300 kHz to<br/>
1500 kHz.<br/>
RX Filter BW<br/>
Single Side BW f<br/>
IF 2<br/>
00 300 kHz<br/>
01 600 kHz<br/>
10 1000 kHz<br/>
11 1500 kHz<br/>
1:0 IFAMP_RESERVED1_0 0x01 R/W For test purposes only, use values from SmartRF Studio<br/>
LNA - Low Noise Amplifier Configuration<br/>
Bit # Name Reset R/W Description<br/>
7:2 LNA_NOT_USED 0x00 R<br/>
1:0 LNA_RESERVED1_0 0x01 R/W For test purposes only, use values from SmartRF Studio<br/>
RXMIX - RX Mixer Configuration<br/>
Bit # Name Reset R/W Description<br/>
7:2 RXMIX_NOT_USED 0x00 R<br/>
1:0 RXMIX_RESERVED1_0 0x01 R/W For test purposes only, use values from SmartRF Studio<br/>
XOSC5 - Crystal Oscillator Configuration Reg. 5<br/>
Bit # Name Reset R/W Description<br/>
7:4 XOSC5_NOT_USED 0x00 R<br/>
3:0 XOSC5_RESERVED3_0 0x0C R/W For test purposes only, use values from SmartRF Studio<br/>
XOSC4 - Crystal Oscillator Configuration Reg. 4<br/>
Bit # Name Reset R/W Description<br/>
7:0 XOSC4_RESERVED7_0 0xA0 R/W For test purposes only, use values from SmartRF Studio<br/>
XOSC3 - Crystal Oscillator Configuration Reg. 3<br/>
Bit # Name Reset R/W Description<br/>
7:0 XOSC3_RESERVED7_0 0x03 R/W For test purposes only, use values from SmartRF Studio<br/>
XOSC2 - Crystal Oscillator Configuration Reg. 2<br/>
Bit # Name Reset R/W Description<br/>
7:4 XOSC2_NOT_USED 0x00 R<br/>
3:1 XOSC2_RESERVED3_1 0x02 R/W For test purposes only, use values from SmartRF Studio<br/>
0 XOSC_CORE_PD_OVERRIDE 0x00 R/W XOSC core power down override<br/>
0 The XOSC will be turned off if the SXOFF, SPWD, or SWOR command<br/>
strobes are issued<br/>
1 The XOSC is forced on even if an SXOFF, SPWD, or SWOR command<br/>
strobe has been issued. This can be used to enable fast start-up from<br/>
SLEEP/XOFF on the expense of a higher current consumption<br/>
SWRU346B Page 103 of 114CC120X<br/>
XOSC1 - Crystal Oscillator Configuration Reg. 1<br/>
Bit # Name Reset R/W Description<br/>
7:3 XOSC1_NOT_USED 0x00 R<br/>
2 XOSC1_RESERVED2 0x00 R/W For test purposes only, use values from SmartRF Studio<br/>
1 XOSC_BUF_SEL 0x00 R/W XOSC buffer select. Selects internal XOSC buffer for RF PLL<br/>
0 Low power, single ended buffer (differential buffer is shut down)<br/>
1 Low phase noise, differential buffer (low power buffer still used for<br/>
digital clock)<br/>
0 XOSC_STABLE 0x01 R XOSC is stable (has finished settling)<br/>
XOSC0 - Crystal Oscillator Configuration Reg. 0<br/>
Bit # Name Reset R/W Description<br/>
7:2 XOSC0_NOT_USED 0x00 R<br/>
1:0 XOSC0_RESERVED1_0 0x00 R For test purposes only, use values from SmartRF Studio<br/>
ANALOG_SPARE - Analog Spare<br/>
Bit # Name Reset R/W Description<br/>
7:0 ANALOG_SPARE_RESERVED7_0 0x00 R/W For test purposes only, use values from SmartRF Studio<br/>
PA_CFG3 - Power Amplifier Configuration Reg. 3<br/>
Bit # Name Reset R/W Description<br/>
7:3 PA_CFG3_NOT_USED 0x00 R<br/>
2:0 PA_CFG3_RESERVED2_0 0x00 R/W For test purposes only, use values from SmartRF Studio<br/>
WOR_TIME1 - eWOR Timer Counter Value MSB<br/>
Bit # Name Reset R/W Description<br/>
7:0 WOR_STATUS_15_8 0x00 R eWOR timer counter value [15:8]<br/>
WOR_TIME0 - eWOR Timer Counter Value LSB<br/>
Bit # Name Reset R/W Description<br/>
7:0 WOR_STATUS_7_0 0x00 R eWOR timer counter value [7:0]<br/>
WOR_CAPTURE1 - eWOR Timer Capture Value MSB<br/>
Bit # Name Reset R/W Description<br/>
7:0 WOR_CAPTURE_15_8 0x00 R eWOR timer capture value [15:8]. Capture timer value on sync detect to<br/>
simplify timer re-synchronization<br/>
WOR_CAPTURE0 - eWOR Timer Capture Value LSB<br/>
Bit # Name Reset R/W Description<br/>
7:0 WOR_CAPTURE_7_0 0x00 R eWOR timer capture value [7:0]. Capture timer value on sync detect to<br/>
simplify timer re-synchronization<br/>
BIST - MARC Built-In Self-Test<br/>
Bit # Name Reset R/W Description<br/>
7:4 BIST_NOT_USED 0x00 R<br/>
3:0 BIST_RESERVED3_0 0x00 R/W For test purposes only, use values from SmartRF Studio<br/>
DCFILTOFFSET_I1 - DC Filter Offset I MSB<br/>
Bit # Name Reset R/W Description<br/>
7:0 DCFILT_OFFSET_I_15_8 0x00 R/W DC compensation, real value [15:8]<br/>
DCFILTOFFSET_I0 - DC Filter Offset I LSB<br/>
Bit # Name Reset R/W Description<br/>
7:0 DCFILT_OFFSET_I_7_0 0x00 R/W DC compensation, real value [7:0]<br/>
DCFILTOFFSET_Q1 - DC Filter Offset Q MSB<br/>
Bit # Name Reset R/W Description<br/>
7:0 DCFILT_OFFSET_Q_15_8 0x00 R/W DC compensation, imaginary value [15:8]<br/>
DCFILTOFFSET_Q0 - DC Filter Offset Q LSB<br/>
Bit # Name Reset R/W Description<br/>
7:0 DCFILT_OFFSET_Q_7_0 0x00 R/W DC compensation, imaginary value [7:0]<br/>
IQIE_I1 - IQ Imbalance Value I MSB<br/>
Bit # Name Reset R/W Description<br/>
7:0 IQIE_I_15_8 0x00 R/W IQ imbalance value, imaginary part [15:8]<br/>
SWRU346B Page 104 of 114CC120X<br/>
IQIE_I0 - IQ Imbalance Value I LSB<br/>
Bit # Name Reset R/W Description<br/>
7:0 IQIE_I_7_0 0x00 R/W IQ imbalance value, imaginary part [7:0]<br/>
IQIE_Q1 - IQ Imbalance Value Q MSB<br/>
Bit # Name Reset R/W Description<br/>
7:0 IQIE_Q_15_8 0x00 R/W IQ imbalance value, imaginary part [15:8]<br/>
IQIE_Q0 - IQ Imbalance Value Q LSB<br/>
Bit # Name Reset R/W Description<br/>
7:0 IQIE_Q_7_0 0x00 R/W IQ imbalance value, imaginary part [7:0]<br/>
RSSI1 - Received Signal Strength Indicator Reg. 1<br/>
Bit # Name Reset R/W Description<br/>
7:0 RSSI_11_4 0x80 R Received signal strength indicator. 8 MSB of RSSI[11:0]. RSSI[11:0]<br/>
is a two&#x27;s complement number with 0.0625 dB resolution hence ranging<br/>
from -128 to 127 dBm. A value of -128 dBm indicates that the RSSI is<br/>
invalid. To get a correct RSSI value a calibrated RSSI offset value should<br/>
be subtracted from the value given by RSSI[11:0]. This RSSI offset<br/>
value can either be subtracted from RSSI[11:0] manually or the offset<br/>
can be written to AGC_GAIN_ADJUST.GAIN_ADJUSTMENT meaning that<br/>
RSSI[11:0] will give a correct value directly<br/>
RSSI0 - Received Signal Strength Indicator Reg. 0<br/>
Bit # Name Reset R/W Description<br/>
7 RSSI0_NOT_USED 0x00 R<br/>
6:3 RSSI_3_0 0x00 R Received signal strength indicator. 4 LSB of RSSI[11:0]. See RSSI1<br/>
2 CARRIER_SENSE 0x00 R Carrier sense<br/>
0 No carrier detected<br/>
1 Carrier detected<br/>
1 CARRIER_SENSE_VALID 0x00 R Carrier sense valid<br/>
0 Carrier sense not valid<br/>
1 Carrier sense valid<br/>
0 RSSI_VALID 0x00 R RSSI valid<br/>
0 RSSI not valid<br/>
1 RSSI valid<br/>
SWRU346B Page 105 of 114CC120X<br/>
MARCSTATE - MARC State<br/>
Bit # Name Reset R/W Description<br/>
7 MARCSTATE_NOT_USED 0x00 R<br/>
6:5 MARC_2PIN_STATE 0x02 R MARC 2 pin state value<br/>
00 SETTLING<br/>
01 TX<br/>
10 IDLE<br/>
11 RX<br/>
4:0 MARC_STATE 0x01 R MARC state MARC 2 pin state value<br/>
00000 SLEEP26 Depends on the GPIO pins used (see<br/>
Section 3.4)<br/>
00001 IDLE IDLE<br/>
00010 XOFF26 SETTLING<br/>
00011 BIAS_SETTLE_MC SETTLING<br/>
00100 REG_SETTLE_MC SETTLING<br/>
00101 MANCAL SETTLING<br/>
00110 BIAS_SETTLE SETTLING<br/>
00111 REG_SETTLE SETTLING<br/>
01000 STARTCAL SETTLING<br/>
01001 BWBOOST SETTLING<br/>
01010 FS_LOCK SETTLING<br/>
01011 IFADCON SETTLING<br/>
01100 ENDCAL SETTLING<br/>
01101 RX RX<br/>
01110 RX_END RX<br/>
01111 RXDCM RX<br/>
10000 TXRX_SWITCH SETTLING<br/>
10001 RX_FIFO_ERR SETTLING<br/>
10010 FSTXON SETTLING<br/>
10011 TX TX<br/>
10100 TX_END TX<br/>
10101 RXTX_SWITCH SETTLING<br/>
10110 TX_FIFO_ERR SETTLING<br/>
10111 IFADCON_TXRX SETTLING<br/>
11000 - Reserved<br/>
11111<br/>
LQI_VAL - Link Quality Indicator Value<br/>
Bit # Name Reset R/W Description<br/>
7 PKT_CRC_OK 0x00 R CRC OK. Asserted in RX when PKT_CFG1.CRC_CFG = 1 or 10b and a good<br/>
packet is received. This signal is always on if the radio is in TX or if the radio is in<br/>
RX and PKT_CFG1.CRC_CFG = 0. The signal is de-asserted when RX mode is<br/>
entered and PKT_CFG1.CRC_CFG ≠ 0<br/>
0 CRC check not ok (bit error)<br/>
1 CRC check ok (no bit error)<br/>
6:0 LQI 0x00 R Link quality indicator. 0 when not valid. A low value indicates a better link than<br/>
what a high value does<br/>
PQT_SYNC_ERR - Preamble and Sync Word Error<br/>
Bit # Name Reset R/W Description<br/>
7:4 PQT_ERROR 0x0F R Preamble qualifier value. The actual preamble qualifier value can be greater than<br/>
15 but since PQT_ERROR is only 4 bits wide PQT_ERROR = MIN[actual PQT<br/>
qualifier value] modulo 16. This means that if PQT _ERROR = 1 the actual<br/>
preamble qualifier value is either 1 or 17. When a sync word is detected<br/>
(SYNC_EVENT is asserted) the PQT_ERROR register field is not updated again<br/>
before RX mode is re-entered. As long as the radio is in RX searching for a sync<br/>
word the register field will be updated continuously<br/>
3:0 SYNC_ERROR 0x0F R Sync word qualifier value. The actual sync word qualifier value can be greater<br/>
than 15 but since SYNC_ERROR is only 4 bits wide SYNC_ERROR = FLOOR[actual<br/>
sync word qualifier value/2] modulo 16. This means that if SYNC_ERROR = 1 the<br/>
actual sync word qualifier value is either 2, 3, 34, or 35. When a sync word is<br/>
received (SYNC_EVENT is asserted) the SYNC_ERROR register field is not updated<br/>
again before RX mode is re-entered. As long as the radio is in RX searching for a<br/>
sync word the register field will be updated continuously<br/>
26 Note that it is not possible to read 0 or 00010 from MARC_STATE as pulling CSn low will take the<br/>
b<br/>
radio to IDLE state.<br/>
SWRU346B Page 106 of 114CC120X<br/>
DEM_STATUS - Demodulator Status<br/>
Bit # Name Reset R/W Description<br/>
7 RSSI_STEP_FOUND 0x00 R RSSI step found during packet reception (after the assertion of SYNC_EVENT).<br/>
The RSSI step is 10 or 16 dB and is configured through<br/>
AGC_CFG1.RSSI_STEP_THR<br/>
0 No RSSI step found during packet reception<br/>
1 RSSI step found during packet reception<br/>
6 COLLISION_FOUND 0x00 R Collision found. Asserted if a new preamble is found and the RSSI has<br/>
increased 10 or 16 dB during packet reception (depending on<br/>
AGC_CFG1.RSSI_STEP_THR).<br/>
MDMCFG1.COLLISION_DETECT_EN must be 1<br/>
0 No collision found<br/>
1 Collision found<br/>
7 SYNC_LOW0_HIGH1 0x00 R DualSync detect. Only valid when SYNC_CFG1.SYNC_MODE = 111b. When<br/>
SYNC_EVENT is asserted this bit can be checked to see which sync word is<br/>
found<br/>
0 Sync word found = [SYNC15_8:SYNC7_0]<br/>
1 Sync word found = [SYNC31_24:SYNC23_16]<br/>
4:1 SRO_INDICATOR 0x00 R Symbol rate offset indicator (two’s complement).<br/>
TOC_CFG.TOC_LIMIT = 027:<br/>
Symbol Rate Offset<br/>
SRO_INDICATOR<br/>
106 [ppm]<br/>
4 Symbols after Sync Word<br/>
TOC_CFG.TOC_LIMIT = 1:<br/>
SRO_INDICATOR<br/>
Symbol Rate Offset 2 [%]<br/>
7<br/>
TOC_CFG.TOC_LIMIT = 3:<br/>
SRO_INDICATOR<br/>
Symbol Rate Offset 12 [%]<br/>
7<br/>
0 IMAGE_FOUND 0x00 R Image found detector<br/>
0 No image found<br/>
1 Image found<br/>
FREQOFF_EST1 - Frequency Offset Estimate MSB<br/>
Bit # Name Reset R/W Description<br/>
7:0 FREQOFF_EST_15_8 0x00 R Frequency offset estimate [15:8] MSB<br/>
Frequency Offset Estimate<br/>
FREQOFF_EST f<br/>
XOSC [Hz]<br/>
LO Divider 218<br/>
The value is in two&#x27;s complement format. The LO divider value can be found in<br/>
FS_CFG.FSD_BANDSELECT register field<br/>
FREQOFF_EST0 - Frequency Offset Estimate LSB<br/>
Bit # Name Reset R/W Description<br/>
7:0 FREQOFF_EST_7_0 0x00 R See FREOFF_EST1<br/>
AGC_GAIN3 - Automatic Gain Control Reg. 3<br/>
Bit # Name Reset R/W Description<br/>
7 AGC_GAIN3_NOT_USED 0x00 R<br/>
6:0 AGC_FRONT_END_GAIN 0x00 R AGC front end gain. Actual applied gain with 1 dB resolution<br/>
AGC_GAIN2 - Automatic Gain Control Reg. 2<br/>
Bit # Name Reset R/W Description<br/>
7 AGC_DRIVES_FE_GAIN 0x01 R/W Override AGC gain control<br/>
1 AGC controls front end gain<br/>
0 Front end gain controlled by registers AGC_GAIN2, AGC_GAIN1, and<br/>
AGC_GAIN0<br/>
6:0 AGC_GAIN2_RESERVED6_0 0x51 R/W For test purposes only, use values from SmartRF Studio<br/>
AGC_GAIN1 - Automatic Gain Control Reg. 1<br/>
Bit # Name Reset R/W Description<br/>
7:5 AGC_GAIN1_NOT_USED 0x00 R<br/>
4:0 AGC_GAIN1_RESERVED4_0 0x00 R/W For test purposes only, use values from SmartRF Studio<br/>
27 The symbol rate offset might wrap around<br/>
SWRU346B Page 107 of 114CC120X<br/>
AGC_GAIN0 - Automatic Gain Control Reg. 0<br/>
Bit # Name Reset R/W Description<br/>
7 AGC_GAIN0_NOT_USED 0x00 R<br/>
6:0 AGC_GAIN0_RESERVED6_0 0x3F R/W For test purposes only, use values from SmartRF Studio<br/>
CFM_RX_DATA_OUT - Custom Frequency Modulation RX Data<br/>
Bit # Name Reset R/W Description<br/>
7:0 CFM_RX_DATA 0x00 R 8-bit signed soft-decision symbol data, either from normal receiver or<br/>
transparent receiver. Can be read using burst mode to do custom<br/>
demodulation<br/>
f<br/>
f<br/>
dev<br/>
CFM_RX_DATA<br/>
[Hz]<br/>
OFFSET 64<br/>
(two&#x27;s complement format). fdev is the programmed frequency deviation<br/>
CFM_TX_DATA_IN - Custom Frequency Modulation TX Data<br/>
Bit # Name Reset R/W Description<br/>
7:0 CFM_TX_DATA 0x00 R/W 8-bit signed soft TX data input register for custom SW controlled<br/>
modulation. Can be accessed using burst mode to get arbitrary<br/>
modulation<br/>
f<br/>
f<br/>
dev<br/>
CFM_TX_DATA<br/>
[Hz]<br/>
OFFSET 64<br/>
(two&#x27;s complement format). fdev is the programmed frequency deviation<br/>
ASK_SOFT_RX_DATA - ASK Soft Decision Output<br/>
Bit # Name Reset R/W Description<br/>
7:6 ASK_SOFT_RX_DATA_NOT_USED 0x00 R<br/>
5:0 ASK_SOFT 0x30 R The OOK/ASK receiver use a max peak magnitude tracker and low peak<br/>
magnitude tracker to estimate ASK_THRESHOLD. The ASK_THRESHOLD<br/>
is used to do hard decision of OOK/ASK symbols.<br/>
ASK_SOFT = +16 when magnitude is ≥ ASK_THRESHOLD<br/>
ASK_SOFT = -16 when magnitude is ≥ ASK_THRESHOLD<br/>
RNDGEN - Random Number Generator Value<br/>
Bit # Name Reset R/W Description<br/>
7 RNDGEN_EN 0x00 R/W Random number generator enable<br/>
0 Random number generator disabled<br/>
1 Random number generator enabled<br/>
6:0 RNDGEN_VALUE 0x7F R Random number value. Number generated by 7 bit LFSR register<br/>
(X7+X6+1). Number will be further randomized when in RX by XORing<br/>
the feedback with receiver noise.<br/>
MAGN2 - Signal Magnitude after CORDIC [16]<br/>
Bit # Name Reset R/W Description<br/>
7:1 MAGN_NOT_USED 0x00 R<br/>
0 MAGN_16 0x00 R Instantaneous signal magnitude after CORDIC, 17-bit [16]<br/>
MAGN1 - Signal Magnitude after CORDIC [15:8]<br/>
Bit # Name Reset R/W Description<br/>
7:0 MAGN_15_8 0x00 R Instantaneous signal magnitude after CORDIC, 17-bit [15:8]<br/>
MAGN0 - Signal Magnitude after CORDIC [7:0]<br/>
Bit # Name Reset R/W Description<br/>
7:0 MAGN_7_0 0x00 R Instantaneous signal magnitude after CORDIC, 17-bit [7:0]<br/>
ANG1 - Signal Angular after CORDIC [9:8]<br/>
Bit # Name Reset R/W Description<br/>
7:2 ANG1_NOT_USED 0x00 R<br/>
1:0 ANGULAR_9_8 0x00 R Instantaneous signal angular after CORDIC, 10-bit [9:8]<br/>
ANG0 - Signal Angular after CORDIC [7:0]<br/>
Bit # Name Reset R/W Description<br/>
7:0 ANGULAR_7_0 0x00 R Instantaneous signal angular after CORDIC, 10-bit [7:0]<br/>
SWRU346B Page 108 of 114CC120X<br/>
CHFILT_I2 - Channel Filter Data Real Part [16]<br/>
Bit # Name Reset R/W Description<br/>
7:2 CHFILT_I2_NOT_USED 0x00 R<br/>
1 CHFILT_STARTUP_VALID 0x01 R Channel filter data valid<br/>
0 Channel filter data not valid<br/>
1 Channel filter data valid (asserted after 16 channel filter samples)<br/>
0 CHFILT_I_16 0x00 R Channel filter data, real part, 17-bit [16]<br/>
CHFILT_I1 - Channel Filter Data Real Part [15:8]<br/>
Bit # Name Reset R/W Description<br/>
7:0 CHFILT_I_15_8 0x00 R Channel filter data, real part, 17-bit [15:8]<br/>
CHFILT_I0 - Channel Filter Data Real Part [7:0]<br/>
Bit # Name Reset R/W Description<br/>
7:0 CHFILT_I_7_0 0x00 R Channel filter data, real part, 17-bit [7:0]<br/>
CHFILT_Q2 - Channel Filter Data Imaginary Part [16]<br/>
Bit # Name Reset R/W Description<br/>
7:1 CHFILT_Q2_NOT_USED 0x00 R<br/>
0 CHFILT_Q_16 0x00 R Channel filter data, imaginary part, 17-bit [16]<br/>
CHFILT_Q1 - Channel Filter Data Imaginary Part [15:8]<br/>
Bit # Name Reset R/W Description<br/>
7:0 CHFILT_Q_15_8 0x00 R Channel filter data, imaginary part, 17-bit [15:8]<br/>
CHFILT_Q0 - Channel Filter Data Imaginary Part [7:0]<br/>
Bit # Name Reset R/W Description<br/>
7:0 CHFILT_Q_7_0 0x00 R Channel filter data, imaginary part, 17-bit [7:0]<br/>
GPIO_STATUS - General Purpose Input/Output Status<br/>
Bit # Name Reset R/W Description<br/>
7:4 MARC_GDO_STATE 0x00 R For test purposes only<br/>
3:0 GPIO_STATE 0x00 R State of GPIO pins. SERIAL_STATUS.IOC_SYNC_PINS_EN must be 1<br/>
FSCAL_CTRL - Frequency Synthesizer Calibration Control<br/>
Bit # Name Reset R/W Description<br/>
7 FSCAL_CTRL_NOT_USED 0x00 R<br/>
6:1 FSCAL_CTRL_RESERVED6_1 0x00 R/W For test purposes only, use values from SmartRF Studio<br/>
0 LOCK 0x01 R Out of lock indicator (FS_CFG.FS_LOCK_EN must be 1). The state of this<br/>
signal is only valid in RX, TX, and FSTXON state<br/>
0 FS is out of lock<br/>
1 FS out of lock not detected<br/>
PHASE_ADJUST - Frequency Synthesizer Phase Adjust<br/>
Bit # Name Reset R/W Description<br/>
7:0 PHASE_ADJUST_RESERVED7_0 0x00 R For test purposes only, use values from SmartRF Studio<br/>
PARTNUMBER - Part Number<br/>
Bit # Name Reset R/W Description<br/>
7:0 PARTNUM 0x00 7:0 Chip ID<br/>
0x20 CC1200<br/>
0x21 CC1201<br/>
PARTVERSION - Part Revision<br/>
Bit # Name Reset R/W Description<br/>
7:0 PARTVER 0x00 R Chip revision<br/>
SWRU346B Page 109 of 114CC120X<br/>
SERIAL_STATUS - Serial Status<br/>
Bit # Name Reset R/W Description<br/>
7:6 SERIAL_STATUS_NOT_USED 0x00 R<br/>
5 SPI_DIRECT_ACCESS_CFG 0x00 R/W Configures which memory to access when using direct memory access<br/>
0 FIFO buffers<br/>
1 FEC workspace or 128 bytes free area<br/>
4 CLK40K 0x00 R Internal 40 kHz RC oscillator clock<br/>
3 IOC_SYNC_PINS_EN 0x00 R/W Enable synchronizer for IO pins. Required for transparent TX and for<br/>
reading GPIO_STATUS.GPIO_STATE<br/>
2 CFM_TX_DATA_CLK 0x00 R Modulator soft data clock (16 times higher than the programmed<br/>
symbol rate)<br/>
1 SERIAL_RX 0x00 R Serial RX data<br/>
0 SERIAL_RX_CLK 0x00 R Serial RX data clock<br/>
MODEM_STATUS1 - Modem Status Reg. 1<br/>
Bit # Name Reset R/W Description<br/>
7 SYNC_FOUND 0x00 R Asserted simultaneously as SYNC_EVENT. De-asserted when an SRX<br/>
strobe has been issued<br/>
6 RXFIFO_FULL 0x00 R Asserted when number of bytes is greater than the RX FIFO threshold. De-<br/>
asserted when the RX FIFO is empty<br/>
5 RXFIFO_THR 0x00 R Asserted when number of bytes is greater than the RX FIFO threshold. De-<br/>
asserted when the RX FIFO is drained below (or is equal) to the same<br/>
threshold<br/>
4 RXFIFO_EMPTY 0x00 R High when no bytes reside in the RX FIFO<br/>
3 RXFIFO_OVERFLOW 0x00 R Asserted when the RX FIFO has overflowed (the radio has received more<br/>
bytes after the RXFIFO is full). De-asserted when the RX FIFO is flushed<br/>
2 RXFIFO_UNDERFLOW 0x00 R Asserted if the user try to read from an empty RX FIFO. De-asserted when<br/>
the RX FIFO is flushed<br/>
1 PQT_REACHED 0x00 R Asserted when a preamble is detected (the preamble qualifier value is less<br/>
than the programmed PQT threshold). The signal will stay asserted as long<br/>
as a preamble is present but will de-assert on sync found (SYNC_EVENT<br/>
asserted). If the preamble disappears, the signal will de-assert after a<br/>
timeout defined by the sync word length + 10 symbols after preamble was<br/>
lost<br/>
0 PQT_VALID 0x01 R Asserted after 11, 12, 13, 14,1 5, 17, 24, or 32 bits are received<br/>
(depending on the PREAMBLE_CFG0.PQT_VALID_TIMEOUT setting) or<br/>
after a preamble is detected<br/>
MODEM_STATUS0 - Modem Status Reg. 0<br/>
Bit # Name Reset R/W Description<br/>
7 MODEM_STATUS0_NOT_USED 0x00 R<br/>
6 FEC_RX_OVERFLOW 0x00 R Internal FEC overflow has occurred<br/>
5 MODEM_STATUS0_RESERVED5 0x00 R For test purposes only<br/>
4 SYNC_SENT 0x00 R Last bit of sync word has been sent<br/>
3 TXFIFO_FULL 0x00 R Asserted when the TX FIFO is full. De-asserted when the number of bytes<br/>
is below threshold<br/>
2 TXFIFO_THR 0x00 R Asserted when number of bytes is greater than or equal to the TX FIFO<br/>
threshold. De-asserted when the TX FIFO is drained below the same<br/>
threshold<br/>
1 TXFIFO_OVERFLOW 0x00 R Asserted when the TX FIFO has overflowed (The user have tried to write to<br/>
a full TX FIFO). De-asserted when the TX FIFO is flushed<br/>
0 TXFIFO_UNDERFLOW 0x00 R Asserted when the TX FIFO has underflowed (TX FIFO is empty before the<br/>
complete packet is sent). De-asserted when the TX FIFO is flushed<br/>
SWRU346B Page 110 of 114CC120X<br/>
MARC_STATUS1 - MARC Status Reg. 1<br/>
Bit # Name Reset R/W Description<br/>
7:0 MARC_STATUS_OUT 0x00 R This register should be read to find what caused the MCU_WAKEUP signal<br/>
to be asserted<br/>
00000000 No failure<br/>
00000001 RX timeout occurred<br/>
00000010 RX termination based on CS or PQT<br/>
00000011 eWOR sync lost (16 slots with no successful reception)<br/>
00000100 Packet discarded due to maximum length filtering<br/>
00000101 Packet discarded due to address filtering<br/>
00000110 Packet discarded due to CRC filtering<br/>
00000111 TX FIFO overflow error occurred<br/>
00001000 TX FIFO underflow error occurred<br/>
00001001 RX FIFO overflow error occurred<br/>
00001010 RX FIFO underflow error occurred<br/>
00001011 TX ON CCA failed<br/>
01000000 TX finished successfully<br/>
10000000 RX finished successfully (a packet is in the RX FIFO ready<br/>
to be read)<br/>
MARC_STATUS0 - MARC Status Reg. 0<br/>
Bit # Name Reset R/W Description<br/>
7:4 MARC_STATUS0_NOT_USED 0x00 R<br/>
3 MARC_STATUS0_RESERVED3 0x00 R For test purposes only<br/>
2 TXONCCA_FAILED 0x00 R This bit can be read after the TXONCCA_DONE signal has been asserted<br/>
0 The channel was clear. The radio will enter TX state<br/>
1 The channel was busy. The radio will remain in RX state<br/>
1 MARC_STATUS0_RESERVED1 0x00 R For test purposes only<br/>
0 RCC_CAL_VALID 0x00 R RCOSC has been calibrated at least once<br/>
PA_IFAMP_TEST - Power Amplifier Intermediate Frequency Amplifier Test<br/>
Bit # Name Reset R/W Description<br/>
7:5 PA_IFAMP_TEST_NOT_USED 0x00 R<br/>
4:0 PA_IFAMP_TEST_RESERVED4_0 0x00 R/W For test purposes only, use values from SmartRF Studio<br/>
FSRF_TEST - Frequency Synthesizer Test<br/>
Bit # Name Reset R/W Description<br/>
7 FSRF_TEST_NOT_USED 0x00 R<br/>
6:0 FSRF_TEST_RESERVED6_0 0x00 R/W For test purposes only, use values from SmartRF Studio<br/>
PRE_TEST - Frequency Synthesizer Prescaler Test<br/>
Bit # Name Reset R/W Description<br/>
7:5 PRE_TEST_NOT_USED 0x00 R<br/>
4:0 PRE_TEST_RESERVED4_0 0x00 R/W For test purposes only, use values from SmartRF Studio<br/>
PRE_OVR - Frequency Synthesizer Prescaler Override<br/>
Bit # Name Reset R/W Description<br/>
7:0 PRE_OVR_RESERVED7_0 0x00 R/W For test purposes only, use values from SmartRF Studio<br/>
ADC_TEST - Analog to Digital Converter Test<br/>
Bit # Name Reset R/W Description<br/>
7:6 ADC_TEST_NOT_USED 0x00 R<br/>
5:0 ADC_TEST_RESERVED5_0 0x00 R/W For test purposes only, use values from SmartRF Studio<br/>
DVC_TEST - Digital Divider Chain Test<br/>
Bit # Name Reset R/W Description<br/>
7:5 DVC_TEST_NOT_USED 0x00 R<br/>
4:0 DVC_TEST_RESERVED4_0 0x0B R/W For test purposes only, use values from SmartRF Studio<br/>
ATEST - Analog Test<br/>
Bit # Name Reset R/W Description<br/>
7 ATEST_NOT_USED 0x00 R<br/>
6:0 ATEST_RESERVED6_0 0x40 R/W For test purposes only, use values from SmartRF Studio<br/>
ATEST_LVDS - Analog Test LVDS<br/>
Bit # Name Reset R/W Description<br/>
7:6 ATEST_LVDS_NOT_USED 0x00 R<br/>
5:0 ATEST_LVDS_RESERVED5_0 0x00 R/W For test purposes only, use values from SmartRF Studio<br/>
SWRU346B Page 111 of 114CC120X<br/>
ATEST_MODE - Analog Test Mode<br/>
Bit # Name Reset R/W Description<br/>
7:0 ATEST_MODE_RESERVED7_0 0x00 R/W For test purposes only, use values from SmartRF Studio<br/>
XOSC_TEST1 - Crystal Oscillator Test Reg. 1<br/>
Bit # Name Reset R/W Description<br/>
7:0 XOSC_TEST1_RESERVED7_0 0x3C R/W For test purposes only, use values from SmartRF Studio<br/>
XOSC_TEST0 - Crystal Oscillator Test Reg. 0<br/>
Bit # Name Reset R/W Description<br/>
7:0 XOSC_TEST0_RESERVED7_0 0x00 R/W For test purposes only, use values from SmartRF Studio<br/>
AES - Advanced Encryption Standard Status<br/>
Bit # Name Reset R/W Description<br/>
7:2 AES_NOT_USED 0x00 R<br/>
1 AES_ABORT 0x00 R/W Setting this bit to 1 will abort the AES encryption cycle.<br/>
The bit will be cleared by HW when the abortion sequence is completed<br/>
0 AES_RUN 0x00 R/W AES enable. The bit will be cleared by HW when an encryption cycle has<br/>
finished<br/>
0 Halt the current AES encryption<br/>
1 AES module is enabled and the AES encryption cycle will<br/>
start/continue given that AES_ABORT is low<br/>
MDM_TEST - Modem Test<br/>
Bit # Name Reset R/W Description<br/>
7:4 MDM_TEST_NOT_USED 0x00 R<br/>
3:0 MDM_TEST_RESERVED3_0 0x00 R/W For test purposes only, use values from SmartRF Studio<br/>
RXFIRST - RX FIFO Pointer First Entry<br/>
Bit # Name Reset R/W Description<br/>
7:0 RX_FIRST 0x00 R Pointer to the first entry in the RX FIFO<br/>
TXFIRST - TX FIFO Pointer First Entry<br/>
Bit # Name Reset R/W Description<br/>
7:0 TX_FIRST 0x00 R Pointer to the first entry in the TX FIFO<br/>
RXLAST - RX FIFO Pointer Last Entry<br/>
Bit # Name Reset R/W Description<br/>
7:0 RX_LAST 0x00 R Pointer to the last entry in the RX FIFO<br/>
TXLAST - TX FIFO Pointer Last Entry<br/>
Bit # Name Reset R/W Description<br/>
7:0 TX_LAST 0x00 R Pointer to the last entry in the TX FIFO<br/>
NUM_TXBYTES - TX FIFO Status<br/>
Bit # Name Reset R/W Description<br/>
7:0 TXBYTES 0x00 R Number of bytes in the TX FIFO<br/>
NUM_RXBYTES - RX FIFO Status<br/>
Bit # Name Reset R/W Description<br/>
7:0 RXBYTES 0x00 R Number of bytes in the RX FIFO<br/>
FIFO_NUM_TXBYTES - TX FIFO Status<br/>
Bit # Name Reset R/W Description<br/>
7:4 FIFO_NUM_TXBYTES_NOT_USED 0x00 R<br/>
3:0 FIFO_TXBYTES 0x0F R Number of free entries in the TX FIF0. 1111b means that there are 15 or<br/>
more free entries<br/>
FIFO_NUM_RXBYTES - RX FIFO Status<br/>
Bit # Name Reset R/W Description<br/>
7:4 FIFO_NUM_RXBYTES_NOT_USED 0x00 R<br/>
3:0 FIFO_RXBYTES 0x00 R Number of available bytes in the RX FIFO. 1111b means that there are<br/>
15 or more bytes available to read<br/>
RXFIFO_PRE_BUF - RX FIFO First Byte<br/>
Bit # Name Reset R/W Description<br/>
7:0 PRE_BUF 0x00 R Contains the first byte received in the RX FIFO when the RX FIFO is<br/>
empty (i.e. RXFIRST = RXLAST)<br/>
SWRU346B Page 112 of 114CC120X<br/>
AES_KEY15 - Advanced Encryption Standard Key [127:120]<br/>
Bit # Name Reset R/W Description<br/>
7:0 AES_KEY_127_120 0x00 R/W 16 bytes AES key, [127:120]<br/>
AES_KEY14 - Advanced Encryption Standard Key [119:112]<br/>
Bit # Name Reset R/W Description<br/>
7:0 AES_KEY_119_112 0x00 R/W 16 bytes AES key, [119:112]<br/>
AES_KEY13 - Advanced Encryption Standard Key [111:104]<br/>
Bit # Name Reset R/W Description<br/>
7:0 AES_KEY_111_104 0x00 R/W 16 bytes AES key, [111:104]<br/>
.<br/>
.<br/>
AES_KEY0 - Advanced Encryption Standard Key [7:0]<br/>
Bit # Name Reset R/W Description<br/>
7:0 AES_KEY_7_0 0x00 R/W 16 bytes AES key, [7:0]<br/>
AES_BUFFER15 - Advanced Encryption Standard Buffer [127:120]<br/>
Bit # Name Reset R/W Description<br/>
7:0 AES_BUFFER_127_120 0x00 R/W AES data buffer [127:120]. The content serves as input to the AES encryption<br/>
module, and the content will be overwritten with the encrypted data when the AES<br/>
encryption is completed<br/>
AES_BUFFER14 - Advanced Encryption Standard Buffer [119:112]<br/>
Bit # Name Reset R/W Description<br/>
7:0 AES_BUFFER_119_112 0x00 R/W AES data buffer [119:112]. See AES_BUFFER15 for details<br/>
AES_BUFFER13 - Advanced Encryption Standard Buffer [111:104]<br/>
Bit # Name Reset R/W Description<br/>
7:0 AES_BUFFER_111_104 0x00 R/W AES data buffer [111:104]. See AES_BUFFER15for details<br/>
.<br/>
.<br/>
AES_BUFFER0 - Advanced Encryption Standard Buffer [7:0]<br/>
Bit # Name Reset R/W Description<br/>
7:0 AES_BUFFER_7_0 0x00 R/W AES data buffer [7:0]. See AES_BUFFER15 for details<br/>
SWRU346B Page 113 of 114CC120X<br/>
13 Soldering Information<br/>
The recommendations for lead-free reflow in IPC/JEDEC J-STD-020 should be followed.<br/>
14 Development Kit Ordering Information<br/>
Orderable Evaluation Module Description<br/>
CC1200DK CC1200 Development Kit, 868-930 MHz<br/>
CC1200EMK-868-930 CC1200 Evaluation Module Kit, 868-930 MHz (add-on kit for CC1200DK)<br/>
CC1200EMK-420-470 CC1200 Evaluation Module Kit, 420-470 MHz (add-on kit for CC1200DK)<br/>
Table 40: Development Kit Ordering Information<br/>
15 References<br/>
[1] SmartRF Studio (SWRC176.zip)<br/>
[2] EN 300 220 V2.3.1: “Electromagnetic compatibility and Radio spectrum Matters (ERM); Short<br/>
Range Devices (SRD); Radio equipment to be used in the 25 MHz to 1000 MHz frequency<br/>
range with power levels rang up to 500 mW” (<a href="http://www.etsi.org" target="_blank" rel="noreferrer">www.etsi.org</a>)<br/>
[3] IEEE Std 802.15.4g-2012 (Amendment to IEEE Std 802.15.4-2011)<br/>
[4] DN403 CC112X/CC120X On-Chip Temperature Sensor (SWRA415.pdf)<br/>
16 General Information<br/>
16.1 Document History<br/>
Revision Date Description/Changes<br/>
Rev. 1.0 28.09.2011 Advance Information<br/>
SWRU346 30.04.2013 First Release<br/>
SWRU346A 01.07.2013 Added info to Section 3.4 saying that interrupts on GPIO signals must be disabled when<br/>
changing the GPIO configuration.<br/>
In Section 9.6.1, info added on how to use Event 2 for RC oscillator calibration.<br/>
Changed description of FS_DIG0.<br/>
Added info to Section 6.1 regarding the relationship between RX Filter BW and symbol rate<br/>
for different settings of SYNC_CFG0.RX_CONFIG_LIMITATION = 0<br/>
Added info regarding recommended AGC settings in the<br/>
SYNC_CFG0.RX_CONFIG_LIMITATION register field<br/>
Removed all references to MDMCFG0.CHFILT_BYPASS as this feature does not work<br/>
Added info in register field RFEND_CFG0.ANT_DIV_RX_TERM_CFG saying that<br/>
MDMCFG1.CARRIER_SENSE_GATE must be 0 when PQT termination is enabled.<br/>
SWRU346B 27.09.2013 AGC_CARRIER_SENSE changed name to CARRIER_SENSE<br/>
Added information about no RSSI available for Mode Switch packets in 802.15.4g mode<br/>
(Section 8.7.2.2 on page 57)<br/>
Changed PREAMBLE_CFG0.PQT_VALID_TIMEOUT<br/>
Section 6.8: Added equations for PQT response time<br/>
Table 41: Document History<br/>
SWRU346B Page 114 of 114IMPORTANTNOTICE<br/>
TexasInstrumentsIncorporatedanditssubsidiaries(TI)reservetherighttomakecorrections,enhancements,improvementsandother<br/>
changestoitssemiconductorproductsandservicesperJESD46,latestissue,andtodiscontinueanyproductorserviceperJESD48,latest<br/>
issue.Buyersshouldobtainthelatestrelevantinformationbeforeplacingordersandshouldverifythatsuchinformationiscurrentand<br/>
complete.Allsemiconductorproducts(alsoreferredtohereinas“components”)aresoldsubjecttoTI’stermsandconditionsofsale<br/>
suppliedatthetimeoforderacknowledgment.<br/>
TIwarrantsperformanceofitscomponentstothespecificationsapplicableatthetimeofsale,inaccordancewiththewarrantyinTI’sterms<br/>
andconditionsofsaleofsemiconductorproducts.TestingandotherqualitycontroltechniquesareusedtotheextentTIdeemsnecessary<br/>
tosupportthiswarranty.Exceptwheremandatedbyapplicablelaw,testingofallparametersofeachcomponentisnotnecessarily<br/>
performed.<br/>
TIassumesnoliabilityforapplicationsassistanceorthedesignofBuyers’products.Buyersareresponsiblefortheirproductsand<br/>
applicationsusingTIcomponents.TominimizetherisksassociatedwithBuyers’productsandapplications,Buyersshouldprovide<br/>
adequatedesignandoperatingsafeguards.<br/>
TIdoesnotwarrantorrepresentthatanylicense,eitherexpressorimplied,isgrantedunderanypatentright,copyright,maskworkright,or<br/>
otherintellectualpropertyrightrelatingtoanycombination,machine,orprocessinwhichTIcomponentsorservicesareused.Information<br/>
publishedbyTIregardingthird-partyproductsorservicesdoesnotconstitutealicensetousesuchproductsorservicesorawarrantyor<br/>
endorsementthereof.Useofsuchinformationmayrequirealicensefromathirdpartyunderthepatentsorotherintellectualpropertyofthe<br/>
thirdparty,oralicensefromTIunderthepatentsorotherintellectualpropertyofTI.<br/>
ReproductionofsignificantportionsofTIinformationinTIdatabooksordatasheetsispermissibleonlyifreproductioniswithoutalteration<br/>
andisaccompaniedbyallassociatedwarranties,conditions,limitations,andnotices.TIisnotresponsibleorliableforsuchaltered<br/>
documentation.Informationofthirdpartiesmaybesubjecttoadditionalrestrictions.<br/>
ResaleofTIcomponentsorserviceswithstatementsdifferentfromorbeyondtheparametersstatedbyTIforthatcomponentorservice<br/>
voidsallexpressandanyimpliedwarrantiesfortheassociatedTIcomponentorserviceandisanunfairanddeceptivebusinesspractice.<br/>
TIisnotresponsibleorliableforanysuchstatements.<br/>
Buyeracknowledgesandagreesthatitissolelyresponsibleforcompliancewithalllegal,regulatoryandsafety-relatedrequirements<br/>
concerningitsproducts,andanyuseofTIcomponentsinitsapplications,notwithstandinganyapplications-relatedinformationorsupport<br/>
thatmaybeprovidedbyTI.Buyerrepresentsandagreesthatithasallthenecessaryexpertisetocreateandimplementsafeguardswhich<br/>
anticipatedangerousconsequencesoffailures,monitorfailuresandtheirconsequences,lessenthelikelihoodoffailuresthatmightcause<br/>
harmandtakeappropriateremedialactions.BuyerwillfullyindemnifyTIanditsrepresentativesagainstanydamagesarisingoutoftheuse<br/>
ofanyTIcomponentsinsafety-criticalapplications.<br/>
Insomecases,TIcomponentsmaybepromotedspecificallytofacilitatesafety-relatedapplications.Withsuchcomponents,TI’sgoalisto<br/>
helpenablecustomerstodesignandcreatetheirownend-productsolutionsthatmeetapplicablefunctionalsafetystandardsand<br/>
requirements.Nonetheless,suchcomponentsaresubjecttotheseterms.<br/>
NoTIcomponentsareauthorizedforuseinFDAClassIII(orsimilarlife-criticalmedicalequipment)unlessauthorizedofficersoftheparties<br/>
haveexecutedaspecialagreementspecificallygoverningsuchuse.<br/>
OnlythoseTIcomponentswhichTIhasspecificallydesignatedasmilitarygradeor“enhancedplastic”aredesignedandintendedforusein<br/>
military/aerospaceapplicationsorenvironments.BuyeracknowledgesandagreesthatanymilitaryoraerospaceuseofTIcomponents<br/>
whichhavenotbeensodesignatedissolelyattheBuyer&#x27;srisk,andthatBuyerissolelyresponsibleforcompliancewithalllegaland<br/>
regulatoryrequirementsinconnectionwithsuchuse.<br/>
TIhasspecificallydesignatedcertaincomponentsasmeetingISO/TS16949requirements,mainlyforautomotiveuse.Inanycaseofuseof<br/>
non-designatedproducts,TIwillnotberesponsibleforanyfailuretomeetISO/TS16949.<br/>
Products Applications<br/>
Audio <a href="http://www.ti.com/audio" target="_blank" rel="noreferrer">www.ti.com/audio</a> AutomotiveandTransportation <a href="http://www.ti.com/automotive" target="_blank" rel="noreferrer">www.ti.com/automotive</a><br/>
Amplifiers amplifier.ti.com CommunicationsandTelecom <a href="http://www.ti.com/communications" target="_blank" rel="noreferrer">www.ti.com/communications</a><br/>
DataConverters dataconverter.ti.com ComputersandPeripherals <a href="http://www.ti.com/computers" target="_blank" rel="noreferrer">www.ti.com/computers</a><br/>
DLP®Products <a href="http://www.dlp.com" target="_blank" rel="noreferrer">www.dlp.com</a> ConsumerElectronics <a href="http://www.ti.com/consumer%5C-apps" target="_blank" rel="noreferrer">www.ti.com/consumer\-apps</a><br/>
DSP dsp.ti.com EnergyandLighting <a href="http://www.ti.com/energy" target="_blank" rel="noreferrer">www.ti.com/energy</a><br/>
ClocksandTimers <a href="http://www.ti.com/clocks" target="_blank" rel="noreferrer">www.ti.com/clocks</a> Industrial <a href="http://www.ti.com/industrial" target="_blank" rel="noreferrer">www.ti.com/industrial</a><br/>
Interface interface.ti.com Medical <a href="http://www.ti.com/medical" target="_blank" rel="noreferrer">www.ti.com/medical</a><br/>
Logic logic.ti.com Security <a href="http://www.ti.com/security" target="_blank" rel="noreferrer">www.ti.com/security</a><br/>
PowerMgmt power.ti.com Space,AvionicsandDefense <a href="http://www.ti.com/space%5C-avionics%5C-defense" target="_blank" rel="noreferrer">www.ti.com/space\-avionics\-defense</a><br/>
Microcontrollers microcontroller.ti.com VideoandImaging <a href="http://www.ti.com/video" target="_blank" rel="noreferrer">www.ti.com/video</a><br/>
RFID <a href="http://www.ti%5C-rfid.com" target="_blank" rel="noreferrer">www.ti\-rfid.com</a><br/>
OMAPApplicationsProcessors <a href="http://www.ti.com/omap" target="_blank" rel="noreferrer">www.ti.com/omap</a> TIE2ECommunity e2e.ti.com<br/>
WirelessConnectivity <a href="http://www.ti.com/wirelessconnectivity" target="_blank" rel="noreferrer">www.ti.com/wirelessconnectivity</a><br/>
MailingAddress:TexasInstruments,PostOfficeBox655303,Dallas,Texas75265<br/>
Copyright©2013,TexasInstrumentsIncorporated</p></div></div>
<div class="mb-4">
<p class="text-blue-500 text-lg"><b>ASSISTANT: </b></p>
<div class="break-words "><p>Certainly! Below is a comprehensive C API for the CC1201 transceiver, structured using an OSI-like layered pattern. This API abstracts the radio communication into different layers, making it modular and maintainable. The implementation assumes that the SPI interface functions are already provided.</p>
<p>I&#x27;ll present the code in sections, each corresponding to different layers:</p>
<ol>
<li><strong>Physical Layer</strong> (<code style="background-color:#f1f1f1;padding:2px 4px;marigin:0 4px;border-radius:4px;border:1px solid;border-color:#ddd">phy_cc1201.h</code> and <code style="background-color:#f1f1f1;padding:2px 4px;marigin:0 4px;border-radius:4px;border:1px solid;border-color:#ddd">phy_cc1201.c</code>): Handles direct interaction with the CC1201 hardware via SPI.</li>
<li><strong>Data Link Layer</strong> (<code style="background-color:#f1f1f1;padding:2px 4px;marigin:0 4px;border-radius:4px;border:1px solid;border-color:#ddd">mac_cc1201.h</code> and <code style="background-color:#f1f1f1;padding:2px 4px;marigin:0 4px;border-radius:4px;border:1px solid;border-color:#ddd">mac_cc1201.c</code>): Manages packet framing, addressing, and error checking.</li>
<li><strong>Network Layer</strong> (<code style="background-color:#f1f1f1;padding:2px 4px;marigin:0 4px;border-radius:4px;border:1px solid;border-color:#ddd">net_cc1201.h</code> and <code style="background-color:#f1f1f1;padding:2px 4px;marigin:0 4px;border-radius:4px;border:1px solid;border-color:#ddd">net_cc1201.c</code>): Provides networking functions such as packet routing (if needed).</li>
<li><strong>Application Layer</strong> (<code style="background-color:#f1f1f1;padding:2px 4px;marigin:0 4px;border-radius:4px;border:1px solid;border-color:#ddd">cc1201.h</code> and <code style="background-color:#f1f1f1;padding:2px 4px;marigin:0 4px;border-radius:4px;border:1px solid;border-color:#ddd">cc1201.c</code>): High-level API functions that applications can use.</li>
</ol>
<hr/>
<h3>1. Physical Layer</h3>
<p><strong>phy_cc1201.h</strong></p>
<pre><div><div style="display:flex;justify-content:space-between;width:100%;background-color:rgb(50, 50, 50);font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;border-top-left-radius:0.3rem;border-top-right-radius:0.3rem;border-bottom-left-radius:0;border-bottom-right-radius:0"><span style="text-decoration:none;color:gray;padding:2px;margin:2px 10px 0 10px">&lt;C&gt;</span></div><div style="color:#f8f8f2;background:#2b2b2b;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:0;overflow:auto;border-radius:0.3em;margin-top:0;border-top-left-radius:0;border-top-right-radius:0;border-bottom-left-radius:0.3rem;border-bottom-right-radius:0.3rem;border:none"><code class="language-c" style="color:#f8f8f2;background:none;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">ifndef</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro expression" style="color:#ffa07a">PHY_CC1201_H</span><span>
</span><span></span><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">define</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro macro-name" style="color:#ffa07a">PHY_CC1201_H</span><span>
</span>
<span></span><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">include</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro" style="color:#abe338">&lt;stdint.h&gt;</span><span>
</span><span></span><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">include</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro" style="color:#abe338">&lt;stdbool.h&gt;</span><span>
</span>
<span></span><span class="token" style="color:#d4d0ab">// Register addresses (define all the necessary CC1201 registers here)</span><span>
</span><span></span><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">define</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro macro-name" style="color:#ffa07a">CC1201_IOCFG3</span><span class="token macro" style="color:#ffa07a">       </span><span class="token macro expression" style="color:#00e0e0">0x0000</span><span>
</span><span></span><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">define</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro macro-name" style="color:#ffa07a">CC1201_IOCFG2</span><span class="token macro" style="color:#ffa07a">       </span><span class="token macro expression" style="color:#00e0e0">0x0001</span><span>
</span><span></span><span class="token" style="color:#d4d0ab">// ... (Include all register addresses as per the CC1201 datasheet)</span><span>
</span>
<span></span><span class="token" style="color:#d4d0ab">// Command strobes</span><span>
</span><span></span><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">define</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro macro-name" style="color:#ffa07a">CC1201_SRES</span><span class="token macro" style="color:#ffa07a">         </span><span class="token macro expression" style="color:#00e0e0">0x30</span><span>
</span><span></span><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">define</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro macro-name" style="color:#ffa07a">CC1201_SFSTXON</span><span class="token macro" style="color:#ffa07a">      </span><span class="token macro expression" style="color:#00e0e0">0x31</span><span>
</span><span></span><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">define</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro macro-name" style="color:#ffa07a">CC1201_SXOFF</span><span class="token macro" style="color:#ffa07a">        </span><span class="token macro expression" style="color:#00e0e0">0x32</span><span>
</span><span></span><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">define</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro macro-name" style="color:#ffa07a">CC1201_SCAL</span><span class="token macro" style="color:#ffa07a">         </span><span class="token macro expression" style="color:#00e0e0">0x33</span><span>
</span><span></span><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">define</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro macro-name" style="color:#ffa07a">CC1201_SRX</span><span class="token macro" style="color:#ffa07a">          </span><span class="token macro expression" style="color:#00e0e0">0x34</span><span>
</span><span></span><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">define</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro macro-name" style="color:#ffa07a">CC1201_STX</span><span class="token macro" style="color:#ffa07a">          </span><span class="token macro expression" style="color:#00e0e0">0x35</span><span>
</span><span></span><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">define</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro macro-name" style="color:#ffa07a">CC1201_SIDLE</span><span class="token macro" style="color:#ffa07a">        </span><span class="token macro expression" style="color:#00e0e0">0x36</span><span>
</span><span></span><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">define</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro macro-name" style="color:#ffa07a">CC1201_SAFC</span><span class="token macro" style="color:#ffa07a">         </span><span class="token macro expression" style="color:#00e0e0">0x37</span><span>
</span><span></span><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">define</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro macro-name" style="color:#ffa07a">CC1201_SWOR</span><span class="token macro" style="color:#ffa07a">         </span><span class="token macro expression" style="color:#00e0e0">0x38</span><span>
</span><span></span><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">define</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro macro-name" style="color:#ffa07a">CC1201_SPWD</span><span class="token macro" style="color:#ffa07a">         </span><span class="token macro expression" style="color:#00e0e0">0x39</span><span>
</span><span></span><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">define</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro macro-name" style="color:#ffa07a">CC1201_SFRX</span><span class="token macro" style="color:#ffa07a">         </span><span class="token macro expression" style="color:#00e0e0">0x3A</span><span>
</span><span></span><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">define</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro macro-name" style="color:#ffa07a">CC1201_SFTX</span><span class="token macro" style="color:#ffa07a">         </span><span class="token macro expression" style="color:#00e0e0">0x3B</span><span>
</span><span></span><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">define</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro macro-name" style="color:#ffa07a">CC1201_SWORRST</span><span class="token macro" style="color:#ffa07a">      </span><span class="token macro expression" style="color:#00e0e0">0x3C</span><span>
</span><span></span><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">define</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro macro-name" style="color:#ffa07a">CC1201_SNOP</span><span class="token macro" style="color:#ffa07a">         </span><span class="token macro expression" style="color:#00e0e0">0x3D</span><span>
</span>
<span></span><span class="token" style="color:#d4d0ab">// FIFO access</span><span>
</span><span></span><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">define</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro macro-name" style="color:#ffa07a">CC1201_TXFIFO</span><span class="token macro" style="color:#ffa07a">       </span><span class="token macro expression" style="color:#00e0e0">0x3F</span><span>
</span><span></span><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">define</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro macro-name" style="color:#ffa07a">CC1201_RXFIFO</span><span class="token macro" style="color:#ffa07a">       </span><span class="token macro expression" style="color:#00e0e0">0xBF</span><span>
</span>
<span></span><span class="token" style="color:#d4d0ab">// Status byte masks</span><span>
</span><span></span><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">define</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro macro-name" style="color:#ffa07a">CC1201_STATUS_STATE_MASK</span><span class="token macro" style="color:#ffa07a">   </span><span class="token macro expression" style="color:#00e0e0">0x70</span><span>
</span><span></span><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">define</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro macro-name" style="color:#ffa07a">CC1201_STATUS_STATE_IDLE</span><span class="token macro" style="color:#ffa07a">   </span><span class="token macro expression" style="color:#00e0e0">0x00</span><span>
</span><span></span><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">define</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro macro-name" style="color:#ffa07a">CC1201_STATUS_STATE_RX</span><span class="token macro" style="color:#ffa07a">     </span><span class="token macro expression" style="color:#00e0e0">0x10</span><span>
</span><span></span><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">define</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro macro-name" style="color:#ffa07a">CC1201_STATUS_STATE_TX</span><span class="token macro" style="color:#ffa07a">     </span><span class="token macro expression" style="color:#00e0e0">0x20</span><span>
</span><span></span><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">define</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro macro-name" style="color:#ffa07a">CC1201_STATUS_STATE_FSTXON</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro expression" style="color:#00e0e0">0x30</span><span>
</span><span></span><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">define</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro macro-name" style="color:#ffa07a">CC1201_STATUS_STATE_CALIBRATE</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro expression" style="color:#00e0e0">0x40</span><span>
</span><span></span><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">define</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro macro-name" style="color:#ffa07a">CC1201_STATUS_STATE_SETTLING</span><span class="token macro" style="color:#ffa07a">  </span><span class="token macro expression" style="color:#00e0e0">0x50</span><span>
</span><span></span><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">define</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro macro-name" style="color:#ffa07a">CC1201_STATUS_STATE_RXFIFO_ERR</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro expression" style="color:#00e0e0">0x60</span><span>
</span><span></span><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">define</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro macro-name" style="color:#ffa07a">CC1201_STATUS_STATE_TXFIFO_ERR</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro expression" style="color:#00e0e0">0x70</span><span>
</span>
<span></span><span class="token" style="color:#d4d0ab">// SPI functions (Assumed to be implemented elsewhere)</span><span>
</span><span></span><span class="token" style="color:#00e0e0">extern</span><span> </span><span class="token" style="color:#00e0e0">void</span><span> </span><span class="token" style="color:#ffd700">SPI_Init</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#00e0e0">void</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span></span><span class="token" style="color:#00e0e0">extern</span><span> </span><span class="token" style="color:#00e0e0">void</span><span> </span><span class="token" style="color:#ffd700">SPI_Select</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#00e0e0">void</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span></span><span class="token" style="color:#00e0e0">extern</span><span> </span><span class="token" style="color:#00e0e0">void</span><span> </span><span class="token" style="color:#ffd700">SPI_Deselect</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#00e0e0">void</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span></span><span class="token" style="color:#00e0e0">extern</span><span> </span><span class="token class-name">uint8_t</span><span> </span><span class="token" style="color:#ffd700">SPI_Transfer</span><span class="token" style="color:#fefefe">(</span><span class="token class-name">uint8_t</span><span> data</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span>
<span></span><span class="token" style="color:#d4d0ab">// Function prototypes</span><span>
</span><span></span><span class="token" style="color:#00e0e0">void</span><span> </span><span class="token" style="color:#ffd700">PHY_CC1201_Init</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#00e0e0">void</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span></span><span class="token" style="color:#00e0e0">void</span><span> </span><span class="token" style="color:#ffd700">PHY_CC1201_Reset</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#00e0e0">void</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span></span><span class="token class-name">uint8_t</span><span> </span><span class="token" style="color:#ffd700">PHY_CC1201_ReadRegister</span><span class="token" style="color:#fefefe">(</span><span class="token class-name">uint16_t</span><span> addr</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span></span><span class="token" style="color:#00e0e0">void</span><span> </span><span class="token" style="color:#ffd700">PHY_CC1201_WriteRegister</span><span class="token" style="color:#fefefe">(</span><span class="token class-name">uint16_t</span><span> addr</span><span class="token" style="color:#fefefe">,</span><span> </span><span class="token class-name">uint8_t</span><span> value</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span></span><span class="token" style="color:#00e0e0">void</span><span> </span><span class="token" style="color:#ffd700">PHY_CC1201_ReadBurst</span><span class="token" style="color:#fefefe">(</span><span class="token class-name">uint16_t</span><span> addr</span><span class="token" style="color:#fefefe">,</span><span> </span><span class="token class-name">uint8_t</span><span> </span><span class="token" style="color:#00e0e0">*</span><span>buffer</span><span class="token" style="color:#fefefe">,</span><span> </span><span class="token class-name">uint8_t</span><span> length</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span></span><span class="token" style="color:#00e0e0">void</span><span> </span><span class="token" style="color:#ffd700">PHY_CC1201_WriteBurst</span><span class="token" style="color:#fefefe">(</span><span class="token class-name">uint16_t</span><span> addr</span><span class="token" style="color:#fefefe">,</span><span> </span><span class="token" style="color:#00e0e0">const</span><span> </span><span class="token class-name">uint8_t</span><span> </span><span class="token" style="color:#00e0e0">*</span><span>buffer</span><span class="token" style="color:#fefefe">,</span><span> </span><span class="token class-name">uint8_t</span><span> length</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span></span><span class="token" style="color:#00e0e0">void</span><span> </span><span class="token" style="color:#ffd700">PHY_CC1201_Strobe</span><span class="token" style="color:#fefefe">(</span><span class="token class-name">uint8_t</span><span> strobe</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span></span><span class="token class-name">uint8_t</span><span> </span><span class="token" style="color:#ffd700">PHY_CC1201_GetStatus</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#00e0e0">void</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span></span><span class="token" style="color:#00e0e0">void</span><span> </span><span class="token" style="color:#ffd700">PHY_CC1201_WriteTXFIFO</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#00e0e0">const</span><span> </span><span class="token class-name">uint8_t</span><span> </span><span class="token" style="color:#00e0e0">*</span><span>buffer</span><span class="token" style="color:#fefefe">,</span><span> </span><span class="token class-name">uint8_t</span><span> length</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span></span><span class="token class-name">uint8_t</span><span> </span><span class="token" style="color:#ffd700">PHY_CC1201_ReadRXFIFO</span><span class="token" style="color:#fefefe">(</span><span class="token class-name">uint8_t</span><span> </span><span class="token" style="color:#00e0e0">*</span><span>buffer</span><span class="token" style="color:#fefefe">,</span><span> </span><span class="token class-name">uint8_t</span><span> length</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span></span><span class="token" style="color:#00e0e0">void</span><span> </span><span class="token" style="color:#ffd700">PHY_CC1201_FlushRXFIFO</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#00e0e0">void</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span></span><span class="token" style="color:#00e0e0">void</span><span> </span><span class="token" style="color:#ffd700">PHY_CC1201_FlushTXFIFO</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#00e0e0">void</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span>
<span></span><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">endif</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro" style="color:#d4d0ab">// PHY_CC1201_H</span></code></div></div></pre>
<p><strong>phy_cc1201.c</strong></p>
<pre><div><div style="display:flex;justify-content:space-between;width:100%;background-color:rgb(50, 50, 50);font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;border-top-left-radius:0.3rem;border-top-right-radius:0.3rem;border-bottom-left-radius:0;border-bottom-right-radius:0"><span style="text-decoration:none;color:gray;padding:2px;margin:2px 10px 0 10px">&lt;C&gt;</span></div><div style="color:#f8f8f2;background:#2b2b2b;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:0;overflow:auto;border-radius:0.3em;margin-top:0;border-top-left-radius:0;border-top-right-radius:0;border-bottom-left-radius:0.3rem;border-bottom-right-radius:0.3rem;border:none"><code class="language-c" style="color:#f8f8f2;background:none;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">include</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro" style="color:#abe338">&quot;phy_cc1201.h&quot;</span><span>
</span>
<span></span><span class="token" style="color:#d4d0ab">// Function to initialize the physical layer</span><span>
</span><span></span><span class="token" style="color:#00e0e0">void</span><span> </span><span class="token" style="color:#ffd700">PHY_CC1201_Init</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#00e0e0">void</span><span class="token" style="color:#fefefe">)</span><span>
</span><span></span><span class="token" style="color:#fefefe">{</span><span>
</span><span>    </span><span class="token" style="color:#ffd700">SPI_Init</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token" style="color:#ffd700">PHY_CC1201_Reset</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token" style="color:#d4d0ab">// Additional hardware initialization if necessary</span><span>
</span><span></span><span class="token" style="color:#fefefe">}</span><span>
</span>
<span></span><span class="token" style="color:#d4d0ab">// Function to reset the CC1201 transceiver</span><span>
</span><span></span><span class="token" style="color:#00e0e0">void</span><span> </span><span class="token" style="color:#ffd700">PHY_CC1201_Reset</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#00e0e0">void</span><span class="token" style="color:#fefefe">)</span><span>
</span><span></span><span class="token" style="color:#fefefe">{</span><span>
</span><span>    </span><span class="token" style="color:#d4d0ab">// Send the SRES command strobe</span><span>
</span><span>    </span><span class="token" style="color:#ffd700">SPI_Select</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token" style="color:#ffd700">PHY_CC1201_Strobe</span><span class="token" style="color:#fefefe">(</span><span>CC1201_SRES</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token" style="color:#ffd700">SPI_Deselect</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span></span><span class="token" style="color:#fefefe">}</span><span>
</span>
<span></span><span class="token" style="color:#d4d0ab">// Function to read a single register</span><span>
</span><span></span><span class="token class-name">uint8_t</span><span> </span><span class="token" style="color:#ffd700">PHY_CC1201_ReadRegister</span><span class="token" style="color:#fefefe">(</span><span class="token class-name">uint16_t</span><span> addr</span><span class="token" style="color:#fefefe">)</span><span>
</span><span></span><span class="token" style="color:#fefefe">{</span><span>
</span><span>    </span><span class="token class-name">uint8_t</span><span> value</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token" style="color:#ffd700">SPI_Select</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token" style="color:#00e0e0">if</span><span> </span><span class="token" style="color:#fefefe">(</span><span>addr </span><span class="token" style="color:#00e0e0">&gt;</span><span> </span><span class="token" style="color:#00e0e0">0x2F</span><span class="token" style="color:#fefefe">)</span><span> </span><span class="token" style="color:#d4d0ab">// Extended address space</span><span>
</span><span>    </span><span class="token" style="color:#fefefe">{</span><span>
</span><span>        </span><span class="token" style="color:#ffd700">SPI_Transfer</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#fefefe">(</span><span>addr </span><span class="token" style="color:#00e0e0">&gt;&gt;</span><span> </span><span class="token" style="color:#00e0e0">8</span><span class="token" style="color:#fefefe">)</span><span> </span><span class="token" style="color:#00e0e0">|</span><span> </span><span class="token" style="color:#00e0e0">0x80</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span> </span><span class="token" style="color:#d4d0ab">// Set R/W bit to 1 for read</span><span>
</span><span>        </span><span class="token" style="color:#ffd700">SPI_Transfer</span><span class="token" style="color:#fefefe">(</span><span>addr </span><span class="token" style="color:#00e0e0">&amp;</span><span> </span><span class="token" style="color:#00e0e0">0xFF</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token" style="color:#fefefe">}</span><span>
</span><span>    </span><span class="token" style="color:#00e0e0">else</span><span>
</span><span>    </span><span class="token" style="color:#fefefe">{</span><span>
</span><span>        </span><span class="token" style="color:#ffd700">SPI_Transfer</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#fefefe">(</span><span class="token class-name">uint8_t</span><span class="token" style="color:#fefefe">)</span><span>addr </span><span class="token" style="color:#00e0e0">|</span><span> </span><span class="token" style="color:#00e0e0">0x80</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span> </span><span class="token" style="color:#d4d0ab">// Set R/W bit to 1 for read</span><span>
</span><span>    </span><span class="token" style="color:#fefefe">}</span><span>
</span><span>    value </span><span class="token" style="color:#00e0e0">=</span><span> </span><span class="token" style="color:#ffd700">SPI_Transfer</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#00e0e0">0x00</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token" style="color:#ffd700">SPI_Deselect</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token" style="color:#00e0e0">return</span><span> value</span><span class="token" style="color:#fefefe">;</span><span>
</span><span></span><span class="token" style="color:#fefefe">}</span><span>
</span>
<span></span><span class="token" style="color:#d4d0ab">// Function to write a single register</span><span>
</span><span></span><span class="token" style="color:#00e0e0">void</span><span> </span><span class="token" style="color:#ffd700">PHY_CC1201_WriteRegister</span><span class="token" style="color:#fefefe">(</span><span class="token class-name">uint16_t</span><span> addr</span><span class="token" style="color:#fefefe">,</span><span> </span><span class="token class-name">uint8_t</span><span> value</span><span class="token" style="color:#fefefe">)</span><span>
</span><span></span><span class="token" style="color:#fefefe">{</span><span>
</span><span>    </span><span class="token" style="color:#ffd700">SPI_Select</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token" style="color:#00e0e0">if</span><span> </span><span class="token" style="color:#fefefe">(</span><span>addr </span><span class="token" style="color:#00e0e0">&gt;</span><span> </span><span class="token" style="color:#00e0e0">0x2F</span><span class="token" style="color:#fefefe">)</span><span> </span><span class="token" style="color:#d4d0ab">// Extended address space</span><span>
</span><span>    </span><span class="token" style="color:#fefefe">{</span><span>
</span><span>        </span><span class="token" style="color:#ffd700">SPI_Transfer</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#fefefe">(</span><span>addr </span><span class="token" style="color:#00e0e0">&gt;&gt;</span><span> </span><span class="token" style="color:#00e0e0">8</span><span class="token" style="color:#fefefe">)</span><span> </span><span class="token" style="color:#00e0e0">&amp;</span><span> </span><span class="token" style="color:#00e0e0">0x7F</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span> </span><span class="token" style="color:#d4d0ab">// Set R/W bit to 0 for write</span><span>
</span><span>        </span><span class="token" style="color:#ffd700">SPI_Transfer</span><span class="token" style="color:#fefefe">(</span><span>addr </span><span class="token" style="color:#00e0e0">&amp;</span><span> </span><span class="token" style="color:#00e0e0">0xFF</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token" style="color:#fefefe">}</span><span>
</span><span>    </span><span class="token" style="color:#00e0e0">else</span><span>
</span><span>    </span><span class="token" style="color:#fefefe">{</span><span>
</span><span>        </span><span class="token" style="color:#ffd700">SPI_Transfer</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#fefefe">(</span><span class="token class-name">uint8_t</span><span class="token" style="color:#fefefe">)</span><span>addr </span><span class="token" style="color:#00e0e0">&amp;</span><span> </span><span class="token" style="color:#00e0e0">0x7F</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span> </span><span class="token" style="color:#d4d0ab">// Set R/W bit to 0 for write</span><span>
</span><span>    </span><span class="token" style="color:#fefefe">}</span><span>
</span><span>    </span><span class="token" style="color:#ffd700">SPI_Transfer</span><span class="token" style="color:#fefefe">(</span><span>value</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token" style="color:#ffd700">SPI_Deselect</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span></span><span class="token" style="color:#fefefe">}</span><span>
</span>
<span></span><span class="token" style="color:#d4d0ab">// Function to read multiple registers in burst</span><span>
</span><span></span><span class="token" style="color:#00e0e0">void</span><span> </span><span class="token" style="color:#ffd700">PHY_CC1201_ReadBurst</span><span class="token" style="color:#fefefe">(</span><span class="token class-name">uint16_t</span><span> addr</span><span class="token" style="color:#fefefe">,</span><span> </span><span class="token class-name">uint8_t</span><span> </span><span class="token" style="color:#00e0e0">*</span><span>buffer</span><span class="token" style="color:#fefefe">,</span><span> </span><span class="token class-name">uint8_t</span><span> length</span><span class="token" style="color:#fefefe">)</span><span>
</span><span></span><span class="token" style="color:#fefefe">{</span><span>
</span><span>    </span><span class="token" style="color:#ffd700">SPI_Select</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token" style="color:#00e0e0">if</span><span> </span><span class="token" style="color:#fefefe">(</span><span>addr </span><span class="token" style="color:#00e0e0">&gt;</span><span> </span><span class="token" style="color:#00e0e0">0x2F</span><span class="token" style="color:#fefefe">)</span><span> </span><span class="token" style="color:#d4d0ab">// Extended address space</span><span>
</span><span>    </span><span class="token" style="color:#fefefe">{</span><span>
</span><span>        </span><span class="token" style="color:#ffd700">SPI_Transfer</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#fefefe">(</span><span>addr </span><span class="token" style="color:#00e0e0">&gt;&gt;</span><span> </span><span class="token" style="color:#00e0e0">8</span><span class="token" style="color:#fefefe">)</span><span> </span><span class="token" style="color:#00e0e0">|</span><span> </span><span class="token" style="color:#00e0e0">0x80</span><span class="token" style="color:#fefefe">)</span><span> </span><span class="token" style="color:#00e0e0">|</span><span> </span><span class="token" style="color:#00e0e0">0x40</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span> </span><span class="token" style="color:#d4d0ab">// Set R/W and Burst bits</span><span>
</span><span>        </span><span class="token" style="color:#ffd700">SPI_Transfer</span><span class="token" style="color:#fefefe">(</span><span>addr </span><span class="token" style="color:#00e0e0">&amp;</span><span> </span><span class="token" style="color:#00e0e0">0xFF</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token" style="color:#fefefe">}</span><span>
</span><span>    </span><span class="token" style="color:#00e0e0">else</span><span>
</span><span>    </span><span class="token" style="color:#fefefe">{</span><span>
</span><span>        </span><span class="token" style="color:#ffd700">SPI_Transfer</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#fefefe">(</span><span class="token class-name">uint8_t</span><span class="token" style="color:#fefefe">)</span><span>addr </span><span class="token" style="color:#00e0e0">|</span><span> </span><span class="token" style="color:#00e0e0">0x80</span><span class="token" style="color:#fefefe">)</span><span> </span><span class="token" style="color:#00e0e0">|</span><span> </span><span class="token" style="color:#00e0e0">0x40</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span> </span><span class="token" style="color:#d4d0ab">// Set R/W and Burst bits</span><span>
</span><span>    </span><span class="token" style="color:#fefefe">}</span><span>
</span><span>    </span><span class="token" style="color:#00e0e0">for</span><span> </span><span class="token" style="color:#fefefe">(</span><span class="token class-name">uint8_t</span><span> i </span><span class="token" style="color:#00e0e0">=</span><span> </span><span class="token" style="color:#00e0e0">0</span><span class="token" style="color:#fefefe">;</span><span> i </span><span class="token" style="color:#00e0e0">&lt;</span><span> length</span><span class="token" style="color:#fefefe">;</span><span> i</span><span class="token" style="color:#00e0e0">++</span><span class="token" style="color:#fefefe">)</span><span>
</span><span>    </span><span class="token" style="color:#fefefe">{</span><span>
</span><span>        buffer</span><span class="token" style="color:#fefefe">[</span><span>i</span><span class="token" style="color:#fefefe">]</span><span> </span><span class="token" style="color:#00e0e0">=</span><span> </span><span class="token" style="color:#ffd700">SPI_Transfer</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#00e0e0">0x00</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token" style="color:#fefefe">}</span><span>
</span><span>    </span><span class="token" style="color:#ffd700">SPI_Deselect</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span></span><span class="token" style="color:#fefefe">}</span><span>
</span>
<span></span><span class="token" style="color:#d4d0ab">// Function to write multiple registers in burst</span><span>
</span><span></span><span class="token" style="color:#00e0e0">void</span><span> </span><span class="token" style="color:#ffd700">PHY_CC1201_WriteBurst</span><span class="token" style="color:#fefefe">(</span><span class="token class-name">uint16_t</span><span> addr</span><span class="token" style="color:#fefefe">,</span><span> </span><span class="token" style="color:#00e0e0">const</span><span> </span><span class="token class-name">uint8_t</span><span> </span><span class="token" style="color:#00e0e0">*</span><span>buffer</span><span class="token" style="color:#fefefe">,</span><span> </span><span class="token class-name">uint8_t</span><span> length</span><span class="token" style="color:#fefefe">)</span><span>
</span><span></span><span class="token" style="color:#fefefe">{</span><span>
</span><span>    </span><span class="token" style="color:#ffd700">SPI_Select</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token" style="color:#00e0e0">if</span><span> </span><span class="token" style="color:#fefefe">(</span><span>addr </span><span class="token" style="color:#00e0e0">&gt;</span><span> </span><span class="token" style="color:#00e0e0">0x2F</span><span class="token" style="color:#fefefe">)</span><span> </span><span class="token" style="color:#d4d0ab">// Extended address space</span><span>
</span><span>    </span><span class="token" style="color:#fefefe">{</span><span>
</span><span>        </span><span class="token" style="color:#ffd700">SPI_Transfer</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#fefefe">(</span><span>addr </span><span class="token" style="color:#00e0e0">&gt;&gt;</span><span> </span><span class="token" style="color:#00e0e0">8</span><span class="token" style="color:#fefefe">)</span><span> </span><span class="token" style="color:#00e0e0">&amp;</span><span> </span><span class="token" style="color:#00e0e0">0x7F</span><span class="token" style="color:#fefefe">)</span><span> </span><span class="token" style="color:#00e0e0">|</span><span> </span><span class="token" style="color:#00e0e0">0x40</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span> </span><span class="token" style="color:#d4d0ab">// Set Burst bit</span><span>
</span><span>        </span><span class="token" style="color:#ffd700">SPI_Transfer</span><span class="token" style="color:#fefefe">(</span><span>addr </span><span class="token" style="color:#00e0e0">&amp;</span><span> </span><span class="token" style="color:#00e0e0">0xFF</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token" style="color:#fefefe">}</span><span>
</span><span>    </span><span class="token" style="color:#00e0e0">else</span><span>
</span><span>    </span><span class="token" style="color:#fefefe">{</span><span>
</span><span>        </span><span class="token" style="color:#ffd700">SPI_Transfer</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#fefefe">(</span><span class="token class-name">uint8_t</span><span class="token" style="color:#fefefe">)</span><span>addr </span><span class="token" style="color:#00e0e0">&amp;</span><span> </span><span class="token" style="color:#00e0e0">0x7F</span><span class="token" style="color:#fefefe">)</span><span> </span><span class="token" style="color:#00e0e0">|</span><span> </span><span class="token" style="color:#00e0e0">0x40</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span> </span><span class="token" style="color:#d4d0ab">// Set Burst bit</span><span>
</span><span>    </span><span class="token" style="color:#fefefe">}</span><span>
</span><span>    </span><span class="token" style="color:#00e0e0">for</span><span> </span><span class="token" style="color:#fefefe">(</span><span class="token class-name">uint8_t</span><span> i </span><span class="token" style="color:#00e0e0">=</span><span> </span><span class="token" style="color:#00e0e0">0</span><span class="token" style="color:#fefefe">;</span><span> i </span><span class="token" style="color:#00e0e0">&lt;</span><span> length</span><span class="token" style="color:#fefefe">;</span><span> i</span><span class="token" style="color:#00e0e0">++</span><span class="token" style="color:#fefefe">)</span><span>
</span><span>    </span><span class="token" style="color:#fefefe">{</span><span>
</span><span>        </span><span class="token" style="color:#ffd700">SPI_Transfer</span><span class="token" style="color:#fefefe">(</span><span>buffer</span><span class="token" style="color:#fefefe">[</span><span>i</span><span class="token" style="color:#fefefe">]</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token" style="color:#fefefe">}</span><span>
</span><span>    </span><span class="token" style="color:#ffd700">SPI_Deselect</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span></span><span class="token" style="color:#fefefe">}</span><span>
</span>
<span></span><span class="token" style="color:#d4d0ab">// Function to send a command strobe</span><span>
</span><span></span><span class="token" style="color:#00e0e0">void</span><span> </span><span class="token" style="color:#ffd700">PHY_CC1201_Strobe</span><span class="token" style="color:#fefefe">(</span><span class="token class-name">uint8_t</span><span> strobe</span><span class="token" style="color:#fefefe">)</span><span>
</span><span></span><span class="token" style="color:#fefefe">{</span><span>
</span><span>    </span><span class="token" style="color:#ffd700">SPI_Select</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token" style="color:#ffd700">SPI_Transfer</span><span class="token" style="color:#fefefe">(</span><span>strobe</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token" style="color:#ffd700">SPI_Deselect</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span></span><span class="token" style="color:#fefefe">}</span><span>
</span>
<span></span><span class="token" style="color:#d4d0ab">// Function to get the status byte</span><span>
</span><span></span><span class="token class-name">uint8_t</span><span> </span><span class="token" style="color:#ffd700">PHY_CC1201_GetStatus</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#00e0e0">void</span><span class="token" style="color:#fefefe">)</span><span>
</span><span></span><span class="token" style="color:#fefefe">{</span><span>
</span><span>    </span><span class="token class-name">uint8_t</span><span> status</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token" style="color:#ffd700">SPI_Select</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    status </span><span class="token" style="color:#00e0e0">=</span><span> </span><span class="token" style="color:#ffd700">SPI_Transfer</span><span class="token" style="color:#fefefe">(</span><span>CC1201_SNOP</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token" style="color:#ffd700">SPI_Deselect</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token" style="color:#00e0e0">return</span><span> status</span><span class="token" style="color:#fefefe">;</span><span>
</span><span></span><span class="token" style="color:#fefefe">}</span><span>
</span>
<span></span><span class="token" style="color:#d4d0ab">// Function to write data to the TX FIFO</span><span>
</span><span></span><span class="token" style="color:#00e0e0">void</span><span> </span><span class="token" style="color:#ffd700">PHY_CC1201_WriteTXFIFO</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#00e0e0">const</span><span> </span><span class="token class-name">uint8_t</span><span> </span><span class="token" style="color:#00e0e0">*</span><span>buffer</span><span class="token" style="color:#fefefe">,</span><span> </span><span class="token class-name">uint8_t</span><span> length</span><span class="token" style="color:#fefefe">)</span><span>
</span><span></span><span class="token" style="color:#fefefe">{</span><span>
</span><span>    </span><span class="token" style="color:#ffd700">SPI_Select</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token" style="color:#ffd700">SPI_Transfer</span><span class="token" style="color:#fefefe">(</span><span>CC1201_TXFIFO </span><span class="token" style="color:#00e0e0">|</span><span> </span><span class="token" style="color:#00e0e0">0x40</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span> </span><span class="token" style="color:#d4d0ab">// Burst write to TX FIFO</span><span>
</span><span>    </span><span class="token" style="color:#00e0e0">for</span><span> </span><span class="token" style="color:#fefefe">(</span><span class="token class-name">uint8_t</span><span> i </span><span class="token" style="color:#00e0e0">=</span><span> </span><span class="token" style="color:#00e0e0">0</span><span class="token" style="color:#fefefe">;</span><span> i </span><span class="token" style="color:#00e0e0">&lt;</span><span> length</span><span class="token" style="color:#fefefe">;</span><span> i</span><span class="token" style="color:#00e0e0">++</span><span class="token" style="color:#fefefe">)</span><span>
</span><span>    </span><span class="token" style="color:#fefefe">{</span><span>
</span><span>        </span><span class="token" style="color:#ffd700">SPI_Transfer</span><span class="token" style="color:#fefefe">(</span><span>buffer</span><span class="token" style="color:#fefefe">[</span><span>i</span><span class="token" style="color:#fefefe">]</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token" style="color:#fefefe">}</span><span>
</span><span>    </span><span class="token" style="color:#ffd700">SPI_Deselect</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span></span><span class="token" style="color:#fefefe">}</span><span>
</span>
<span></span><span class="token" style="color:#d4d0ab">// Function to read data from the RX FIFO</span><span>
</span><span></span><span class="token class-name">uint8_t</span><span> </span><span class="token" style="color:#ffd700">PHY_CC1201_ReadRXFIFO</span><span class="token" style="color:#fefefe">(</span><span class="token class-name">uint8_t</span><span> </span><span class="token" style="color:#00e0e0">*</span><span>buffer</span><span class="token" style="color:#fefefe">,</span><span> </span><span class="token class-name">uint8_t</span><span> length</span><span class="token" style="color:#fefefe">)</span><span>
</span><span></span><span class="token" style="color:#fefefe">{</span><span>
</span><span>    </span><span class="token class-name">uint8_t</span><span> bytesAvailable </span><span class="token" style="color:#00e0e0">=</span><span> </span><span class="token" style="color:#ffd700">PHY_CC1201_ReadRegister</span><span class="token" style="color:#fefefe">(</span><span>CC1201_NUM_RXBYTES</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token" style="color:#00e0e0">if</span><span> </span><span class="token" style="color:#fefefe">(</span><span>bytesAvailable </span><span class="token" style="color:#00e0e0">&lt;</span><span> length</span><span class="token" style="color:#fefefe">)</span><span>
</span><span>        length </span><span class="token" style="color:#00e0e0">=</span><span> bytesAvailable</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token" style="color:#ffd700">SPI_Select</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token" style="color:#ffd700">SPI_Transfer</span><span class="token" style="color:#fefefe">(</span><span>CC1201_RXFIFO </span><span class="token" style="color:#00e0e0">|</span><span> </span><span class="token" style="color:#00e0e0">0x80</span><span> </span><span class="token" style="color:#00e0e0">|</span><span> </span><span class="token" style="color:#00e0e0">0x40</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span> </span><span class="token" style="color:#d4d0ab">// Burst read from RX FIFO</span><span>
</span><span>    </span><span class="token" style="color:#00e0e0">for</span><span> </span><span class="token" style="color:#fefefe">(</span><span class="token class-name">uint8_t</span><span> i </span><span class="token" style="color:#00e0e0">=</span><span> </span><span class="token" style="color:#00e0e0">0</span><span class="token" style="color:#fefefe">;</span><span> i </span><span class="token" style="color:#00e0e0">&lt;</span><span> length</span><span class="token" style="color:#fefefe">;</span><span> i</span><span class="token" style="color:#00e0e0">++</span><span class="token" style="color:#fefefe">)</span><span>
</span><span>    </span><span class="token" style="color:#fefefe">{</span><span>
</span><span>        buffer</span><span class="token" style="color:#fefefe">[</span><span>i</span><span class="token" style="color:#fefefe">]</span><span> </span><span class="token" style="color:#00e0e0">=</span><span> </span><span class="token" style="color:#ffd700">SPI_Transfer</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#00e0e0">0x00</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token" style="color:#fefefe">}</span><span>
</span><span>    </span><span class="token" style="color:#ffd700">SPI_Deselect</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token" style="color:#00e0e0">return</span><span> length</span><span class="token" style="color:#fefefe">;</span><span>
</span><span></span><span class="token" style="color:#fefefe">}</span><span>
</span>
<span></span><span class="token" style="color:#d4d0ab">// Function to flush the RX FIFO</span><span>
</span><span></span><span class="token" style="color:#00e0e0">void</span><span> </span><span class="token" style="color:#ffd700">PHY_CC1201_FlushRXFIFO</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#00e0e0">void</span><span class="token" style="color:#fefefe">)</span><span>
</span><span></span><span class="token" style="color:#fefefe">{</span><span>
</span><span>    </span><span class="token" style="color:#ffd700">PHY_CC1201_Strobe</span><span class="token" style="color:#fefefe">(</span><span>CC1201_SFRX</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span></span><span class="token" style="color:#fefefe">}</span><span>
</span>
<span></span><span class="token" style="color:#d4d0ab">// Function to flush the TX FIFO</span><span>
</span><span></span><span class="token" style="color:#00e0e0">void</span><span> </span><span class="token" style="color:#ffd700">PHY_CC1201_FlushTXFIFO</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#00e0e0">void</span><span class="token" style="color:#fefefe">)</span><span>
</span><span></span><span class="token" style="color:#fefefe">{</span><span>
</span><span>    </span><span class="token" style="color:#ffd700">PHY_CC1201_Strobe</span><span class="token" style="color:#fefefe">(</span><span>CC1201_SFTX</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span></span><span class="token" style="color:#fefefe">}</span></code></div></div></pre>
<hr/>
<h3>2. Data Link Layer</h3>
<p><strong>mac_cc1201.h</strong></p>
<pre><div><div style="display:flex;justify-content:space-between;width:100%;background-color:rgb(50, 50, 50);font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;border-top-left-radius:0.3rem;border-top-right-radius:0.3rem;border-bottom-left-radius:0;border-bottom-right-radius:0"><span style="text-decoration:none;color:gray;padding:2px;margin:2px 10px 0 10px">&lt;C&gt;</span></div><div style="color:#f8f8f2;background:#2b2b2b;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:0;overflow:auto;border-radius:0.3em;margin-top:0;border-top-left-radius:0;border-top-right-radius:0;border-bottom-left-radius:0.3rem;border-bottom-right-radius:0.3rem;border:none"><code class="language-c" style="color:#f8f8f2;background:none;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">ifndef</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro expression" style="color:#ffa07a">MAC_CC1201_H</span><span>
</span><span></span><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">define</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro macro-name" style="color:#ffa07a">MAC_CC1201_H</span><span>
</span>
<span></span><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">include</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro" style="color:#abe338">&lt;stdint.h&gt;</span><span>
</span><span></span><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">include</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro" style="color:#abe338">&lt;stdbool.h&gt;</span><span>
</span><span></span><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">include</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro" style="color:#abe338">&quot;phy_cc1201.h&quot;</span><span>
</span>
<span></span><span class="token" style="color:#d4d0ab">// Packet structure</span><span>
</span><span></span><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">define</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro macro-name" style="color:#ffa07a">MAX_PAYLOAD_SIZE</span><span class="token macro" style="color:#ffa07a">    </span><span class="token macro expression" style="color:#00e0e0">255</span><span>
</span>
<span></span><span class="token" style="color:#00e0e0">typedef</span><span> </span><span class="token" style="color:#00e0e0">struct</span><span> </span><span class="token" style="color:#fefefe">{</span><span>
</span><span>    </span><span class="token class-name">uint8_t</span><span> length</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token class-name">uint8_t</span><span> address</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token class-name">uint8_t</span><span> payload</span><span class="token" style="color:#fefefe">[</span><span>MAX_PAYLOAD_SIZE</span><span class="token" style="color:#fefefe">]</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token class-name">uint8_t</span><span> crc</span><span class="token" style="color:#fefefe">[</span><span class="token" style="color:#00e0e0">2</span><span class="token" style="color:#fefefe">]</span><span class="token" style="color:#fefefe">;</span><span>
</span><span></span><span class="token" style="color:#fefefe">}</span><span> CC1201_Packet_t</span><span class="token" style="color:#fefefe">;</span><span>
</span>
<span></span><span class="token" style="color:#d4d0ab">// Function prototypes</span><span>
</span><span></span><span class="token" style="color:#00e0e0">void</span><span> </span><span class="token" style="color:#ffd700">MAC_CC1201_Init</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#00e0e0">void</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span></span><span class="token" style="color:#00e0e0">void</span><span> </span><span class="token" style="color:#ffd700">MAC_CC1201_SetAddress</span><span class="token" style="color:#fefefe">(</span><span class="token class-name">uint8_t</span><span> address</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span></span><span class="token" style="color:#00e0e0">void</span><span> </span><span class="token" style="color:#ffd700">MAC_CC1201_SetChannel</span><span class="token" style="color:#fefefe">(</span><span class="token class-name">uint8_t</span><span> channel</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>bool </span><span class="token" style="color:#ffd700">MAC_CC1201_SendPacket</span><span class="token" style="color:#fefefe">(</span><span class="token class-name">uint8_t</span><span> destAddress</span><span class="token" style="color:#fefefe">,</span><span> </span><span class="token" style="color:#00e0e0">const</span><span> </span><span class="token class-name">uint8_t</span><span> </span><span class="token" style="color:#00e0e0">*</span><span>data</span><span class="token" style="color:#fefefe">,</span><span> </span><span class="token class-name">uint8_t</span><span> length</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>bool </span><span class="token" style="color:#ffd700">MAC_CC1201_ReceivePacket</span><span class="token" style="color:#fefefe">(</span><span>CC1201_Packet_t </span><span class="token" style="color:#00e0e0">*</span><span>packet</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span></span><span class="token" style="color:#00e0e0">void</span><span> </span><span class="token" style="color:#ffd700">MAC_CC1201_SetRXState</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#00e0e0">void</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span></span><span class="token" style="color:#00e0e0">void</span><span> </span><span class="token" style="color:#ffd700">MAC_CC1201_SetTXState</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#00e0e0">void</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span>
<span></span><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">endif</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro" style="color:#d4d0ab">// MAC_CC1201_H</span></code></div></div></pre>
<p><strong>mac_cc1201.c</strong></p>
<pre><div><div style="display:flex;justify-content:space-between;width:100%;background-color:rgb(50, 50, 50);font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;border-top-left-radius:0.3rem;border-top-right-radius:0.3rem;border-bottom-left-radius:0;border-bottom-right-radius:0"><span style="text-decoration:none;color:gray;padding:2px;margin:2px 10px 0 10px">&lt;C&gt;</span></div><div style="color:#f8f8f2;background:#2b2b2b;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:0;overflow:auto;border-radius:0.3em;margin-top:0;border-top-left-radius:0;border-top-right-radius:0;border-bottom-left-radius:0.3rem;border-bottom-right-radius:0.3rem;border:none"><code class="language-c" style="color:#f8f8f2;background:none;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">include</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro" style="color:#abe338">&quot;mac_cc1201.h&quot;</span><span>
</span>
<span></span><span class="token" style="color:#d4d0ab">// Internal variables</span><span>
</span><span></span><span class="token" style="color:#00e0e0">static</span><span> </span><span class="token class-name">uint8_t</span><span> nodeAddress </span><span class="token" style="color:#00e0e0">=</span><span> </span><span class="token" style="color:#00e0e0">0</span><span class="token" style="color:#fefefe">;</span><span>
</span><span></span><span class="token" style="color:#00e0e0">static</span><span> </span><span class="token class-name">uint8_t</span><span> currentChannel </span><span class="token" style="color:#00e0e0">=</span><span> </span><span class="token" style="color:#00e0e0">0</span><span class="token" style="color:#fefefe">;</span><span>
</span>
<span></span><span class="token" style="color:#d4d0ab">// Function to initialize the MAC layer</span><span>
</span><span></span><span class="token" style="color:#00e0e0">void</span><span> </span><span class="token" style="color:#ffd700">MAC_CC1201_Init</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#00e0e0">void</span><span class="token" style="color:#fefefe">)</span><span>
</span><span></span><span class="token" style="color:#fefefe">{</span><span>
</span><span>    </span><span class="token" style="color:#ffd700">PHY_CC1201_Init</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span>
<span>    </span><span class="token" style="color:#d4d0ab">// Write configuration registers (use values from SmartRF Studio or datasheet)</span><span>
</span>
<span>    </span><span class="token" style="color:#d4d0ab">// Example: Setting IOCFG3 register</span><span>
</span><span>    </span><span class="token" style="color:#ffd700">PHY_CC1201_WriteRegister</span><span class="token" style="color:#fefefe">(</span><span>CC1201_IOCFG3</span><span class="token" style="color:#fefefe">,</span><span> </span><span class="token" style="color:#00e0e0">0xB0</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span>
<span>    </span><span class="token" style="color:#d4d0ab">// Configure packet length mode to variable</span><span>
</span><span>    </span><span class="token" style="color:#ffd700">PHY_CC1201_WriteRegister</span><span class="token" style="color:#fefefe">(</span><span>CC1201_PKT_CFG0</span><span class="token" style="color:#fefefe">,</span><span> </span><span class="token" style="color:#00e0e0">0x01</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span> </span><span class="token" style="color:#d4d0ab">// LENGTH_CONFIG = 1</span><span>
</span>
<span>    </span><span class="token" style="color:#d4d0ab">// Set default address</span><span>
</span><span>    </span><span class="token" style="color:#ffd700">MAC_CC1201_SetAddress</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#00e0e0">0x01</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span>
<span>    </span><span class="token" style="color:#d4d0ab">// Flush FIFOs</span><span>
</span><span>    </span><span class="token" style="color:#ffd700">PHY_CC1201_FlushRXFIFO</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token" style="color:#ffd700">PHY_CC1201_FlushTXFIFO</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span>
<span>    </span><span class="token" style="color:#d4d0ab">// Calibrate frequency synthesizer</span><span>
</span><span>    </span><span class="token" style="color:#ffd700">PHY_CC1201_Strobe</span><span class="token" style="color:#fefefe">(</span><span>CC1201_SCAL</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span></span><span class="token" style="color:#fefefe">}</span><span>
</span>
<span></span><span class="token" style="color:#d4d0ab">// Function to set the node address</span><span>
</span><span></span><span class="token" style="color:#00e0e0">void</span><span> </span><span class="token" style="color:#ffd700">MAC_CC1201_SetAddress</span><span class="token" style="color:#fefefe">(</span><span class="token class-name">uint8_t</span><span> address</span><span class="token" style="color:#fefefe">)</span><span>
</span><span></span><span class="token" style="color:#fefefe">{</span><span>
</span><span>    nodeAddress </span><span class="token" style="color:#00e0e0">=</span><span> address</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token" style="color:#ffd700">PHY_CC1201_WriteRegister</span><span class="token" style="color:#fefefe">(</span><span>CC1201_DEV_ADDR</span><span class="token" style="color:#fefefe">,</span><span> address</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span></span><span class="token" style="color:#fefefe">}</span><span>
</span>
<span></span><span class="token" style="color:#d4d0ab">// Function to set the communication channel (frequency)</span><span>
</span><span></span><span class="token" style="color:#00e0e0">void</span><span> </span><span class="token" style="color:#ffd700">MAC_CC1201_SetChannel</span><span class="token" style="color:#fefefe">(</span><span class="token class-name">uint8_t</span><span> channel</span><span class="token" style="color:#fefefe">)</span><span>
</span><span></span><span class="token" style="color:#fefefe">{</span><span>
</span><span>    currentChannel </span><span class="token" style="color:#00e0e0">=</span><span> channel</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token" style="color:#d4d0ab">// Calculate the frequency settings based on the channel</span><span>
</span><span>    </span><span class="token" style="color:#d4d0ab">// This is an example; actual calculation depends on frequency band and channel spacing</span><span>
</span>
<span>    </span><span class="token class-name">uint32_t</span><span> frequency </span><span class="token" style="color:#00e0e0">=</span><span> </span><span class="token" style="color:#00e0e0">0x00186655</span><span> </span><span class="token" style="color:#00e0e0">+</span><span> </span><span class="token" style="color:#fefefe">(</span><span>channel </span><span class="token" style="color:#00e0e0">*</span><span> </span><span class="token" style="color:#00e0e0">0x00001333</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span> </span><span class="token" style="color:#d4d0ab">// Example frequency calculation</span><span>
</span><span>    </span><span class="token" style="color:#ffd700">PHY_CC1201_WriteRegister</span><span class="token" style="color:#fefefe">(</span><span>CC1201_FREQ2</span><span class="token" style="color:#fefefe">,</span><span> </span><span class="token" style="color:#fefefe">(</span><span class="token class-name">uint8_t</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">(</span><span>frequency </span><span class="token" style="color:#00e0e0">&gt;&gt;</span><span> </span><span class="token" style="color:#00e0e0">16</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token" style="color:#ffd700">PHY_CC1201_WriteRegister</span><span class="token" style="color:#fefefe">(</span><span>CC1201_FREQ1</span><span class="token" style="color:#fefefe">,</span><span> </span><span class="token" style="color:#fefefe">(</span><span class="token class-name">uint8_t</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">(</span><span>frequency </span><span class="token" style="color:#00e0e0">&gt;&gt;</span><span> </span><span class="token" style="color:#00e0e0">8</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token" style="color:#ffd700">PHY_CC1201_WriteRegister</span><span class="token" style="color:#fefefe">(</span><span>CC1201_FREQ0</span><span class="token" style="color:#fefefe">,</span><span> </span><span class="token" style="color:#fefefe">(</span><span class="token class-name">uint8_t</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">(</span><span>frequency</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span>
<span>    </span><span class="token" style="color:#d4d0ab">// Calibrate synthesizer after frequency change</span><span>
</span><span>    </span><span class="token" style="color:#ffd700">PHY_CC1201_Strobe</span><span class="token" style="color:#fefefe">(</span><span>CC1201_SCAL</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span></span><span class="token" style="color:#fefefe">}</span><span>
</span>
<span></span><span class="token" style="color:#d4d0ab">// Function to send a packet</span><span>
</span><span>bool </span><span class="token" style="color:#ffd700">MAC_CC1201_SendPacket</span><span class="token" style="color:#fefefe">(</span><span class="token class-name">uint8_t</span><span> destAddress</span><span class="token" style="color:#fefefe">,</span><span> </span><span class="token" style="color:#00e0e0">const</span><span> </span><span class="token class-name">uint8_t</span><span> </span><span class="token" style="color:#00e0e0">*</span><span>data</span><span class="token" style="color:#fefefe">,</span><span> </span><span class="token class-name">uint8_t</span><span> length</span><span class="token" style="color:#fefefe">)</span><span>
</span><span></span><span class="token" style="color:#fefefe">{</span><span>
</span><span>    </span><span class="token" style="color:#00e0e0">if</span><span> </span><span class="token" style="color:#fefefe">(</span><span>length </span><span class="token" style="color:#00e0e0">&gt;</span><span> MAX_PAYLOAD_SIZE</span><span class="token" style="color:#fefefe">)</span><span>
</span><span>        </span><span class="token" style="color:#00e0e0">return</span><span> false</span><span class="token" style="color:#fefefe">;</span><span>
</span>
<span>    </span><span class="token" style="color:#d4d0ab">// Build the packet</span><span>
</span><span>    </span><span class="token class-name">uint8_t</span><span> buffer</span><span class="token" style="color:#fefefe">[</span><span>MAX_PAYLOAD_SIZE </span><span class="token" style="color:#00e0e0">+</span><span> </span><span class="token" style="color:#00e0e0">2</span><span class="token" style="color:#fefefe">]</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    buffer</span><span class="token" style="color:#fefefe">[</span><span class="token" style="color:#00e0e0">0</span><span class="token" style="color:#fefefe">]</span><span> </span><span class="token" style="color:#00e0e0">=</span><span> length </span><span class="token" style="color:#00e0e0">+</span><span> </span><span class="token" style="color:#00e0e0">1</span><span class="token" style="color:#fefefe">;</span><span> </span><span class="token" style="color:#d4d0ab">// Length byte including address</span><span>
</span><span>    buffer</span><span class="token" style="color:#fefefe">[</span><span class="token" style="color:#00e0e0">1</span><span class="token" style="color:#fefefe">]</span><span> </span><span class="token" style="color:#00e0e0">=</span><span> destAddress</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token" style="color:#00e0e0">for</span><span> </span><span class="token" style="color:#fefefe">(</span><span class="token class-name">uint8_t</span><span> i </span><span class="token" style="color:#00e0e0">=</span><span> </span><span class="token" style="color:#00e0e0">0</span><span class="token" style="color:#fefefe">;</span><span> i </span><span class="token" style="color:#00e0e0">&lt;</span><span> length</span><span class="token" style="color:#fefefe">;</span><span> i</span><span class="token" style="color:#00e0e0">++</span><span class="token" style="color:#fefefe">)</span><span>
</span><span>    </span><span class="token" style="color:#fefefe">{</span><span>
</span><span>        buffer</span><span class="token" style="color:#fefefe">[</span><span>i </span><span class="token" style="color:#00e0e0">+</span><span> </span><span class="token" style="color:#00e0e0">2</span><span class="token" style="color:#fefefe">]</span><span> </span><span class="token" style="color:#00e0e0">=</span><span> data</span><span class="token" style="color:#fefefe">[</span><span>i</span><span class="token" style="color:#fefefe">]</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token" style="color:#fefefe">}</span><span>
</span>
<span>    </span><span class="token" style="color:#d4d0ab">// Flush TX FIFO</span><span>
</span><span>    </span><span class="token" style="color:#ffd700">PHY_CC1201_FlushTXFIFO</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span>
<span>    </span><span class="token" style="color:#d4d0ab">// Write packet to TX FIFO</span><span>
</span><span>    </span><span class="token" style="color:#ffd700">PHY_CC1201_WriteTXFIFO</span><span class="token" style="color:#fefefe">(</span><span>buffer</span><span class="token" style="color:#fefefe">,</span><span> length </span><span class="token" style="color:#00e0e0">+</span><span> </span><span class="token" style="color:#00e0e0">2</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span>
<span>    </span><span class="token" style="color:#d4d0ab">// Enter TX state</span><span>
</span><span>    </span><span class="token" style="color:#ffd700">PHY_CC1201_Strobe</span><span class="token" style="color:#fefefe">(</span><span>CC1201_STX</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span>
<span>    </span><span class="token" style="color:#d4d0ab">// Wait for transmission to complete (poll status register or use GDO signals)</span><span>
</span><span>    </span><span class="token" style="color:#00e0e0">while</span><span> </span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#ffd700">PHY_CC1201_GetStatus</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#fefefe">)</span><span> </span><span class="token" style="color:#00e0e0">&amp;</span><span> CC1201_STATUS_STATE_MASK</span><span class="token" style="color:#fefefe">)</span><span> </span><span class="token" style="color:#00e0e0">==</span><span> CC1201_STATUS_STATE_TX</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span>
<span>    </span><span class="token" style="color:#d4d0ab">// Check for TX FIFO underflow</span><span>
</span><span>    </span><span class="token class-name">uint8_t</span><span> marcState </span><span class="token" style="color:#00e0e0">=</span><span> </span><span class="token" style="color:#ffd700">PHY_CC1201_ReadRegister</span><span class="token" style="color:#fefefe">(</span><span>CC1201_MARCSTATE</span><span class="token" style="color:#fefefe">)</span><span> </span><span class="token" style="color:#00e0e0">&amp;</span><span> </span><span class="token" style="color:#00e0e0">0x1F</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token" style="color:#00e0e0">if</span><span> </span><span class="token" style="color:#fefefe">(</span><span>marcState </span><span class="token" style="color:#00e0e0">==</span><span> </span><span class="token" style="color:#00e0e0">0x16</span><span class="token" style="color:#fefefe">)</span><span> </span><span class="token" style="color:#d4d0ab">// TXFIFO_ERR</span><span>
</span><span>    </span><span class="token" style="color:#fefefe">{</span><span>
</span><span>        </span><span class="token" style="color:#ffd700">PHY_CC1201_FlushTXFIFO</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>        </span><span class="token" style="color:#00e0e0">return</span><span> false</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token" style="color:#fefefe">}</span><span>
</span>
<span>    </span><span class="token" style="color:#00e0e0">return</span><span> true</span><span class="token" style="color:#fefefe">;</span><span>
</span><span></span><span class="token" style="color:#fefefe">}</span><span>
</span>
<span></span><span class="token" style="color:#d4d0ab">// Function to receive a packet</span><span>
</span><span>bool </span><span class="token" style="color:#ffd700">MAC_CC1201_ReceivePacket</span><span class="token" style="color:#fefefe">(</span><span>CC1201_Packet_t </span><span class="token" style="color:#00e0e0">*</span><span>packet</span><span class="token" style="color:#fefefe">)</span><span>
</span><span></span><span class="token" style="color:#fefefe">{</span><span>
</span><span>    </span><span class="token class-name">uint8_t</span><span> rxBytes </span><span class="token" style="color:#00e0e0">=</span><span> </span><span class="token" style="color:#ffd700">PHY_CC1201_ReadRegister</span><span class="token" style="color:#fefefe">(</span><span>CC1201_NUM_RXBYTES</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token" style="color:#00e0e0">if</span><span> </span><span class="token" style="color:#fefefe">(</span><span>rxBytes </span><span class="token" style="color:#00e0e0">==</span><span> </span><span class="token" style="color:#00e0e0">0</span><span class="token" style="color:#fefefe">)</span><span>
</span><span>        </span><span class="token" style="color:#00e0e0">return</span><span> false</span><span class="token" style="color:#fefefe">;</span><span>
</span>
<span>    </span><span class="token" style="color:#d4d0ab">// Read packet length</span><span>
</span><span>    </span><span class="token class-name">uint8_t</span><span> pktLen</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token" style="color:#ffd700">PHY_CC1201_ReadBurst</span><span class="token" style="color:#fefefe">(</span><span>CC1201_RXFIFO</span><span class="token" style="color:#fefefe">,</span><span> </span><span class="token" style="color:#00e0e0">&amp;</span><span>pktLen</span><span class="token" style="color:#fefefe">,</span><span> </span><span class="token" style="color:#00e0e0">1</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span>
<span>    </span><span class="token" style="color:#00e0e0">if</span><span> </span><span class="token" style="color:#fefefe">(</span><span>pktLen </span><span class="token" style="color:#00e0e0">&gt;</span><span> </span><span class="token" style="color:#fefefe">(</span><span>MAX_PAYLOAD_SIZE </span><span class="token" style="color:#00e0e0">+</span><span> </span><span class="token" style="color:#00e0e0">1</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">)</span><span> </span><span class="token" style="color:#d4d0ab">// +1 for address</span><span>
</span><span>    </span><span class="token" style="color:#fefefe">{</span><span>
</span><span>        </span><span class="token" style="color:#ffd700">PHY_CC1201_FlushRXFIFO</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>        </span><span class="token" style="color:#00e0e0">return</span><span> false</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token" style="color:#fefefe">}</span><span>
</span>
<span>    </span><span class="token" style="color:#d4d0ab">// Read rest of the packet</span><span>
</span><span>    </span><span class="token class-name">uint8_t</span><span> buffer</span><span class="token" style="color:#fefefe">[</span><span>MAX_PAYLOAD_SIZE </span><span class="token" style="color:#00e0e0">+</span><span> </span><span class="token" style="color:#00e0e0">3</span><span class="token" style="color:#fefefe">]</span><span class="token" style="color:#fefefe">;</span><span> </span><span class="token" style="color:#d4d0ab">// +2 for CRC</span><span>
</span><span>    </span><span class="token" style="color:#ffd700">PHY_CC1201_ReadBurst</span><span class="token" style="color:#fefefe">(</span><span>CC1201_RXFIFO</span><span class="token" style="color:#fefefe">,</span><span> buffer</span><span class="token" style="color:#fefefe">,</span><span> pktLen </span><span class="token" style="color:#00e0e0">+</span><span> </span><span class="token" style="color:#00e0e0">2</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span>
<span>    packet</span><span class="token" style="color:#00e0e0">-&gt;</span><span>length </span><span class="token" style="color:#00e0e0">=</span><span> pktLen </span><span class="token" style="color:#00e0e0">-</span><span> </span><span class="token" style="color:#00e0e0">1</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    packet</span><span class="token" style="color:#00e0e0">-&gt;</span><span>address </span><span class="token" style="color:#00e0e0">=</span><span> buffer</span><span class="token" style="color:#fefefe">[</span><span class="token" style="color:#00e0e0">0</span><span class="token" style="color:#fefefe">]</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token" style="color:#00e0e0">for</span><span> </span><span class="token" style="color:#fefefe">(</span><span class="token class-name">uint8_t</span><span> i </span><span class="token" style="color:#00e0e0">=</span><span> </span><span class="token" style="color:#00e0e0">0</span><span class="token" style="color:#fefefe">;</span><span> i </span><span class="token" style="color:#00e0e0">&lt;</span><span> packet</span><span class="token" style="color:#00e0e0">-&gt;</span><span>length</span><span class="token" style="color:#fefefe">;</span><span> i</span><span class="token" style="color:#00e0e0">++</span><span class="token" style="color:#fefefe">)</span><span>
</span><span>    </span><span class="token" style="color:#fefefe">{</span><span>
</span><span>        packet</span><span class="token" style="color:#00e0e0">-&gt;</span><span>payload</span><span class="token" style="color:#fefefe">[</span><span>i</span><span class="token" style="color:#fefefe">]</span><span> </span><span class="token" style="color:#00e0e0">=</span><span> buffer</span><span class="token" style="color:#fefefe">[</span><span>i </span><span class="token" style="color:#00e0e0">+</span><span> </span><span class="token" style="color:#00e0e0">1</span><span class="token" style="color:#fefefe">]</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token" style="color:#fefefe">}</span><span>
</span><span>    packet</span><span class="token" style="color:#00e0e0">-&gt;</span><span>crc</span><span class="token" style="color:#fefefe">[</span><span class="token" style="color:#00e0e0">0</span><span class="token" style="color:#fefefe">]</span><span> </span><span class="token" style="color:#00e0e0">=</span><span> buffer</span><span class="token" style="color:#fefefe">[</span><span>packet</span><span class="token" style="color:#00e0e0">-&gt;</span><span>length </span><span class="token" style="color:#00e0e0">+</span><span> </span><span class="token" style="color:#00e0e0">1</span><span class="token" style="color:#fefefe">]</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    packet</span><span class="token" style="color:#00e0e0">-&gt;</span><span>crc</span><span class="token" style="color:#fefefe">[</span><span class="token" style="color:#00e0e0">1</span><span class="token" style="color:#fefefe">]</span><span> </span><span class="token" style="color:#00e0e0">=</span><span> buffer</span><span class="token" style="color:#fefefe">[</span><span>packet</span><span class="token" style="color:#00e0e0">-&gt;</span><span>length </span><span class="token" style="color:#00e0e0">+</span><span> </span><span class="token" style="color:#00e0e0">2</span><span class="token" style="color:#fefefe">]</span><span class="token" style="color:#fefefe">;</span><span>
</span>
<span>    </span><span class="token" style="color:#d4d0ab">// Check CRC (if enabled and status bytes appended)</span><span>
</span><span>    </span><span class="token" style="color:#d4d0ab">// This example assumes CRC check is done by hardware</span><span>
</span>
<span>    </span><span class="token" style="color:#00e0e0">return</span><span> true</span><span class="token" style="color:#fefefe">;</span><span>
</span><span></span><span class="token" style="color:#fefefe">}</span><span>
</span>
<span></span><span class="token" style="color:#d4d0ab">// Function to enter RX state</span><span>
</span><span></span><span class="token" style="color:#00e0e0">void</span><span> </span><span class="token" style="color:#ffd700">MAC_CC1201_SetRXState</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#00e0e0">void</span><span class="token" style="color:#fefefe">)</span><span>
</span><span></span><span class="token" style="color:#fefefe">{</span><span>
</span><span>    </span><span class="token" style="color:#ffd700">PHY_CC1201_Strobe</span><span class="token" style="color:#fefefe">(</span><span>CC1201_SRX</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span></span><span class="token" style="color:#fefefe">}</span><span>
</span>
<span></span><span class="token" style="color:#d4d0ab">// Function to enter TX state</span><span>
</span><span></span><span class="token" style="color:#00e0e0">void</span><span> </span><span class="token" style="color:#ffd700">MAC_CC1201_SetTXState</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#00e0e0">void</span><span class="token" style="color:#fefefe">)</span><span>
</span><span></span><span class="token" style="color:#fefefe">{</span><span>
</span><span>    </span><span class="token" style="color:#ffd700">PHY_CC1201_Strobe</span><span class="token" style="color:#fefefe">(</span><span>CC1201_STX</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span></span><span class="token" style="color:#fefefe">}</span></code></div></div></pre>
<hr/>
<h3>3. Network Layer (Optional)</h3>
<p>For many applications, the network layer may not be necessary. If routing or network management features are needed, you can implement them here.</p>
<p><strong>net_cc1201.h</strong></p>
<pre><div><div style="display:flex;justify-content:space-between;width:100%;background-color:rgb(50, 50, 50);font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;border-top-left-radius:0.3rem;border-top-right-radius:0.3rem;border-bottom-left-radius:0;border-bottom-right-radius:0"><span style="text-decoration:none;color:gray;padding:2px;margin:2px 10px 0 10px">&lt;C&gt;</span></div><div style="color:#f8f8f2;background:#2b2b2b;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:0;overflow:auto;border-radius:0.3em;margin-top:0;border-top-left-radius:0;border-top-right-radius:0;border-bottom-left-radius:0.3rem;border-bottom-right-radius:0.3rem;border:none"><code class="language-c" style="color:#f8f8f2;background:none;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">ifndef</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro expression" style="color:#ffa07a">NET_CC1201_H</span><span>
</span><span></span><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">define</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro macro-name" style="color:#ffa07a">NET_CC1201_H</span><span>
</span>
<span></span><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">include</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro" style="color:#abe338">&lt;stdint.h&gt;</span><span>
</span><span></span><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">include</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro" style="color:#abe338">&lt;stdbool.h&gt;</span><span>
</span><span></span><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">include</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro" style="color:#abe338">&quot;mac_cc1201.h&quot;</span><span>
</span>
<span></span><span class="token" style="color:#d4d0ab">// Function prototypes</span><span>
</span><span></span><span class="token" style="color:#00e0e0">void</span><span> </span><span class="token" style="color:#ffd700">NET_CC1201_Init</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#00e0e0">void</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>bool </span><span class="token" style="color:#ffd700">NET_CC1201_SendData</span><span class="token" style="color:#fefefe">(</span><span class="token class-name">uint8_t</span><span> destAddress</span><span class="token" style="color:#fefefe">,</span><span> </span><span class="token" style="color:#00e0e0">const</span><span> </span><span class="token class-name">uint8_t</span><span> </span><span class="token" style="color:#00e0e0">*</span><span>data</span><span class="token" style="color:#fefefe">,</span><span> </span><span class="token class-name">uint8_t</span><span> length</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>bool </span><span class="token" style="color:#ffd700">NET_CC1201_ReceiveData</span><span class="token" style="color:#fefefe">(</span><span>CC1201_Packet_t </span><span class="token" style="color:#00e0e0">*</span><span>packet</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span>
<span></span><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">endif</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro" style="color:#d4d0ab">// NET_CC1201_H</span></code></div></div></pre>
<p><strong>net_cc1201.c</strong></p>
<pre><div><div style="display:flex;justify-content:space-between;width:100%;background-color:rgb(50, 50, 50);font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;border-top-left-radius:0.3rem;border-top-right-radius:0.3rem;border-bottom-left-radius:0;border-bottom-right-radius:0"><span style="text-decoration:none;color:gray;padding:2px;margin:2px 10px 0 10px">&lt;C&gt;</span></div><div style="color:#f8f8f2;background:#2b2b2b;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:0;overflow:auto;border-radius:0.3em;margin-top:0;border-top-left-radius:0;border-top-right-radius:0;border-bottom-left-radius:0.3rem;border-bottom-right-radius:0.3rem;border:none"><code class="language-c" style="color:#f8f8f2;background:none;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">include</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro" style="color:#abe338">&quot;net_cc1201.h&quot;</span><span>
</span>
<span></span><span class="token" style="color:#d4d0ab">// Function to initialize the network layer</span><span>
</span><span></span><span class="token" style="color:#00e0e0">void</span><span> </span><span class="token" style="color:#ffd700">NET_CC1201_Init</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#00e0e0">void</span><span class="token" style="color:#fefefe">)</span><span>
</span><span></span><span class="token" style="color:#fefefe">{</span><span>
</span><span>    </span><span class="token" style="color:#ffd700">MAC_CC1201_Init</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span></span><span class="token" style="color:#fefefe">}</span><span>
</span>
<span></span><span class="token" style="color:#d4d0ab">// Function to send data over the network</span><span>
</span><span>bool </span><span class="token" style="color:#ffd700">NET_CC1201_SendData</span><span class="token" style="color:#fefefe">(</span><span class="token class-name">uint8_t</span><span> destAddress</span><span class="token" style="color:#fefefe">,</span><span> </span><span class="token" style="color:#00e0e0">const</span><span> </span><span class="token class-name">uint8_t</span><span> </span><span class="token" style="color:#00e0e0">*</span><span>data</span><span class="token" style="color:#fefefe">,</span><span> </span><span class="token class-name">uint8_t</span><span> length</span><span class="token" style="color:#fefefe">)</span><span>
</span><span></span><span class="token" style="color:#fefefe">{</span><span>
</span><span>    </span><span class="token" style="color:#00e0e0">return</span><span> </span><span class="token" style="color:#ffd700">MAC_CC1201_SendPacket</span><span class="token" style="color:#fefefe">(</span><span>destAddress</span><span class="token" style="color:#fefefe">,</span><span> data</span><span class="token" style="color:#fefefe">,</span><span> length</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span></span><span class="token" style="color:#fefefe">}</span><span>
</span>
<span></span><span class="token" style="color:#d4d0ab">// Function to receive data from the network</span><span>
</span><span>bool </span><span class="token" style="color:#ffd700">NET_CC1201_ReceiveData</span><span class="token" style="color:#fefefe">(</span><span>CC1201_Packet_t </span><span class="token" style="color:#00e0e0">*</span><span>packet</span><span class="token" style="color:#fefefe">)</span><span>
</span><span></span><span class="token" style="color:#fefefe">{</span><span>
</span><span>    </span><span class="token" style="color:#00e0e0">return</span><span> </span><span class="token" style="color:#ffd700">MAC_CC1201_ReceivePacket</span><span class="token" style="color:#fefefe">(</span><span>packet</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span></span><span class="token" style="color:#fefefe">}</span></code></div></div></pre>
<hr/>
<h3>4. Application Layer</h3>
<p><strong>cc1201.h</strong></p>
<pre><div><div style="display:flex;justify-content:space-between;width:100%;background-color:rgb(50, 50, 50);font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;border-top-left-radius:0.3rem;border-top-right-radius:0.3rem;border-bottom-left-radius:0;border-bottom-right-radius:0"><span style="text-decoration:none;color:gray;padding:2px;margin:2px 10px 0 10px">&lt;C&gt;</span></div><div style="color:#f8f8f2;background:#2b2b2b;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:0;overflow:auto;border-radius:0.3em;margin-top:0;border-top-left-radius:0;border-top-right-radius:0;border-bottom-left-radius:0.3rem;border-bottom-right-radius:0.3rem;border:none"><code class="language-c" style="color:#f8f8f2;background:none;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">ifndef</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro expression" style="color:#ffa07a">CC1201_H</span><span>
</span><span></span><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">define</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro macro-name" style="color:#ffa07a">CC1201_H</span><span>
</span>
<span></span><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">include</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro" style="color:#abe338">&lt;stdint.h&gt;</span><span>
</span><span></span><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">include</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro" style="color:#abe338">&lt;stdbool.h&gt;</span><span>
</span><span></span><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">include</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro" style="color:#abe338">&quot;net_cc1201.h&quot;</span><span>
</span>
<span></span><span class="token" style="color:#d4d0ab">// Function prototypes</span><span>
</span><span></span><span class="token" style="color:#00e0e0">void</span><span> </span><span class="token" style="color:#ffd700">CC1201_Init</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#00e0e0">void</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span></span><span class="token" style="color:#00e0e0">void</span><span> </span><span class="token" style="color:#ffd700">CC1201_SetAddress</span><span class="token" style="color:#fefefe">(</span><span class="token class-name">uint8_t</span><span> address</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span></span><span class="token" style="color:#00e0e0">void</span><span> </span><span class="token" style="color:#ffd700">CC1201_SetChannel</span><span class="token" style="color:#fefefe">(</span><span class="token class-name">uint8_t</span><span> channel</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>bool </span><span class="token" style="color:#ffd700">CC1201_SendMessage</span><span class="token" style="color:#fefefe">(</span><span class="token class-name">uint8_t</span><span> destAddress</span><span class="token" style="color:#fefefe">,</span><span> </span><span class="token" style="color:#00e0e0">const</span><span> </span><span class="token class-name">uint8_t</span><span> </span><span class="token" style="color:#00e0e0">*</span><span>data</span><span class="token" style="color:#fefefe">,</span><span> </span><span class="token class-name">uint8_t</span><span> length</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>bool </span><span class="token" style="color:#ffd700">CC1201_ReceiveMessage</span><span class="token" style="color:#fefefe">(</span><span class="token class-name">uint8_t</span><span> </span><span class="token" style="color:#00e0e0">*</span><span>sourceAddress</span><span class="token" style="color:#fefefe">,</span><span> </span><span class="token class-name">uint8_t</span><span> </span><span class="token" style="color:#00e0e0">*</span><span>data</span><span class="token" style="color:#fefefe">,</span><span> </span><span class="token class-name">uint8_t</span><span> </span><span class="token" style="color:#00e0e0">*</span><span>length</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span>
<span></span><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">endif</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro" style="color:#d4d0ab">// CC1201_H</span></code></div></div></pre>
<p><strong>cc1201.c</strong></p>
<pre><div><div style="display:flex;justify-content:space-between;width:100%;background-color:rgb(50, 50, 50);font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;border-top-left-radius:0.3rem;border-top-right-radius:0.3rem;border-bottom-left-radius:0;border-bottom-right-radius:0"><span style="text-decoration:none;color:gray;padding:2px;margin:2px 10px 0 10px">&lt;C&gt;</span></div><div style="color:#f8f8f2;background:#2b2b2b;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:0;overflow:auto;border-radius:0.3em;margin-top:0;border-top-left-radius:0;border-top-right-radius:0;border-bottom-left-radius:0.3rem;border-bottom-right-radius:0.3rem;border:none"><code class="language-c" style="color:#f8f8f2;background:none;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">include</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro" style="color:#abe338">&quot;cc1201.h&quot;</span><span>
</span>
<span></span><span class="token" style="color:#d4d0ab">// Function to initialize the CC1201 transceiver</span><span>
</span><span></span><span class="token" style="color:#00e0e0">void</span><span> </span><span class="token" style="color:#ffd700">CC1201_Init</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#00e0e0">void</span><span class="token" style="color:#fefefe">)</span><span>
</span><span></span><span class="token" style="color:#fefefe">{</span><span>
</span><span>    </span><span class="token" style="color:#ffd700">NET_CC1201_Init</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span></span><span class="token" style="color:#fefefe">}</span><span>
</span>
<span></span><span class="token" style="color:#d4d0ab">// Function to set the node address</span><span>
</span><span></span><span class="token" style="color:#00e0e0">void</span><span> </span><span class="token" style="color:#ffd700">CC1201_SetAddress</span><span class="token" style="color:#fefefe">(</span><span class="token class-name">uint8_t</span><span> address</span><span class="token" style="color:#fefefe">)</span><span>
</span><span></span><span class="token" style="color:#fefefe">{</span><span>
</span><span>    </span><span class="token" style="color:#ffd700">MAC_CC1201_SetAddress</span><span class="token" style="color:#fefefe">(</span><span>address</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span></span><span class="token" style="color:#fefefe">}</span><span>
</span>
<span></span><span class="token" style="color:#d4d0ab">// Function to set the communication channel</span><span>
</span><span></span><span class="token" style="color:#00e0e0">void</span><span> </span><span class="token" style="color:#ffd700">CC1201_SetChannel</span><span class="token" style="color:#fefefe">(</span><span class="token class-name">uint8_t</span><span> channel</span><span class="token" style="color:#fefefe">)</span><span>
</span><span></span><span class="token" style="color:#fefefe">{</span><span>
</span><span>    </span><span class="token" style="color:#ffd700">MAC_CC1201_SetChannel</span><span class="token" style="color:#fefefe">(</span><span>channel</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span></span><span class="token" style="color:#fefefe">}</span><span>
</span>
<span></span><span class="token" style="color:#d4d0ab">// Function to send a message</span><span>
</span><span>bool </span><span class="token" style="color:#ffd700">CC1201_SendMessage</span><span class="token" style="color:#fefefe">(</span><span class="token class-name">uint8_t</span><span> destAddress</span><span class="token" style="color:#fefefe">,</span><span> </span><span class="token" style="color:#00e0e0">const</span><span> </span><span class="token class-name">uint8_t</span><span> </span><span class="token" style="color:#00e0e0">*</span><span>data</span><span class="token" style="color:#fefefe">,</span><span> </span><span class="token class-name">uint8_t</span><span> length</span><span class="token" style="color:#fefefe">)</span><span>
</span><span></span><span class="token" style="color:#fefefe">{</span><span>
</span><span>    </span><span class="token" style="color:#00e0e0">return</span><span> </span><span class="token" style="color:#ffd700">NET_CC1201_SendData</span><span class="token" style="color:#fefefe">(</span><span>destAddress</span><span class="token" style="color:#fefefe">,</span><span> data</span><span class="token" style="color:#fefefe">,</span><span> length</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span></span><span class="token" style="color:#fefefe">}</span><span>
</span>
<span></span><span class="token" style="color:#d4d0ab">// Function to receive a message</span><span>
</span><span>bool </span><span class="token" style="color:#ffd700">CC1201_ReceiveMessage</span><span class="token" style="color:#fefefe">(</span><span class="token class-name">uint8_t</span><span> </span><span class="token" style="color:#00e0e0">*</span><span>sourceAddress</span><span class="token" style="color:#fefefe">,</span><span> </span><span class="token class-name">uint8_t</span><span> </span><span class="token" style="color:#00e0e0">*</span><span>data</span><span class="token" style="color:#fefefe">,</span><span> </span><span class="token class-name">uint8_t</span><span> </span><span class="token" style="color:#00e0e0">*</span><span>length</span><span class="token" style="color:#fefefe">)</span><span>
</span><span></span><span class="token" style="color:#fefefe">{</span><span>
</span><span>    CC1201_Packet_t packet</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token" style="color:#00e0e0">if</span><span> </span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#ffd700">NET_CC1201_ReceiveData</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#00e0e0">&amp;</span><span>packet</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">)</span><span>
</span><span>    </span><span class="token" style="color:#fefefe">{</span><span>
</span><span>        </span><span class="token" style="color:#00e0e0">*</span><span>sourceAddress </span><span class="token" style="color:#00e0e0">=</span><span> packet</span><span class="token" style="color:#fefefe">.</span><span>address</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>        </span><span class="token" style="color:#00e0e0">*</span><span>length </span><span class="token" style="color:#00e0e0">=</span><span> packet</span><span class="token" style="color:#fefefe">.</span><span>length</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>        </span><span class="token" style="color:#00e0e0">for</span><span> </span><span class="token" style="color:#fefefe">(</span><span class="token class-name">uint8_t</span><span> i </span><span class="token" style="color:#00e0e0">=</span><span> </span><span class="token" style="color:#00e0e0">0</span><span class="token" style="color:#fefefe">;</span><span> i </span><span class="token" style="color:#00e0e0">&lt;</span><span> packet</span><span class="token" style="color:#fefefe">.</span><span>length</span><span class="token" style="color:#fefefe">;</span><span> i</span><span class="token" style="color:#00e0e0">++</span><span class="token" style="color:#fefefe">)</span><span>
</span><span>        </span><span class="token" style="color:#fefefe">{</span><span>
</span><span>            data</span><span class="token" style="color:#fefefe">[</span><span>i</span><span class="token" style="color:#fefefe">]</span><span> </span><span class="token" style="color:#00e0e0">=</span><span> packet</span><span class="token" style="color:#fefefe">.</span><span>payload</span><span class="token" style="color:#fefefe">[</span><span>i</span><span class="token" style="color:#fefefe">]</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>        </span><span class="token" style="color:#fefefe">}</span><span>
</span><span>        </span><span class="token" style="color:#00e0e0">return</span><span> true</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token" style="color:#fefefe">}</span><span>
</span><span>    </span><span class="token" style="color:#00e0e0">return</span><span> false</span><span class="token" style="color:#fefefe">;</span><span>
</span><span></span><span class="token" style="color:#fefefe">}</span></code></div></div></pre>
<hr/>
<h3>Usage Example</h3>
<p><strong>main.c</strong></p>
<pre><div><div style="display:flex;justify-content:space-between;width:100%;background-color:rgb(50, 50, 50);font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, &quot;Liberation Mono&quot;, &quot;Courier New&quot;, monospace;border-top-left-radius:0.3rem;border-top-right-radius:0.3rem;border-bottom-left-radius:0;border-bottom-right-radius:0"><span style="text-decoration:none;color:gray;padding:2px;margin:2px 10px 0 10px">&lt;C&gt;</span></div><div style="color:#f8f8f2;background:#2b2b2b;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:0;overflow:auto;border-radius:0.3em;margin-top:0;border-top-left-radius:0;border-top-right-radius:0;border-bottom-left-radius:0.3rem;border-bottom-right-radius:0.3rem;border:none"><code class="language-c" style="color:#f8f8f2;background:none;font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">include</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro" style="color:#abe338">&lt;stdio.h&gt;</span><span>
</span><span></span><span class="token macro directive-hash" style="color:#ffa07a">#</span><span class="token macro directive" style="color:#00e0e0">include</span><span class="token macro" style="color:#ffa07a"> </span><span class="token macro" style="color:#abe338">&quot;cc1201.h&quot;</span><span>
</span>
<span></span><span class="token" style="color:#00e0e0">int</span><span> </span><span class="token" style="color:#ffd700">main</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#00e0e0">void</span><span class="token" style="color:#fefefe">)</span><span>
</span><span></span><span class="token" style="color:#fefefe">{</span><span>
</span><span>    </span><span class="token" style="color:#d4d0ab">// Initialize the CC1201 transceiver</span><span>
</span><span>    </span><span class="token" style="color:#ffd700">CC1201_Init</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span>
<span>    </span><span class="token" style="color:#d4d0ab">// Set the node address</span><span>
</span><span>    </span><span class="token" style="color:#ffd700">CC1201_SetAddress</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#00e0e0">0x02</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span>
<span>    </span><span class="token" style="color:#d4d0ab">// Set the communication channel</span><span>
</span><span>    </span><span class="token" style="color:#ffd700">CC1201_SetChannel</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#00e0e0">0x01</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span>
<span>    </span><span class="token" style="color:#d4d0ab">// Send a message</span><span>
</span><span>    </span><span class="token class-name">uint8_t</span><span> message</span><span class="token" style="color:#fefefe">[</span><span class="token" style="color:#fefefe">]</span><span> </span><span class="token" style="color:#00e0e0">=</span><span> </span><span class="token" style="color:#abe338">&quot;Hello, World!&quot;</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token" style="color:#00e0e0">if</span><span> </span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#ffd700">CC1201_SendMessage</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#00e0e0">0x01</span><span class="token" style="color:#fefefe">,</span><span> message</span><span class="token" style="color:#fefefe">,</span><span> </span><span class="token" style="color:#00e0e0">sizeof</span><span class="token" style="color:#fefefe">(</span><span>message</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">)</span><span>
</span><span>    </span><span class="token" style="color:#fefefe">{</span><span>
</span><span>        </span><span class="token" style="color:#ffd700">printf</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#abe338">&quot;Message sent successfully.\n&quot;</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token" style="color:#fefefe">}</span><span>
</span><span>    </span><span class="token" style="color:#00e0e0">else</span><span>
</span><span>    </span><span class="token" style="color:#fefefe">{</span><span>
</span><span>        </span><span class="token" style="color:#ffd700">printf</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#abe338">&quot;Failed to send message.\n&quot;</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token" style="color:#fefefe">}</span><span>
</span>
<span>    </span><span class="token" style="color:#d4d0ab">// Receive a message</span><span>
</span><span>    </span><span class="token class-name">uint8_t</span><span> sourceAddress</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token class-name">uint8_t</span><span> receivedData</span><span class="token" style="color:#fefefe">[</span><span>MAX_PAYLOAD_SIZE</span><span class="token" style="color:#fefefe">]</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token class-name">uint8_t</span><span> length</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token" style="color:#00e0e0">if</span><span> </span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#ffd700">CC1201_ReceiveMessage</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#00e0e0">&amp;</span><span>sourceAddress</span><span class="token" style="color:#fefefe">,</span><span> receivedData</span><span class="token" style="color:#fefefe">,</span><span> </span><span class="token" style="color:#00e0e0">&amp;</span><span>length</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">)</span><span>
</span><span>    </span><span class="token" style="color:#fefefe">{</span><span>
</span><span>        </span><span class="token" style="color:#ffd700">printf</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#abe338">&quot;Received message from address 0x%02X: &quot;</span><span class="token" style="color:#fefefe">,</span><span> sourceAddress</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>        </span><span class="token" style="color:#00e0e0">for</span><span> </span><span class="token" style="color:#fefefe">(</span><span class="token class-name">uint8_t</span><span> i </span><span class="token" style="color:#00e0e0">=</span><span> </span><span class="token" style="color:#00e0e0">0</span><span class="token" style="color:#fefefe">;</span><span> i </span><span class="token" style="color:#00e0e0">&lt;</span><span> length</span><span class="token" style="color:#fefefe">;</span><span> i</span><span class="token" style="color:#00e0e0">++</span><span class="token" style="color:#fefefe">)</span><span>
</span><span>        </span><span class="token" style="color:#fefefe">{</span><span>
</span><span>            </span><span class="token" style="color:#ffd700">putchar</span><span class="token" style="color:#fefefe">(</span><span>receivedData</span><span class="token" style="color:#fefefe">[</span><span>i</span><span class="token" style="color:#fefefe">]</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>        </span><span class="token" style="color:#fefefe">}</span><span>
</span><span>        </span><span class="token" style="color:#ffd700">putchar</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#abe338">&#x27;\n&#x27;</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token" style="color:#fefefe">}</span><span>
</span><span>    </span><span class="token" style="color:#00e0e0">else</span><span>
</span><span>    </span><span class="token" style="color:#fefefe">{</span><span>
</span><span>        </span><span class="token" style="color:#ffd700">printf</span><span class="token" style="color:#fefefe">(</span><span class="token" style="color:#abe338">&quot;No message received.\n&quot;</span><span class="token" style="color:#fefefe">)</span><span class="token" style="color:#fefefe">;</span><span>
</span><span>    </span><span class="token" style="color:#fefefe">}</span><span>
</span>
<span>    </span><span class="token" style="color:#00e0e0">return</span><span> </span><span class="token" style="color:#00e0e0">0</span><span class="token" style="color:#fefefe">;</span><span>
</span><span></span><span class="token" style="color:#fefefe">}</span></code></div></div></pre>
<hr/>
<h3>Notes:</h3>
<ul>
<li>
<p><strong>SPI Interface</strong>: The SPI functions (<code style="background-color:#f1f1f1;padding:2px 4px;marigin:0 4px;border-radius:4px;border:1px solid;border-color:#ddd">SPI_Init</code>, <code style="background-color:#f1f1f1;padding:2px 4px;marigin:0 4px;border-radius:4px;border:1px solid;border-color:#ddd">SPI_Select</code>, <code style="background-color:#f1f1f1;padding:2px 4px;marigin:0 4px;border-radius:4px;border:1px solid;border-color:#ddd">SPI_Deselect</code>, <code style="background-color:#f1f1f1;padding:2px 4px;marigin:0 4px;border-radius:4px;border:1px solid;border-color:#ddd">SPI_Transfer</code>) are assumed to be implemented elsewhere, as per your requirement.</p>
</li>
<li>
<p><strong>Register Configuration</strong>: The register configurations in <code style="background-color:#f1f1f1;padding:2px 4px;marigin:0 4px;border-radius:4px;border:1px solid;border-color:#ddd">MAC_CC1201_Init()</code> are placeholders. You should configure all necessary registers according to your specific application and the CC1201 datasheet.</p>
</li>
<li>
<p><strong>OSI Layering</strong>: The code is structured to reflect an OSI-like layering, with each layer handling specific responsibilities:</p>
<ul>
<li><strong>Physical Layer</strong>: Direct hardware interaction.</li>
<li><strong>Data Link Layer</strong>: Packet framing, addressing, error detection.</li>
<li><strong>Network Layer</strong>: Data routing and network management (simplified here).</li>
<li><strong>Application Layer</strong>: High-level functions for the user application.</li>
</ul>
</li>
<li>
<p><strong>Error Handling</strong>: Basic error handling is included. Depending on your application&#x27;s requirements, you might want to enhance error detection and handling mechanisms.</p>
</li>
<li>
<p><strong>Thread Safety and Concurrency</strong>: This code does not consider multithreading. If your application uses multiple threads, ensure that access to shared resources is properly synchronized.</p>
</li>
<li>
<p><strong>Hardware-Specific Considerations</strong>: Make sure to adjust the frequency calculations, channel settings, and other hardware-specific parameters according to your needs and regional regulations.</p>
</li>
<li>
<p><strong>Testing</strong>: Before deploying, thoroughly test the code in your hardware environment to ensure proper functionality.</p>
</li>
</ul>
<hr/>
<p>This comprehensive C API for the CC1201 transceiver should provide a solid foundation for your application development, following the OSI layering pattern and assuming the SPI interface already exists.</p></div></div>
<hr />
</div>

        <hr />
        <a href="https://chatboxai.app" style="display: flex; align-items: center;" class="text-sky-500" target="_blank">
            <img src='https://chatboxai.app/icon.png' class="w-12 pr-2">
            <b style='font-size:30px'>Chatbox AI</b>
        </a>
        <p><a a href="https://chatboxai.app" target="_blank">https://chatboxai.app</a></p>
    </div>
</body>
</html>
